<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[准备面试--CSS&HTML-2]]></title>
    <url>%2F2019%2F03%2F12%2F%E5%87%86%E5%A4%87%E9%9D%A2%E8%AF%95--CSS%26HTML-2%2F</url>
    <content type="text"><![CDATA[准备面试–CSS&amp;HTML-2No.1 两列布局1234&lt;body&gt; &lt;div id=&quot;left&quot;&gt;&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;&lt;/div&gt;&lt;/body&gt; 左列定宽，右列自适应 利用float+margin 1234567891011#left&#123; background: #f00; width: 100px; height: 500px; float: left;&#125;#right&#123; background: #0f0; height: 500px; margin-left: 100px;&#125; 利用float+overflow 1234567891011#left&#123; background: #f00; width: 100px; height: 500px; float: left;&#125;#right&#123; overflow: hidden; background-color: #0f0; height: 500px;&#125; 使用table实现 123456789101112131415#parent&#123; width: 100%; display: table; height: 500px;&#125;#left&#123; width: 100px; background-color: #f00;&#125;#right &#123; background-color: #0f0;&#125;#left,#right&#123; display: table-cell; /*利用单元格自动分配宽度*/&#125; 使用绝对定位实现 12345678910111213141516171819#parent&#123; position: relative; /*子绝父相*/&#125;#left &#123; position: absolute; top: 0; left: 0; background-color: #f00; width: 100px; height: 500px;&#125;#right &#123; position: absolute; top: 0; left: 100px; /*值大于等于#left的宽度*/ right: 0; background-color: #0f0; height: 500px;&#125; 使用flex实现 12345678910111213#parent&#123; width: 100%; height: 500px; display: flex;&#125;#left &#123; width: 100px; background-color: #f00;&#125;#right &#123; flex: 1; /*均分了父元素剩余空间*/ background-color: #0f0;&#125; 左列自适应,右列定宽 使用float+margin实现 1234567891011121314151617#parent&#123; height: 500px; padding-left: 100px; /*抵消#left的margin-left以达到#parent水平居中*/&#125;#left &#123; width: 100%; height: 500px; float: left; margin-left: -100px; /*正值等于#right的宽度*/ background-color: #f00;&#125;#right &#123; height: 500px; width: 100px; float: right; background-color: #0f0;&#125; 使用float+overflow实现 html: 123456&lt;body&gt;&lt;div id=&quot;parent&quot;&gt; &lt;div id=&quot;right&quot;&gt;右列定宽&lt;/div&gt; &lt;div id=&quot;left&quot;&gt;左列自适应&lt;/div&gt; &lt;!--顺序要换一下--&gt;&lt;/div&gt;&lt;/body&gt; css: 123456789101112#left &#123; overflow: hidden; /*触发bfc*/ height: 500px; background-color: #f00;&#125;#right &#123; margin-left: 10px; /*margin需要定义在#right中*/ float: right; width: 100px; height: 500px; background-color: #0f0;&#125; 使用table实现 1234567891011121314#parent&#123; width: 100%; height: 500px; display: table;&#125;#left &#123; background-color: #f00; display: table-cell;&#125;#right &#123; width: 100px; background-color: #0f0; display: table-cell;&#125; 使用绝对定位实现 12345678910111213141516171819#parent&#123; position: relative; /*子绝父相*/&#125;#left &#123; position: absolute; top: 0; left: 0; right: 100px; /*大于等于#rigth的宽度*/ background-color: #f00; height: 500px;&#125;#right &#123; position: absolute; top: 0; right: 0; background-color: #0f0; width: 100px; height: 500px;&#125; 使用flex 123456789101112#parent&#123; height: 500px; display: flex;&#125;#left &#123; flex: 1; background-color: #f00;&#125;#right &#123; width: 100px; background-color: #0f0;&#125; 一列不定,一列自适应 使用float+overflow实现 1234567891011#left &#123; margin-right: 10px; float: left; /*只设置浮动,不设宽度*/ height: 500px; background-color: #f00;&#125;#right &#123; overflow: hidden; /*触发bfc*/ height: 500px; background-color: #0f0;&#125; 使用flex 12345678910111213#parent&#123; display: flex;&#125;#left &#123; /*不设宽度*/ margin-right: 10px; height: 500px; background-color: #f00;&#125;#right &#123; height: 500px; background-color: #0f0; flex: 1; /*均分#parent剩余的部分*/&#125; No.2 三列布局两列定宽,一列自适应 float+margin html: 1234567&lt;body&gt;&lt;div id=&quot;parent&quot;&gt; &lt;div id=&quot;left&quot;&gt;左列定宽&lt;/div&gt; &lt;div id=&quot;center&quot;&gt;中间定宽&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;右列自适应&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; css: 123456789101112131415161718192021#parent&#123; min-width: 310px; /*100+10+200,防止宽度不够,子元素换行*/&#125;#left &#123; margin-right: 10px; /*#left和#center间隔*/ float: left; width: 100px; height: 500px; background-color: #f00;&#125;#center&#123; float: left; width: 200px; height: 500px; background-color: #eeff2b;&#125;#right &#123; margin-left: 320px; /*等于#left和#center的宽度之和加上间隔,多出来的就是#right和#center的间隔*/ height: 500px; background-color: #0f0;&#125; 使用float+overflow实现 12345678910111213141516171819202122#parent&#123; min-width: 320px; /*100+10+200+20,防止宽度不够,子元素换行*/&#125;#left &#123; margin-right: 10px; /*间隔*/ float: left; width: 100px; height: 500px; background-color: #f00;&#125;#center&#123; margin-right: 10px; /*在此定义和#right的间隔*/ float: left; width: 200px; height: 500px; background-color: #eeff2b;&#125;#right &#123; overflow: hidden; /*触发bfc*/ height: 500px; background-color: #0f0;&#125; 使用flex 123456789101112131415161718#parent &#123; height: 500px; display: flex;&#125;#left &#123; margin-right: 10px; /*间距*/ width: 100px; background-color: #f00;&#125;#center &#123; margin-right: 10px; /*间距*/ width: 200px; background-color: #eeff2b;&#125;#right &#123; flex: 1; /*均分#parent剩余的部分达到自适应*/ background-color: #0f0;&#125; 两侧定宽,中间自适应 双飞翼布局方法 html： 12345678910111213&lt;body&gt;&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;&lt;div id=&quot;parent&quot;&gt; &lt;!--中间栏需要放在前面--&gt; &lt;div id=&quot;center&quot;&gt; &lt;div id=&quot;center_inbox&quot;&gt;中间自适应&lt;/div&gt; &lt;hr&gt; &lt;!--方便观察原理--&gt; &lt;/div&gt; &lt;div id=&quot;left&quot;&gt;左列定宽&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;右列定宽&lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;footer&quot;&gt;&lt;/div&gt;&lt;/body&gt; css： 123456789101112131415161718192021222324252627282930313233343536#header &#123; height: 60px; background-color: #ccc;&#125;#left &#123; float: left; width: 100px; height: 500px; margin-left: -100%; /*调整#left的位置,值等于自身宽度*/ background-color: #f00; opacity: 0.5;&#125;#center &#123; height: 500px; float: left; width: 100%; background-color: #eeff2b;&#125;#center_inbox&#123; height: 480px; border: 1px solid #000; margin: 0 220px 0 120px; /*关键!!!左右边界等于左右盒子的宽度,多出来的为盒子间隔*/&#125;#right &#123; float: left; width: 200px; height: 500px; margin-left: -200px; /*使right到指定的位置,值等于自身宽度*/ background-color: #0f0; opacity: 0.5;&#125;#footer &#123; clear: both; /*注意清除浮动!!*/ height: 60px; background-color: #ccc;&#125; 圣杯布局方法 1234567891011121314151617181920212223242526272829303132333435363738394041#header&#123; height: 60px; background-color: #ccc;&#125;#parent &#123; box-sizing: border-box; height: 500px; padding: 0 215px 0 115px; /*为了使#center摆正,左右padding分别等于左右盒子的宽,可以结合左右盒子相对定位的left调整间距*/&#125;#left &#123; margin-left: -100%; /*使#left上去一行*/ position: relative; left: -115px; /*相对定位调整#left的位置,正值大于或等于自身宽度*/ float: left; width: 100px; height: 500px; background-color: #f00; opacity: 0.5;&#125;#center &#123; float: left; width: 100%; /*由于#parent的padding,达到自适应的目的*/ height: 500px; box-sizing: border-box; border: 1px solid #000; background-color: #eeff2b;&#125;#right &#123; position: relative; left: 215px; /*相对定位调整#right的位置,大于或等于自身宽度*/ width: 200px; height: 500px; margin-left: -200px; /*使#right上去一行*/ float: left; background-color: #0f0; opacity: 0.5;&#125;#footer&#123; height: 60px; background-color: #ccc;&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[准备面试--CSS&HTML-1]]></title>
    <url>%2F2019%2F02%2F28%2F%E5%87%86%E5%A4%87%E9%9D%A2%E8%AF%95--HTML%26CSS-1%2F</url>
    <content type="text"><![CDATA[准备面试–CSS&amp;HTML-1No.1 块级元素和行内元素有哪些？块级：&lt;div&gt;, &lt;p&gt;, &lt;form&gt;, &lt;h1&gt;~&lt;h6&gt;, &lt;hr&gt;, &lt;ul&gt;, &lt;ol&gt;, &lt;address&gt; 行内：&lt;a&gt;, &lt;span&gt;, &lt;i&gt;, &lt;em&gt;, &lt;br&gt;, &lt;strong&gt; No.2 块级元素和行内的特点。 块级：1、独占一行。 2、长度、宽度、行高可设置。 3、宽度没有设置时，默认为100%。 4、块级元素中可以包含块级元素和行内元素。 行内：1、和其他元素在一行中。2、高度，宽度以及内边距都是不能设置的。3、宽高就是内容的宽高，不能设置。4、行内元素内部只能包含行内元素，不能包含块级元素 No.3 img是什么类型的元素？ img属于行内替换元素 行内替换元素：height/width/padding/margin均可用。效果等于块级元素。 行内非替换元素：height/width/padding top、bottom/margin top、bottom均没有效果，只能用padding left、right/margin left、right改变宽度。 从元素本身的特点来说，分为不可替换元素和替换元素。HTML大多数元素是不可替换元素，即其内容直接表现给客户端。 替换元素就是根据元素的标签和属性，来决定元素的具体显示内容。例如浏览器会根据的src属性的值来读取图片的信息并显示出来。 HTML中的&lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;object&gt;都是替换元素 No.4 Doctype的作用？标准模式和兼容模式各有什么区别？ Doctype作用：用于向浏览器声明使用标准模式来解析文档。 标准模式：以浏览器最高级别来解析文档。 兼容模式：向后兼容的方式来解析文档。 No.5 为什么HTML5只需要写&lt;!DOCTYPE html&gt;？ 因为HTML5不是SGML的子集，所以不需要DTD引用，但是需要DOCTYPE来规范行为。 而HTML4.01是基于SGML，所以需要DTD引用，来告诉浏览器文档所使用的文档类型。 SGML：标准通用标记语言。 DTD：Docuemnt Type Definition，文档类型定义。 No.6 页面导入样式时，使用link和@import有什么区别？ link 在浏览器加载页面的时候并行加载，而@import需要等页面加载完成之后才会加载。 link 不存在兼容性问题，而@import是css2.1提出的，IE5以上才能支持。 link 还可以加载RSS和使用rel属性，@import只能加载css。 link 加载的样式可以通过JS更改，而@import加载的样式不可以被JS更改。 No.7 介绍一下你对浏览器内核的理解？ 渲染引擎：负责取得网页的内容(HTML,XML,图像等等)，整理讯息(引入CSS等)，通过计算来显示出网页(这个过程也称为回流)，然后输出至显卡，最后渲染为网页(这个过程称为重绘) JS引擎：获取网页的JS部分用来解析和执行以实现网页的动态效果 No.8 水平居中文本/行内元素/行内块级元素:text-align只控制行内内容(文字、行内元素、行内块级元素)如何相对他的块父元素对齐 123#parent&#123; text-align: center;&#125; 单个块级元素1234#son&#123; width: 100px; margin: 0 auto;&#125; 必须定宽，并且值不能为auto；宽度要小于父元素，否则无效 多个块级元素123456#parent&#123; text-align: center;&#125;.son&#123; display: inline-block; /*改为行内或者行内块级形式，以达到text-align对其生效*/&#125; 只对行内内容有效；属性会继承影响到后代行内内容；块级改为inline-block换行、空格会产生元素间隔 使用绝对定位原理：子绝父相，top、right、bottom、left的值是相对于父元素尺寸的，然后margin或者transform是相对于自身尺寸的，组合使用达到水平居中的目的 12345678910111213#parent&#123; height: 200px; width: 200px; position: relative; &#125;#son&#123; position: absolute; left: 50%; /*父元素宽度一半,这里等同于left:100px*/ transform: translateX(-50%); /*自身宽度一半,等同于margin-left: -50px;*/ width: 100px; /*定宽*/ height: 100px; background-color: #00ff00; 代码较多；脱离文档流；使用margin-left需要知道宽度值；使用transform兼容性不好（ie9+） 任意个元素原理：就是设置当前主轴对齐方式为居中。flex无非就是主轴侧轴是重点，然后就是排列方式的设置。 1234#parent&#123; display: flex; justify-content: center;&#125; No.9 垂直居中单行文本/行内元素/行内块级元素1234#parent&#123; height: 100px; line-height: 100px; /*与height等值*/&#125; 只能用于单行行内内容，要知道高度的值 多行文本/行内元素/行内块级元素1234#parent&#123; height: 150px; line-height: 30px; // 元素在页面呈现为5行，则line-height的值为height/5&#125; 只能用于行内内容；需要知道高度和最终呈现多少行来计算出line-height的值，建议用span包裹多行文本 图片123456#parent&#123; height: 150px; line-height: 150px; font-size: 0;&#125;img#son&#123;vertical-align: middle;&#125; 需要添加font-size: 0; 才可以完全的垂直居中；不过需要主要，html#parent包裹img之间需要有换行或空格 单个块级元素 使用table-cell实现 1234#parent&#123; display: table-cell; vertical-align: middle;&#125; 使用绝对定位实现 12345678910#parent&#123; position: relative; height: 150px;&#125;#son&#123; position: absolute; top: 50%; transform: translateY(-50%); height: 50px;&#125; 1234567891011//原理：当top、bottom为0时,margin-top&amp;bottom会无限延伸占满空间并且平分#parent&#123; position: relative;&#125;#son&#123; position: absolute; margin: auto 0; top: 0; bottom: 0; height: 50px;&#125; 使用flex 123456789#parent&#123; display: flex; align-items: center;&#125;//else#parent&#123; display: flex; &#125;#son&#123; align-self: center; &#125; 任意个元素12345678910111213#parent&#123; display: flex; align-items: center;&#125;//else#parent&#123; display: flex;&#125;.son&#123; align-self: center;&#125; No.10 水平垂直居中行内/行内块级/图片12345678910#parent&#123; text-align: center; height: 150px; line-height: 150px; font-size: 0;&#125;#son&#123; // display: inline 如果是块级元素需要改为行内元素才能生效 vertical-align: middle;&#125; table-cell123456789101112#parent&#123; height: 150px; width: 200px; display: table-cell; vertical-align: middle; // text-align: center; 行内元素&#125;#son&#123; // margin: 0 auto; 块级元素 width: 100px; height: 50px;&#125; 绝对定位123456789#parent&#123; position: relative;&#125;#son&#123; position: absolute; top: 50%: left: 50; transform: translate(-50%, -50%);&#125; 绝对居中原理：当top、bottom为0时,margin-top&amp;bottom设置auto的话会无限延伸占满空间并且平分；当left、right为0时,margin-left&amp;right设置auto的话会无限延伸占满空间并且平分 12345678910111213#parent&#123; position: relative;&#125;#son&#123; position: absolute; margin: 0; top: 0; left: 0; right: 0; bottom: 0; height: 50px; width: 60px;&#125; flex123456789101112131415#parent&#123; display: flex; justify-content: center; align-item: center;&#125;//else#parent&#123; display: flex; justify-content: center;&#125;#son&#123; align-self: center;&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Express构建Web程序]]></title>
    <url>%2F2019%2F02%2F16%2F%E4%BD%BF%E7%94%A8Express%E6%9E%84%E5%BB%BAWeb%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[使用Express构建Web程序12var express = require(&apos;express&apos;);var app = express(); app为一个Express应用程序实例对象，app.listen(1337, &#39;127.0.0.1&#39;)指定服务器所要监听的地址。 app.get(path,callback)接收客户端提供的GET请求并返回服务器端响应结果。callback =&gt; function(req,res){...} 在Express框架中，为http.ServerResponse对象提供一个send方法，用于发送一个服务器的响应结果。该方法不需要单独发送响应头信息，会自动计算头信息；也不需要用end方法结束响应的发送。 设置路由在路由中，可以使用：+参数名的方式指定一个参数。在路由中，可以使用正则表达式。在路由中，可以使用通配符。 使用各种提交数据或请求数据的方法12345app.get(path, callback)app.post(path, callback)app.put(path, callback)app.delete(path, callback)app.all(path, callback) 中间件在Express框架中，允许通过中间件的使用来调用各种第三方库，这让我们的开发工作变得更为方便，也使得我们可以开发出各种更为强大的应用程序。 一个中间件是一个用于处理客户端请求的函数。一个HTTP服务器中可能会使用到各种中间件。当接收到一个客户端时，首先将该请求提交给第一个中间件函数，每一个中间件函数内部都封装一个next回调函数，在一个中间件函数内部可以判断是否调用next回调函数来处理客户端请求。function middleware(req,res,next){next()} 在Express中，使用应用程序实例对象的use方法来调用一个中间件，app.use([path],function) path用于指定何种路径应用中间件 12345app.get(path, [callback], callback)app.post(path, [callback], callback)app.put(path, [callback], callback)app.delete(path, [callback], callback)app.all(path, [callback], callback) 在这些方法path和callback中间，可以使用一个或多个参数，每一个参数值均为一个中间件函数。在使用多个中间件函数时，当在前一个中间件函数中调用next方法时，调用后一个中间件函数；当在最后一个中间件函数中调用next方法时，调用最后一个callback参数值的回调函数。 Express框架中内置的中间件basicAuth中间件为网站添加身份认证功能。在使用该中间件之后，用户访问网站时必须输入用户名与密码才能访问网站。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于TCP与UDP的数据通信]]></title>
    <url>%2F2019%2F02%2F13%2F%E5%9F%BA%E4%BA%8ETCP%E4%B8%8EUDP%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[基于TCP与UDP的数据通信使用net模块实现基于TCP的数据通信创建TCP服务器123var server = net.createServer([option],[connectionListener])[connectionListener] ==&gt; function(socket)&#123;...&#125; //socket为该TCP服务器监听的socket端口对象 在创建TCP服务器之后，使用listen方法通知服务器开始监听客户端链接。三种方法。 server.listen(port,[host],[backlog],[callback]) port监听端口号，参数值为0时随机分配；host指定监听的IP地址或主机名，省略则监听全部客户端链接；backlog指定位于等待队列的客户端链接的最大数量，默认511。 server.listen(path,[callback]) 用于通知一个使用unix端口的服务器开始监听来自于指定路径的客户端链接，path指定需要监听的路径。 server.listen(handle,[callback]) 用于通知一个TCP服务器开始监听来自于socket句柄。句柄可以是TCP服务器对象，可以是socket端口对象，文件描述等。 如果不使用callback，也可以通过server.on(&#39;listening&#39;, function(){...}。当监听地址或端口被占用，将产生“EADDRINUSE”的错误，并触发error事件。 可以用address方法来查看该服务器所监听的地址信息，在服务器触发listening事件之后再调用该方法。var address = server.address()，address是一个对象，其下有三个属性，port监听端口号，address监听地址，family表明是ipv4还是ipv6 可以使用getConnections方法查看当前与TCP服务器建立连接的客户端数量。可以通过server.maxConnections设置最大链接数量 1234server.getConnections(function(err,count)&#123; ...&#125;)//count 为获取到的客户端链接数 最后可以使用close方法让服务器拒绝所有新的客户端链接，server.close([callback])。在调用时并不会断开现有连接。 socket端口对象使用net.Socket代表一个socket端口对象。在使用createServer方法的connectionListener参数所指定的回调函数的参数值即为一个被自动创建的net.Socket对象。 socket对象可被用来读取客户端发送的流数据，每次接收到客户端发送的流数据时触发data事件 pipe将客户端发送的流数据写入文件等对象中 socket.pipe(destination,[options]),destination为可写入数据流对象。使用socket.unpipe([destination])取消目标对象的写入操作，若不用参数，则取消所有的pipe写入操作。 创建TCP客户端var net = new net.Socket([options])options的内容：fd，socket文件描述符；type，协议；allowHalfOpen。 创建socket端口对象之后，可以使用两种connect方法连接TCP服务器 socket.connect(port, [host], [connectListener]) port需要链接的TCP服务器端口；host需要连接的TCP服务器地址，不指定则默认为localhost；最后一个参数为连接成功时的回调函数。也可以不指定connectListener参数，而是通过监听socket对象的connect事件来处理连接成功时的操作。 socket.connect(path, [connectListener]) 用于与unix端口的服务器进行连接。 socket建立连接后，客户端和服务端都具有如下属性：remoteAddress、remotePort、localAddress、localPort。 socket.write(data,[encoding],[callback])用来向客户端或者服务端写入数据。 发生错误触发error事件，socket.on(&#39;error&#39;, function(err){})，在捕捉到错误之后，要使用socket.destroy()销毁该socket端口对象，确保该socket端口对象不会被利用。 使用socket.end([data],[encoding])关闭客户端和服务端的连接。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建HTTP与HTTPS服务器及客户端]]></title>
    <url>%2F2019%2F02%2F11%2F%E5%88%9B%E5%BB%BAHTTP%E4%B8%8EHTTPS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8A%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[创建HTTP与HTTPS服务器及客户端HTTP服务器创建HTTP服务器123var server = http.createServer([requestListener]);requestListener ==&gt; function(request, response)&#123;...&#125; 回调函数中有两个参数，第一个参数代表客户端请求，第二个参数代表一个服务器响应对象。若不在createServer方法中使用参数，也可以通过监听服务器对象的request事件server.on(&#39;request&#39;, function(request,response){...})。 在创建了http服务器之后，需要指定服务器监听的地址server.listen(port, [host], [bocklog], [callback])可使用listen回调函数指定listening事件的回调函数，也可以使用server对象监听listening事件 关闭http服务器server.close()，当服务器关闭时，触发close事件server.on(&#39;close&#39;,function(){...}) 若http服务器监听的端口或地址已被占用，将产生错误代码为”EADDRINUSE”的错误，同时将触发HTTP服务器的error事件 客户端和服务端建立连接时，触发connect事件server.on(&#39;connection&#39;,function(socket){...})。在浏览器访问HTTP服务器时，浏览器会发出两次客户端请求，一次是用户发出的请求，另一次是浏览器为页面在收藏加中的显示图标（favicon.ico）自动发出的。 设置超时server.setTimeout(msecs, callback)超时触发timeout事件。 获取客户端请求信息HTTP服务器接收到客户端请求时调用回调函数中的第一个参数值为http.IncomingMessage对象，该对象用于读取客户端请求流中的数据。当读取代新数据触发data事件，读取完毕触发end事件。 req下的data事件和end事件。 转换URL字符串与查询字符串在node.js中，提供了一个url模块和一个Query String模块，分别用来转换完整URL字符串和URL中的查询字符串。 在一个完整的URL字符串中，从？字符之后到#号字符之前或者到URL字符串结束的这一部分为查询字符串 可以使用Query String模块中的parse方法将查询字符串转化为一个对象，querystring.parse(str,[sep],[eq],[options])sep用于指定查询字符串的分割字符，默认为“&amp;”；eq用于指定查询字符串中的分配字符，默认为“=”；options为一个对象，对象中设置maxKeys来指定转换后的对象属性个数。 querystring.stringify(obj,[sep],[eq])将对象转换为一个查询字符串，sep指定查询字符串中的分隔符，默认为&amp;；eq指定查询字符串中使用的分配字符，默认为=。 URL模块专门用于对完整的URL字符串进行转换。 parse方法将一个URL字符串转化为一个对象。url.parse(urlStr, [parseQueryString]) format方法将URL字符串经过转换后的对象还原成一个URL字符串。url.format(urlobj) resolve方法将两个路径结合成为一个路径 url.resolve(from, to) 如果from为网络路径，to为非网络路径的绝对路径，则返回网络根目录+参考路径 其他情况下，to为绝对路径，则返回参考路径 如果from为一个不以“/”字符结尾的根目录且to为相对路径，则返回根目录+/+参考路径去除开头./或../ 如果from为一个以“/”字符结尾的根目录且to为相对路径，则返回根目录+/+参考路径去除开头./或../ url.resolve(&#39;http://www.example.com/a/b/c&#39;, &#39;one&#39;)返回http://www.example.com/a/b/one url.resolve(&#39;http://www.example.com/a/b/c/&#39;, &#39;one&#39;)返回http://www.example.com/one url.resolve(&#39;http://www.example.com/a/b/c&#39;, &#39;./one&#39;)返回http://www.example.com/a/b/one url.resolve(&#39;http://www.example.com/a/b/c/&#39;, &#39;./one&#39;)返回http://www.example.com/a/b/c/one url.resolve(&#39;http://www.example.com/a/b/c&#39;, &#39;../one&#39;)返回http://www.example.com/a/one url.resolve(&#39;http://www.example.com/a/b/c&#39;, &#39;../one&#39;)返回http://www.example.com/a/one 发送服务器端相应流在createServer方法的参数值回调函数或服务器对象的request事件函数中的第二个参数值为一个http.ServerResponse对象，可以利用该对象发送服务器端响应流。 response.writeHead(statusCode,[reasonPhrase],[headers])statusCode指定一个HTTP状态码，例如404。reasonPhrase指定对于状态码的描述信息。第三个参数为一个对象，指定服务器端创建的响应头对象。在响应头中包含的常用字段如下： content-type: 指定内容类型 location: 将客户端重定向到另一个URL地址 content-disposition: 指定一个被下载的文件名 content-length: 指定服务器端响应内容的字节数 set-cookie: 在客户端创建一个cookie content-encoding: 指定服务器端响应内容的编码方式 Cache-Control: 开启缓存机制 Expires: 用于指定缓存过期时间 Etag: 用于指定当前服务器响应的内容没有变化时不重新下载数据 若服务器端口为1337，并从80端口的网站运行HTML5页面，这是一种跨域操作。需要在HTTP响应头中添加Access-Control-Allow-Origin字段，并且将参数值指定为允许向服务器请求数据的端口+端口号（省略端口号时允许该域名下的任何端口向服务器请求数据） 12res.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;,&apos;Access-Control-Allow-Origin&apos;: &apos;http://localhost&apos;&#125;) response.setHeader(name, value)单个设置头信息 response.getHeader(name)获取响应字段 response.removeHeader(name)删除响应字段，必须在ServerResponse对象的write方法之前被调用 在调用writeHead方法时即发送响应头。在使用setHeader时，调用write方法即发送响应头。两种方法发送响应头的时间不一样。 默认情况下，HTTP服务器自动将服务器端的当前时间作为响应头的Date字段发给客户端，可以设置sendDate为false删除Date字段。statusCode获取HTTP服务器返回的状态码。 res.addTrailers(headers)在响应数据的尾部追加一个头信息，headers为一个对象 res.write(chunk, [encoding])发送响应内容。 HTTP客户端var req = http.request(options, callback)向其他网站发送请求数据。 req.on(&#39;resposne&#39;,function(res){})当客户端请求获取到响应流之后，触发response事件 req.write(chunk,[encoding]) 向目标网站发送数据 req.end([chunk],[callback])结束本次请求 在建立连接的过程中，当为该连接分配端口时，触发http.ClientRequest对象的socket事件req.on(&#39;socket&#39;,funcition(socket){...})]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack--概念]]></title>
    <url>%2F2018%2F11%2F22%2FWebpack%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Webpack概念 入口(entry) 输出(output) loader 插件(plugins) 入口(entry)入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 输出(output)output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段。 loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 插件(plugins)plugins插件可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。 想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack--入口起点]]></title>
    <url>%2F2018%2F11%2F22%2F%20webpack--%E5%85%A5%E5%8F%A3%E8%B5%B7%E7%82%B9%2F</url>
    <content type="text"><![CDATA[入口起点(entry points)单个入口（简写）语法12345const config = &#123; entry: &apos;./path/to/my/entry/file.js&apos;&#125;;module.exports = config; 对象语法123456const config = &#123; entry: &#123; app: &apos;./src/app.js&apos;, vendors: &apos;./src/vendors.js&apos; &#125;&#125;; 常见应用分离 应用程序(app) 和 第三方库(vendor) 入口多页面应用程序]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6--变量的解构赋值]]></title>
    <url>%2F2018%2F04%2F24%2FES6--%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[变量的解构赋值数组的解构赋值基本用法ES6允许按照一定模式从数组和对象中提取值，然后对变量进行赋值，这被称为解构。例如： 12345let a=1;let b=2;let c=3;//上面等价于let [a,b,c]=[1,2,3]; 默认值解构赋值允许有默认值。 1234let [foo=true]=[];foo //truelet [x,y='b']=['a'] //x='a', y='b' 如果默认值是一个表达式，那么这个表达式是惰性求值的。默认值可以引用解构赋值的其他变量，但改变量必须已经声明。 对象的解构赋值解构不仅可以用于数组，还可以用于对象 123let &#123;foo, bar&#125;=&#123;foo: 'aaa',bar: 'bbb'&#125;;foo //aaabar //bbb 对象的解构和数组有一个重要的不同。对象的属性没有次序，变量必须与属性同名才能取得正确的值。如果变量名和属性名不一致，必须写成下面这样 12var &#123;foo:baz&#125;=&#123;foo:'aaa',bar:'bbb'&#125;;baz //aaa 对象的解构赋值的内部机制是先找到同名属性，然后再赋值给相应的变量。真正被赋值的是后者，而不是前者。对象的解构也可以指定默认值。默认值生效的条件是：对象属性值严格等于undefined。 对象的解构赋值可以很方便的将现有对象的方法赋值到某个变量例如let {log,sin,cos}=Math;另外数组本质是特殊的对象，可以有如下操作 1234let arr=[1,2,3];let &#123;0:first,[arr.length-1]:last&#125;=arr;first //1last //3 字符串的解构赋值字符串也可以解构赋值。这是因为此时的字符串被转化成了一个类似数组的对象。 1const [a,b,c,d,e]='hello'; 类似数组的对象都有一个length属性，因此可以对这个属性进行解构赋值 12let &#123;length:len&#125;='hello';len //5 数值和布尔值的解构赋值解构属性时，如果等号右边是数值和布尔值，则会先转化为对象。 函数参数的解构赋值12345function add([x,y])&#123; return x+y;&#125;add([x,y]); //3 上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成x和y。对于函数内部的代码来说，他们能感受到的就是x和y。函数参数的解构也可以使用默认值。 圆括号问题解构赋值虽然很方便，但是解析起来不是很容易。 不能使用圆括号的情况 变量声明语句。let [x: (c)]=[1]; //报错 函数参数。 function f(z, (x)){return x;} 赋值语句模式。 ({p: a})={p: 42}) 将整个模式放在圆括号之中 可以使用圆括号的情况赋值语句的非模式部分可以使用圆括号。 用途交换变量的值1234let x=1;let y=2;[x,y]=[y,x]; 从函数返回多个值函数只能返回一个值，如果返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213function example()&#123; return [1,2,3];&#125;let [a,b,c]=example()//返回一个对象function example()&#123; return &#123; foo: 1, bar: 2 &#125;&#125;let &#123;foo,bar&#125;=example(); 函数参数的定义解构赋值可以方便地将一组参数与变量名对应起来 提取JSON数据对于提取JSON对象中的数据尤其有用 123456789let jsonData=&#123; id: 42, status: "OK", data: [867, 5309]&#125;let &#123;id, status, data:number&#125;=jsonData;id //42status //"OK"number //"[867, 5309]" 函数参数的默认值遍历Map结构任何部署了Iterator接口的对象都可以用for…of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值获取键名和键值就非常方便。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基础--计算属性]]></title>
    <url>%2F2018%2F04%2F23%2FVue--%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[计算属性 模版内的表达式常用于简单的运算，当其过长或逻辑复杂时，会难以维护。计算属性则是解决该问题的。 什么是计算属性上一章已经学到，我们可以通过&#123;&#123; &#125;&#125;双向绑定一些数据或者表达式，但是如果数据或者表达式过长，就会变得臃肿甚至难以阅读和维护。比如 123&lt;div&gt; &#123;&#123; text.split(',').reverse().join(',') &#125;&#125;&lt;/div&gt; 这里的表达式包含3个操作，并不是很清晰，所以我们遇到复杂的逻辑时，应该用计算属性。上面可以改写为如下： 12345678910111213141516&lt;div id="app"&gt; &#123;&#123;reversedText&#125;&#125;&lt;/div&gt;&lt;script&gt; var app=new Vue(&#123; el: '#app', data: &#123; text: '123,456', &#125;, computed: &#123; reversedText: function()&#123; return this.text.split(',').reverse().join(','); &#125;, &#125; &#125;);&lt;/script 所有的计算属性都以函数的形式写在Vue实例内的computed选项内，最终返回计算后的结果。 计算属性用法在一个计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结果就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;hello&lt;/title&gt; &lt;script src="vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;总价：&#123;&#123; prices &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var app=new Vue(&#123; el: '#app', data: &#123; package1: [ &#123; name: 'iphone 7', price: 7199, count: 2, &#125;, &#123; name: 'ipad', price: 2888, count: 3, &#125; ], package2: [ &#123; name: 'apple', price: 3, count: 5, &#125;, &#123; name: 'banana', price: 2, count: 10, &#125; ], &#125;, computed: &#123; prices: function()&#123; var prices=0; for(let i=0;i&lt;this.package1.length;i++)&#123; prices += this.package1[i].price*this.package1[i].count; &#125; for(let i=0;i&lt;this.package2.length;i++)&#123; prices += this.package2[i].price*this.package2[i].count; &#125; return prices; &#125;, &#125;, &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当package1或package2中的商品有任何变化，比如购买数量变化或增删商品时，计算属性prices就会自动更新，视图中的总价也会变化。每一个计算属性都包含一个getter和一个setter，上面使用的都是getter。setter的作用是，当手动修改计算属性的值就像修改一个普通数据那样，就会触发setter函数。计算属性的两个小技巧： 可以依赖其他计算属性 计算属性不仅可以依赖当前Vue实例的数据，还可以依赖其他实例数据 计算属性缓存计算属性是基于它的缓存的。一个计算属性所依赖的数据发生变化时，他才会重新取值。只要数据不改变，计算属性也就不更新。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基础--v-bind及class与style绑定]]></title>
    <url>%2F2018%2F04%2F23%2FVue.js--v-bind%E5%8F%8Aclass%E4%B8%8Estyle%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[v-bind及class与style绑定 DOM元素经常会动态地绑定一些class类名或style样式。 了解v-bind指令]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6--let和const]]></title>
    <url>%2F2018%2F04%2F21%2FES6--let%E5%92%8Cconst%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[let和const命令1.let命令1.1 基本用法let用于申明变量，其用法类似于var。但是所有申明的变量只在let命令所在的代码块内有效。for循环有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环内部是一个单独的子作用域。 1234567for(let i=0;i&lt;3;i++)&#123; let i=0; console.log(i);&#125;//abc//abc//abc 1.2 不存在变量提升使用var声明变量会有变量提升的情况，即变量可以在声明之前使用，值为undefined。为了纠正这种情况，let命令改变了语法行为，他所声明的变量一定要在声明之后使用，否则会报错。 12345console.log(foo); //undefinedvar foo=2;console.log(foo1); //报错let foo1=2; 1.3 暂时性死区只要块级作用域内存在let命令，他所声明的变量就“binding”绑定这个区域，不再受外部的影响。 12345var tmp=123;if(true)&#123; tmp='abc'; let tmp;&#125; 上面存在全局作用域tmp，但是块级作用域内又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明之前，调用tmp会报错。总之，暂时性死区的本质就是只要进入当前作用域，所要使用的变量就已经存在，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 1.4 不允许重复声明let不允许在相同的作用域中重复声明同一个变量 1234567891011//报错function()&#123; let a=10; var a=1;&#125;//报错function()&#123; let a=10; let a=1;j&#125; 2.块级作用域2.1 为什么使用块级作用域ES5只有全局作用域和函数作用域，没有块级作用域，这导致很多场景不合理。 内层变量可能会覆盖外层变量 12345678910var tmp=new Date();function f()&#123; console.log(tmp); if(false)&#123; var tmp="hello world"; &#125;&#125;f(); //undefined 用来计数的循环变量泄漏为全局变量 2.2 ES6的块级作用域let实际上为JavaScript新增了块级作用域 12345678function f1()&#123; let n=5; if(true)&#123; let n=10; &#125; console.log(n);&#125;f1(); // 5 外层代码不受内层代码的影响，如果使用var定义变量n，最后输出的值就是10.ES6允许块级作用域的任意嵌套，并且外层作用域无法读取内层作用域的变量。内层作用域可以定义和外层作用域的同名变量块级作用的出现，实际上使得立即执行匿名函数不再必要 2.3 块级作用域和函数声明ES5规定，函数只能在顶层作用域和函数作用域中声明，不能在块级作用域中声明。但是浏览器并没有遵守这个规定。ES6引入块级作用域，明确允许在块级作用域之中声明函数。在块级作用域之中声明函数类似于let，在块级作用域之外不可引用。 2.4 do表达式本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。现在有一个提案使得块级作用域可以变为表达式，即可以返回值，操作如下： 1234let x=do&#123; let t=f(); t*t+1;&#125;; 3.const命令3.1 基本用法const声明一个只读常量。一旦声明，常量的值不能改变。const一旦声明常量，就必须立即初始化，不能留到以后赋值。其余特性和let一样。 3.2 本质const实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据而言，值就保存在变量指向的内存地址中,因此等同于常量。但对于复合类型的数据，变量指向的内存地址只是一个指针，const只能保证这个指针是固定的，至于他指向的数据结构是不是可变的，这完全不能控制。如果想将对象冻结，应该使用Object.freeze方法。const foo=Object.freeze({}); 3.3 ES6声明变量的6种方法ES5: 使用var命令和function命令。ES6: 添加了let和const命令，还有import和class命令。 4.顶层对象属性顶层对象在浏览器中是指window对象，在Node环境中指的是global对象。在ES5中，顶层对象属性和与全局变量是等价的。ES6规定，var命令和function命令声明的全局变量依旧是顶层对象属性；其次，let命令、const命令、class命令声明的全局变量不属于顶层对象属性。 5.global对象ES5的顶层对象本身也是一个问题，因为他在各种实现中是不统一的。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基础]]></title>
    <url>%2F2018%2F04%2F19%2FVue_No1%2F</url>
    <content type="text"><![CDATA[What’s Vue.js综述：简单小巧的核心，渐进式技术栈。可以一步一步，有阶段的使用vue.js。他提供了现代web开发中常见的高级功能。 解耦视图与数据 可复用组件 前端路由 状态管理 虚拟DOM 1.1 MVVM模式Vue.js在设计上使用MVVM。当View发生变化时，会自动更新到ViewModel(视图模型)。View和ViewModel之间通过双向绑定建立联系。Vue.js通过MVVM的模式拆分为视图和数据两个部分，并将其分离。只需要操作数据。 How do we use it?2.1 实例与数据绑定Vue.js创建： 1234var app=new Vue(&#123; //选项 el: document.getElementById('app'); //或者是'#app'&#125;); 不可缺少的选项：el。el用于指定一个页面中已经存在的DOM元素。该元素用来挂载Vue实例，他可以是HTMLElement或者CSS选择器。 data选项，可以声明应用内需要双向绑定的数据。 2.1.1 生命周期每个Vue实例创建时，都会经历一系列初始化过程，同时也会调用相应的生命周期钩子，利用相应的生命周期钩子，在合适的时机执行我们的业务逻辑。 created：实例创建完成后调用，此阶段完成了数据的观测，但尚未挂载。$el还不能用。 mounted: el挂载到实例上调用。 beforeDestroy：实例销毁之前调用。 2.1.2 插值与表达式插值表达方式：“&#123;&#123; &#125;&#125;”。作用：他会自动将我们双向绑定的数据显示出来。 如果想输出HTML，而不是纯文本，可以用v-html。 如果想显示&#123;&#123; &#125;&#125;，使用v-pre即可跳过这个元素和它的籽元素编译的过程。 在&#123;&#123; &#125;&#125;中，除了简单的绑定属性值外，还可以使用Javascript表达式进行运算。但是，他只支持单个表达式，不支持语句和流控制。 2.1.3 过滤器在&#123;&#123; &#125;&#125;插值的尾部添加一个管道符(|)对数据进行过滤，经常用于格式化文本。过滤规则是自定义的，通过给Vue实例添加filters来设置 2.2 指令与事件指令是Vue.js模版中最常用的一项功能，他带有前缀v-。指令的主要职能就是当其表达式的值改变时，相应地将某些行为应用到DOM上。数据驱动DOM是Vue.js的核心理念，不到万不得已不要主动操作DOM。 v-bind:基本用途是动态更新HTML元素上的属性，比如id、class等。 v-on:用来绑定事件监听器，]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM扩展]]></title>
    <url>%2F2018%2F03%2F19%2FDOM%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[DOM扩展 之前都是学习的DOM，最近准备学习下DOM扩展和DOM2、DOM3 DOM扩展目的：为了实现更多的功能。DOM主要扩展的两方面：Selectors API和HTML5。 1.选择符API最常用的的就是根据CSS选择符选择与某个模式匹配的DOM元素。jQuery的核心就是通过CSS选择符查询DOM文档取得元素引用。Selectors API的核心是两个方法：querySelector()和querySelectorAll()。 1.1 querySelector()方法querySelector()接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回null。 123456//取得body元素var body=document.querySelector("body");//取得ID为myDiv的元素var myDiv=document.querySelector("#myDiv");//取得类为selected的第一个元素var selected=document.querySelector(".selected"); 通过Document类型调用querySelector()方法时，会在文档元素范围内查找匹配的元素。而通过Element类型调用quertSelector()方法时，只会在该元素后代元素的范围内查找匹配的元素。 1.2 querySelectorAll()接收的参数和querySelector()一样，都是一个css选择符，但返回的是所有匹配元素而不仅仅是一个元素。这个方法返回一个NodeList的实例。 1.3 matchesSelector()方法这个方法接收一个参数，即css选择符，如果调用元素与该选择符匹配，返回true；否则，返回false。 2.元素遍历对于元素间的空格，IE9及之前的版本不会返回文本节点，而其他所有浏览器都会返回文本节点。为了保持一致。定义以下新属性。 childElementCount：返回子元素的个数（不包含文本节点和注释） firstElementChild: 返回第一个元素；firstChild元素版。 lastElementChild: 指向最后一个元素；lastChild元素版。 previousElementSibling: 指向前一个同辈元素。previousSibling的元素版。 nextElementSibling：指向后一个同辈元素。nextSibling的元素版。 遍历某元素的子元素 1234567var i, len, child=element.firstElementChild;while( child != element.lastElementChild )&#123; processChild(child); child=child.nextElementSibling;&#125; 3.HTML5HTML5规范围绕如何使用新增标记定义了大量的JavaScript API 3.1 与类相关的扩充 getElementsByClassName()方法接收一个参数，即一个包含一个或多个类名的字符串。返回带有指定类的所有元素的NodeList。 12//取得所有类中包含“username”和“current”的元素，类名的先后顺序无所谓var allCurrentUsernames=document.getElementsByClassName("username current"); 调用这个方法时，只有位于调用子树中的元素才会返回。在document对象上调用getElementsByClassName()始终会返回与类名匹配的所有元素，在元素上调用该方法就只会返回后代元素中匹配的元素。 classList属性classList属性有一个表示自己包含多少元素的length属性，而取得每个元素可以使用item()或者方括号语法。此外这个属性还定义了如下方法。 add(value): 将给定的字符串值添加到列表中。如果存在，则不添加了。 contains(value): 表示列表中是否存在给定的值。如果存在则返回true，否则则返回false。 remove(value): 从列表中删除给定的字符串。 toggle(value): 如果存在给定值，则删除它，如果不存在给定值，则添加它。 123456789div.classList.remove("disabled");div.classList.add("current");div.classList.toggle("ueser");if(div.classList.contains("bd"))&#123; ...&#125;for(var i=0;i&lt;classList.length;i++)&#123; doSomething(div.classList[i]);&#125; 3.2 焦点管理HTML5也添加了辅助管理DOM焦点的功能。首先就是document.activeElement属性，作用：始终引用DOM中当前获得了焦点的元素。元素获得焦点的方式有页面加载、用户输入、在代码中调用focus()方法。 123var button=document.getElementById('myButton');button.focus();alert(document.activeElement==button); //true;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络之数据网络层学习笔记]]></title>
    <url>%2F2018%2F03%2F15%2F%E7%BD%91%E7%BB%9C%E5%B1%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[网络层学习笔记1.网络层提供的两种服务英特网的设计思路：网络层向上只提供简单灵活的、无连接的、尽量大努力交付数据报服务。网络层不提供服务质量的承诺。好处：网络造价大大降低，运行方式灵活，能够适应各种应用。 2.网际协议IP是最重要的因特网标准协议之一，与之配套的使用的还有三个协议。 地址解析协议ARP 网际控制报文协议ICMP 网际组管理协议IGMP RARP逆地址解析协议（弃用） 2.1 虚拟互联网路不能让大家都使用相同的网络，因为用户的需求是多样的。没有一种单一的网络能够适应所有的需求。将网络互相连接起来要使用一些中间设备。 物理层使用的中间设备转发器 数据链路层使用的中间设备网桥和桥接器 网络层使用的中间设备路由器 在网络层以上使用的中间设备叫做网关。用网关连接两个不兼容的系统需要在高层进行协议的转换。 现在我们讨论网络互联时，都是指用路由器进行网络互联和路由选择。TCP/IP体系在网络互联上采用的做法是在网络层采用了标准化协议，但相互连接的网络则可以是异构的。由于参与互联的计算机网络都使用相同的网际协议IP，因此可以把互联以后的计算机网络看成一个虚拟互连网络。虚拟互联网络：即逻辑互联网络，互连起来的各种物理网络的异构性客观存在，利用IP协议就可以使这些性能各异的网路在网络层上看起来好像是一个统一的网络。总之，互联网可以由多种异构网络组成。 2.2 分类的IP地址有关IP的文档就是RFC 791. IP地址及其表示方法 IP地址就是给因特网上的每一个主机的每一个接口分配一个全世界范围内唯一的32位标识符。IP地址的编码经过了三个历史阶段 分类的IP地址 子网的划分 构成超网 分类的IP地址就是将IP地址划分为若干固定类，每一类地址都由两个固定的长度的字端组成，其中第一个字段是网络号，它标志主机所连接到的网络。第二个字段是主机号，它标记该主机。一个IP地址在整个因特网范围内。A、B、C类地址都是单播地址（一对一通信），是最常用的。 A、B、C类地址的网络号分别为1，2，3字节。而在网络号前面有1～3位类别号。分别是0，10，110。 IP地址不仅标示了一个主机，还指明了主机算连接到的网络。 IP地址都是32位，用点分计数法，每八位为一个单位。 常用的三种类别的IP地址 A类：A类地址的网络号占一个字节，可指派的网络号为2^7-2个，126个。为什么减2？因为IP中全0是个保留地址，意思是“本网络”。第二，网络号为127保留作为本地软件环回测试。A类主机号三个字节有2^24-2个。减去全0的主机号，因为它表示所连接到的单个网络地址。全1表示该网络上的所有主机。A类地址占整个空间的50%。 B类：B类地址的网络号占两个字节，前面两位固定（10），B类网络地址128.0.0.0是不指派的，可指派的最小的网络地址是128.1.0.0。所以，网络数为2^16-1。B类地址主机数2^16-2. 25% C类：三个字节的网络的字段三个字节。最前面三位（110），192.0.0.0是不指派的，所以网络号有2^21-1个。C类地址最大的主机号2^8-2. 12.5% IP地址特点： 分等级的地址结构。管理机构只分配网络号。路由器仅根据目的主机所连接的网络号来分组，减少了路由表所占存储空间以及查找路由表时间。 IP地址标志一个主机和一条链路的接口。当一个主机同时接入两个网络时，它就必须拥有两个不同的IP地址，这种主机叫多归属主机。所以路由器至少都有两个IP地址。每一个接口都有一个不同的网络号的IP地址。 用转发器或网桥连接起来的若干局域网仍为一个网络。不同网络号必须用路由器进行连接。 所有网络号的网络都是平等的。 2.3 IP地址与硬件地址 区别：物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址。IP地址放在IP数据报的首部，而硬件地址则放在MAC帧的首部，在网络层和网络层以上使用的是IP地址，而数据链路层及以下使用的是硬件地址。在数据链路层看不见数据报的地址。 需要强调的是： 在IP层抽象的互联网只能看见IP数据包。 虽然在IP数据包首部有源站IP地址，但路由器只根据目的站的IP地址的网络号进行路由选择。 在局域网的链路层，只能看见MAC帧。 IP层抽象的互联网屏蔽了下层这些很复杂的细节。 2.4 地址解析协议ARP ARP协议含义：已经知道了一个机器的IP地址，需要找出其相应的硬件地址。即从网络层的IP解析出在数据链路层使用的MAC地址。还又个叫RARP逆解析协议。 地址解析协议ARP解决IP到MAC的映射是在主机ARP高速缓存中存放一个IP地址到硬件地址的映射表，并且这个映射表还经常动态更新。 每一个主机里面都设有一个ARP高速缓存，里面有本局域网上的各主机和路由器的IP地址到硬件地址的映射表。 写入映射表的过程： ARP进程在本局域网上广播发送一个ARP请求分组 在本局域网上的所有主机上运行的ARP进程都收到此ARP请求 若主机B的IP地址与ARP请求分组中要查询的IP地址一致，就收下这个ARP请求，并向主机A发送ARP响应分组。 主机A收到主机B的ARP响应分组之后，就在其中ARP高速缓存中写入主机B的IP地址到硬件地址的映射。 ARP把保存在高速缓存中的每一个映射项目都设置生存生存时间，超过了这个时间的项目就从高速缓存中删除。 ARP解决的是同一个局域网上的主机或路由器的IP地址到硬件地址的 映射问题。 IP地址到硬件地址的解析是自动进行的。主机的用户对这种地址解析过程是不知道的。 使用ARP的四种典型情况： 主机到同网络主机 主机到异网络主机 路由器到同网络主机 路由器到异网络主机 为什么不直接使用硬件地址来通信？ 原因：由于世界上存在着各种各样的网络，他们使用不同的硬件地址，要使这些异构的网络互相通信就必须进行非常复杂的硬件地址转换工作。 2.5 IP数据报的格式一个IP数据包有首部和数据两个部分组成，首部的前一部分是固定长度，共20字节。是所有IP数据报都必须拥有的。后一部分是一些可选字段，其长度是可变的。 IP数据报首部固定部分中的各字段 版本：占4位，指IP协议版本。通信双方使用的IP协议版本必须一致。 首部长度：占4位，可表示最大十进制数为15。 区分服务：占8位，用来获得更好的服务。这个字段在旧标准中叫做服务类型。 总长度：首部和数据之和的长度，单位为字节。IP层下面的每一种数据链路协议都规定了一个数据帧中的数据字段的最大长度，这称为最大传送单元MTU。IP数据报越短，路由器转发的速度越快。为此，IP协议规定，因特网中所有的主机和路由器，必须能够接收长度不超过576字节的数据报。超过这个长度时，就要进行分片。 标示：占3位，目前只有两位有意义。标志字段中的最低位记位MF，MF=1则表示后面还有分片。MF=0则表示这已是若干数据的报片中的最后一个 片偏移：占13位，某片在原分组中的相对位置。片偏移以8个字节为偏移单位。 生存时间TTL：占8位，表明是数据报在网络中的寿命。其目的是防止无法交付的数据报无限制地在因特网中兜圈子。 协议：占8位，协议字段指出此数据报携带的数据是使用何种协议。 首部检验和：只检验数据报的首部，但不包括数据部分。 IP数据报的可变部分 就是一个选项字段，选项字段用来支持排错、测量以及安全措施，内容很丰富。最后用全0字节的填充字段补齐成为4个字节的整数倍。增加可变部分就是为了增加IP数据报的功能。 2.6 IP层转发分组的流程在互联网上转发分组时，是从一个路由器转发到下一个路由器。(目的网络地址，下一跳地址)。有如下结果： IP数据报最终一定可以找到目的主机所在目的网络上的路由器(也许要通过多次的间接交付) 只有达到最后一个路由器时，才试图向目的主机直接交付。 因特网的分组转发都是基于目的主机所在的网络。但也允许特定主机路由：即对特定的目的主机指明一个路由。采用特定主机路由可使网络管理人员能更方便的控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种方式路由器还可以采用默认路由以减少路由表所占的空间和搜索路由表所用的时间。这种转发方式在一个网络只有很少的对外连接是很有用的。 分组转发算法如下： 从数据报的首部提取目的主机的IP地址D，得出目的网络的地址为N。 若N就是与此路由器直接相连的某个网络地址，则进行直接交付。 若路由表中有目的地址为D的特定主机路由，则把数据报传给路由表中所指明的下一跳路由器。 若路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器。 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器。 报告转发分组出错。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[严格模式学习笔记]]></title>
    <url>%2F2018%2F03%2F10%2F%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[严格模式通过严格模式，可以在函数内部选择进行较为严格的全局和局部的错误条件检测。好处：可以提早知道代码中存在的错误，及时捕获一些导致编程错误的ECMAScript行为 1.选择使用要选择进入严格模式，可以使用严格模式的编译指示，实际上就是一个不会符给任何变量的字符串：“use strict”。这种语法可以向后兼容那些不支持严格模式的JavaScript引擎。 如果是在全局作用域中给出这个编译指示，则整个脚本都处于严格模式。也可以只在函数中打开严格模式。如下 1234function doSomething()&#123; "use strict" ...&#125; 2.变量在严格模式下，什么时候创建变量以及怎么创建变量都是有限制的。首先，不允许意外创建全局变量 像这样 message=&quot;hello world&quot;在严格模式下，如果给一个没有声明的变量赋值，那代码会抛出错误 其次，不能对变量调用delete操作符。非严格模式下允许这种操作，但会返回false。严格模式下抛出错误 3.对象在严格模式下操作对象比非严格模式下操作对象更容易导致错误。在开发中使用非严格模式会加大发现错误的可能性。在下列情形下操作对象的属性会导致错误。 为只读属性赋值 为不可配置的属性使用delete操作符 为不可扩展的对象添加属性 在使用对象自变量时，属性名必须唯一。 4.函数首先，严格模式要求命名函数的参数必须唯一。其次，在非严格模式下，修改命名参数的值也会反映到arguments中，而严格模式下这两个值则是保持独立 1234567function showValue(value)&#123; value="foo"; alert(value); //"foo" alert(arguments[0]); //严格模式"Hi" 非严格模式“Foo”&#125;showValue("Hi"); 另外，淘汰了arguments.callee和arguments.caller。在非严格模式下，一个引用函数本身，一个引用调用函数。最后，就是只能在脚本的顶级和函数的内部声明函数。也就是说，在if语句中声明函数会导致语法错误。 eval()eval()函数在严格模式下也得到了提升。最大的变化就是它在包含上下文中不再创建变量或者函数。 1234function doSomething()&#123; eval("var x=10"); alert(x); //非严格模式下10 严格模式下抛出错误。&#125; eval和arguments在严格模式下，禁止使用eval和arguments作为标示符。 抑制this在非严格模式下使用函数apply（）和call（）方法时，null和undefined值会被转换成全局对象。而在严格模式下，函数this的值始终是指定的值，无论指定什么值。 12345var color='red';function displayColor()&#123; alert(this.color);&#125;displayColor.call(null); //非严格模式this的值为全局对象，弹出red，严格模式下，这个this的值时null，抛出错误 其他 抛弃with语句 抛弃八进制自变量，以0开头的八进制自变量 修改parseInt()的行为。如今，八进制自变量在严格模式下会被当作0开头的十进制自变量。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络之数据链路层学习笔记]]></title>
    <url>%2F2018%2F03%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[计算机网络之数据链路层学习笔记1、使用广播信道的数据链路层广播信道可以进行一对多信道，局域网使用的就是广播信道。 1.1局域网的数据链路层 局域网特点：网络为一个单位所有，且地理范围和站点数目均有限。 局域网优点： 具有广播功能，从一个站点可以方便的访问全网。 便于系统的扩展和逐渐的演变。 提高了系统的可靠性、可用性和生存性。 局域按网络拓扑分类： 星型网 环型网 总线网 共享信道要着重考虑的一个问题就是如何使众多用户能够合理而方便的共享信通媒体资源，有两种方法： 静态划分信道 动态媒体接入控制，又称多点接入。特点：信道并非在用户通信时固定分配给用户。分为：随机接入和受控接入 为了使数据链路层更好的适应多种局域网标准，把数据链路层拆成两个字层：逻辑链路控制LLC字层和媒体接入控制子层 适配器：即网络接口卡，简称网卡。作用：负责计算机与外界局域网的连接。适配器上有处理器和存储器。适配器和局域网之间通过电缆和双绞线以串行传输方式进行。适配器与计算机通过计算机主板I/O主线以并行传输进行。适配器包含了数据链路层和物理层两层次的功能 1.2 CSDA/CD协议 载波监听多点接入/碰撞检测 总线特点：当一个站点发送数据时，总线上所有计算机都能检测到这个数据。实现一对一通信的方式：在帧首部写上接收站点位置。 为了方便通信，以太网采取了以下两种方式 无连接的工作方式。即不必建立连接就可以直接发送数据。适配器对发送的帧不进行编号，也不要求对方发回确认。以太网提供的服务是尽最大努力的交付，即不可靠交付。在同一时刻只能允许一台计算机发送数据。 以太网发送的数据都使用曼彻斯特码 CSMA/CD协议的要点 “多点接入”：说明这是总线型网络。 “载波监听”：用电子技术检测总线上有没有其他计算机也在发送。载波监听就是检测信道。不管在发送前还是在发送中，每个站都必须不停地检测信道。 “碰撞检测”：就是边发送边监听。即适配器边发送数据边检测信道上的信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。一旦发现总线上出现了碰撞，其适配器就要立即停止发送，免得进行无效发送。 电磁波在1Km电缆传播时延约5us。在使用CSMA/CD协议时，一个站不可能同时进行发送和接收。所以只能进行半双工通信。每一个站在自己发送数据后一小段时间内，存在遭遇碰撞的可能性，这一小段时间是不确定的，称为发送的不确定性。以太网端到端往返时间2t称为争用期（碰撞窗口），经过争用期还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 CSMA/CD协议过程： 准备发送：适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器缓存中。发送之前，必须检测信道。 检测信道：若检测到信道忙，则不停的检测，一直等待信道变为空闲。若检测到信道空闲，并在96比特内保持信道空闲（帧间最小间隔9.6us，相当于96比特时间），就发送这个帧。 在发送过程中仍不停的检测信道，即网络适配器要边发送边监听。两种可能性：一是发送成功，二是发送失败 2、使用广播信道的以太网2.1 使用集线器的星型拓扑 传统以太网最初使用粗同轴电缆，后来演变到比较便宜的细同轴电缆，最后发展为使用更便宜更灵活的双绞线。这种以太网采用星型结构，在中心有一个可靠性非常高的设备，叫集线器（hub） 10BASE-T双绞线以太网是星型结构，是局域网历史上一个非常重要的里程碑。 集线器的特点： 使用集线器的以太网逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA/CD协议。在同一个时刻只允许一个站发送数据。10BASE-T以太网又称为星型总线或盒中总线。 一个集线器有许多接口。因此一个集线器像一个多接口的转发器 集线器工作在物理层，它的每个接口仅仅简单的转发比特，不进行碰撞检测。 采用专门的芯片。 2.2 以太网信道利用率以太网总的信道利用率并不能达到100%。当数据率一定时，以太网的连接长度收到了限制，同时以太网的帧长不能太短。 2.3 以太网的MAC层 MAC层的硬件地址在局域网中，硬件地址又称为物理地址或MAC地址。在所有计算机系统中，标示系统都是一个核心问题。在标示系统中，地址就是为识别某个系统的一个非常重要的标示符。严格来说，名字应该与系统所在地无关，但IEEE802 规定了一种48位全球地址，是指局域网上的每一台计算机中固化在适配器的ROM中的地址。局域网上的某个主机的地址根本不可能告诉我们这台主机位于什么地方，因此，严格来说，局域网的‘地址’应当是每一个站的‘名字’或标识符。现在局域网适配器使用的都是6字节的MAC地址。MAC的前三个子节为公司标识符，后三个子节则有厂家自行指派，成为扩展标识符。一个地址块可生成2^24个不同的地址。MAC地址就是适配器地址或者适配器标识符。适配器有过滤功能，但适配器从网络上收到每一个MAC帧就先用硬件检测MAC帧中的目的地址，如果是发往本站的帧则收下，然后再进行其他的处理。否则将此帧丢弃。发往‘本站的帧’包括以下三种帧：单播帧、广播帧、多播帧，所有适配器都至少识别单播和多播地址，只有目的地址使用广播地址和多播地址。 MAC帧格式有两种标准，一种是以太网标准，另一种是IEEE的802.3标准。第一种最常用。以太网v2标准由5个字段组成，前两个字段分别为6字节长的目的地址和源地址字段第三个字段是2字节的类型字段，用来表示上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层这个协议。第四个字段为数据字段，长度为46到1500字节之间。最后一个字段是4字节的帧检测序列FCS。当数据字段小于64字节时，MAC字层就会在数据字段的后面加上一个整数字段的填充字段，以保证以太网的MAC帧长不小于64字节。因此上层协议必须具有识别有效的数据字段的功能在传输媒体（物理层）上实际传输的要比MAC帧还多8字节。目的是为了接收端迅速实现同步。这8个字节的组成：第一个字段是7个字节的前同步码，作用是使接收端的适配器在接收MAC帧时能迅速调整时钟频率，使他和发送端时钟同步，第二个字段是帧开始定界符，定义为10101011。MAC帧的FCS字段的检验范围不包括前同步码和帧开始界定符。以太网不需要帧结束界定符，也不需要字节来保证透明传输。 扩展以太网这种扩展的以太网在网络层看来仍然是一个网络。 在物理层扩展以太网 现在，扩展以太网和集线器之间的距离一种简单的方法就是使用光纤和一对光线解调器。缺点：碰撞域扩大；如果使用不同以太网技术，那么就不可能用集线器将它们互联起来。 在数据链路层扩展以太网 在数据链路层扩展以太网要使用网桥，网桥工作在数据链路层，它根据MAC帧的目的地址对收到的帧进行转发和过滤。 网桥内部结构 两个以太网通过网桥来连接时，就成为一个覆盖更大的以太网，而原来的每个以太网就可以称为一个网段。网桥依靠转发表来转发帧，转发表也叫做转发数据库和路由目录。转发表的好处： 1.过滤通信量，增大吞吐量 2.扩大了物理范围 3.提高可靠性 4.可互联不同物理层，不同MAC字层和不同速率 缺点： 1.增加了延时 2.没有流量控制功能 3.用户数太多和通信量太大会导致广播风暴 透明网桥 目前使用最多的网桥，透明是指以太网上的站点都看不见以太网上的网桥，透明网桥还是一种即插即用设备 当网桥刚刚连接到以太网时，其转发表是空的。网桥收到一个帧就会按照自学习的算法处理收到的帧。网桥每收到一个帧，就记下其源地址和进入网桥的接口。转发表中，没有源地址这一栏，只有地址这一栏。建立转发表时是把帧首部的源地址写在地址栏里，在转发帧时，是根据收到的这首部中的目的地址来转发的，这时地址栏下面把记录的源地址当作目的地址 网桥的子学习和转发帧：网桥收到一段帧后先进行自学习，查找转发表中有与收到帧的源地址有无相匹配的项目。转发帧，查找转发表中与收到的目的地址有无向匹配的项目。如没有，则通过所有其他接口进行转发。如有，则按转发表中给出的接口进行转发。若转发表中给出的接口就是该帧进入的接口，则丢弃该帧。 源路由网桥 源路由网桥是在发送帧时，把详细的路由信息放在帧首部中。 多接口路由–以太网交换机 交换式集线器又称为交换机或第二层交换机，表明这种交换机工作在数据链路层。交换机实质上就是一个多接口的网桥。使每一对相互通信的主机都能像独占传输设备那样，无碰撞的传输数据。以太网交换机对收到的帧采用存储转发和直通的方式 以太网可以实现虚拟以太网VLAN。VLAN：由一些局域网网段构成与物理位置无关的工作组，而这些网段具有某种共同的需求。VLAN其实是给用户提供一种服务，而不是一种新型局域网。虚拟局域网上的每个站都可以收到同一个局域网上的其他成员所发出的广播，即使他们没有连接在同一个以太网交换机上。它可以限制接收广播的工作站数，抑制广播风暴。虚拟局域网允许在以太网的帧格式中插入一个4字节的表示符，称为VLAN标记，用来指明发送该帧的工作站属于哪一个虚拟局域网。插入在MAC帧的源地址和字段和类型字段之间。 3.高速以太网 100BASE-T以太网 在全双工方式下工作而无冲突发生，此方式下CSMA/CD不起作用。 吉比特以太网 有全双工和半双工两种方式工作。 10吉比特和100吉比特 只工作在全双工方式。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象程序设计之继承]]></title>
    <url>%2F2018%2F03%2F10%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承学习笔记许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。 1、原型链 基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。过程：A.prototype=B的实例。然后这就意味着A.prototype的内部有一个内部属性[[prototype]]，这个指针指向B的原型B.prototype。如下 12345678910111213141516171819function A()&#123; this.aProperty=true;&#125;A.prototype.getAValue=function()&#123; return this.property;&#125;function B()&#123; this.bProperty=false;&#125;B.prototype=new A();B.prototype.getBValue=function()&#123; return this.bProperty;&#125;var instance=new B();alert(instance.getAValue()); //true 实现的本质是重写原型对象，用另外一个对象的实例赋值给这个原型对象。调用getAValue()会经历三个步骤：1、搜索实例。2、搜索B.prototype. 3、搜索A.prototype 1.1 默认的原型所有引用类型默认继承了Object，这个继承也是通过原型链来实现的。所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。所以上述就是，A继承了B，B继承了Object。调用instance.toString()，实际上是调用Object.prototype上的方法。 1.2 确认原型和实例的关系 调用instanceof操作符，只要用这个操作符测试实例与原型链中出现过的构造函数，结果就返回true。 123alert(instance instanceof Object); //truealert(instance instanceof A); //truealert(instance instanceof B); //true 使用isPrototypeof()方法。只要在原型链中出现过的原型，都可以说是该原型链派生的实例的原型，因此isPrototypeOf()方法也会返回true。 123alert(Object.prototype.isPrototypeOf(instance));alert(A.prototype.isPrototypeOf(instance));alert(B.prototype.isPrototypeOf(instance)); 1,3 谨慎的定义方法自类型有时候需要覆盖超类型中的某个方法，或者需要添加超类型中不存在的某个方法。给原型添加方法的代码一定要放在替换原型的语句之后。 1234567891011121314151617181920212223function A()&#123; this.aProperty=true;&#125;A.prototype.getAValue=function()&#123; return this.property;&#125;function B()&#123; this.bProperty=false;&#125;B.prototype=new A(); //替换原型的语句B.prototype.getBValue=function()&#123; //添加新方法 return this.bProperty;&#125;B.prototype.getAValue=function()&#123; //重写超类型中的方法 return false;&#125;var instance=new B();alert(instance.getAValue()); //true 使用原型链实现继承时，不能使用对象自变量创建原型方法。 1.4 原型链的问题最主要的问题来自包含引用类型值的原型。 1234567891011121314function SuperType()&#123; this.colors=['red','blue','green'];&#125;function SubType()&#123;&#125;Subtype.prototype=new SuperType();var instance1=new Subtype();instance1.colors.push('black');alert(instance1.colors); //'red','blue','green','black'var instacne2=new Subtype();alert(instance2.colors); //'red','blue','green','black' 2、借用构造函数为了解决原型中包含引用类型的值所带来的问题，可以使用一种叫做借用构造函数的技术。思路：在子类型构造函数的内部调用超类型构造函数。函数只不过是在特定环境中执行代码的对象，因此使用apply()和call()方法也可以在新创建的对象上执行构造函数。如下 1234567891011121314function SuperType()&#123; this.colors=["red","blue","green"];&#125;function SubType()&#123; SuperType.call(this); //借调了超类型构造函数&#125;var instance1=new SubType();instance.colors.push("black");alert(instance1.colors); //"red","blue","green","black"var instance2=new SubType();alert(instance2.colors); //"red","blue","green" 2.1 传递参数相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。 12345678910function SuperType(name)&#123; this.name=name&#125;function Subtype()&#123; SuperType.call(this,'Tom'); this.age=29&#125;var instance=new Subtype();alert(instance.name); //Tomalert(instance.age); //29 问题：不能避免构造函数模式的问题，方法都在构造函数中定义，因此函数复用就无从谈起。 3、组合继承将原型链和借用构造函数组合在一块。思路：使用原型链实现对原型属性和方法的基础，通过构造函数实现对实例属性的继承 1234567891011121314151617181920function SuperType(name)&#123; this.name=name; this.colors=["red","blue","green"];&#125;Supertype.prototype.sayName=function()&#123; alert(this.name);&#125;;function SubType(name,age)&#123; //继承属性 SuperType.call(this,name); this.age=age;&#125;//继承方法SubType.prototype=new SuperType();SubType.prototype.constructor=SubType;SubType.prototype.sayAge=function()&#123; alert(this.age);&#125;; 4、原型式继承借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。 12345function object(o)&#123; function F()&#123;&#125; F.prototype=o; return new F();&#125; 在这个object()函数内部，先创建了一个临时性的构造函数，然后传入的对象作为这个构造函数的原型。最后返回这个临时类型的一个新实例。从本质上说，object()对传入的对象执行了一次浅拷贝。 123456789101112var person=&#123; name: "Tom", friends: ["Tom","Court","Van"]&#125;;var anotherPerson=object(person);anotherPerson.name="Grey";anotherPerson.friends.push("Rob");var yetAnotherPerson=object(person);yetAnotherPerson.name='Linda';yetAnotherPerson.friends.push('Jay'); 这种方式必须要有一个对象作为另一个对象的基础。ECMAScript通过Object.create(新对象原型的对象，一个为新对象定义额外属性的对象)方法规范了原型式继承 1234567var person=&#123; name: "Tom", friends: ["Tom","Court","Van"]&#125;;var person1=Object.create(peron);... 5、寄生式继承与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回对象 1234567function createAnother(o)&#123; var clone=object(o); clone.sayHi=function()&#123; alert('Hi'); &#125;; return clone;&#125; 作用：在主要考虑对象而不是自定义类型的构造函数的情况下，寄生式构造函数也是一种有用的模式。 6、寄生组合式继承组合继承最大的问题就是：无论在何种情况下，都会调用两次构造函数：一次是在创建子类型原型的时候，另一次是在子类构造函数内部。 原理：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。思路：不必为了指定子类型的原型而调用超类型的构造函数，我们所需的无非就是超类型的一个副本而已。 如下 12345function inheritPrototype(subType,superType)&#123; var prototype=object(subType.prototype); //创建对象 prototype.constructor=subType; //增强对象 subType.prototype=prototype; //指定对象&#125;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象程序设计之对象]]></title>
    <url>%2F2018%2F03%2F05%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[面向对象程序设计学习笔记1.理解对象创建自定义对象最简单的方式就是创建一个Object的实例，再给他加上方法和属性 123456var person = new Object();person.name="Tom";person.age=29;person.sayName=function()&#123; alert(this.name);&#125;; 还有一种就是创建对象自变量。 1234567var person=&#123; name: "Tom", age: 29, sayName: function()&#123; alert(this.name); &#125;&#125;; 1.1属性类型只有内部才用的特性时（attribute），描述了属性（property）的各种特征。在JavaScript中不能直接访问它们。为了表示特性是内部值，用[[attribute]]表示ECMAScipt有两种属性：数据属性和访问器属性。 数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性 [[Configurable]]: 表示能否通过delete删除属性重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。默认为true。 [[Enumerable]]: 表示能否通过for-in循环返回属性。默认true [[Writable]]: 能否修改属性的值。默认true [[Value]]: 包含这个属性的数据值。读取属性值时，从这个位置读；写入属性值时，把新值保存到这个位置。默认undefined。 要修改属性的默认特性，就必须使用Object.defineProperty()方法。接收三个参数：属性所在对象、属性名字、一个描述符对象。其中，描述符对象的属性必须是：Configurable,Enumerable,Writable,Value. 12345678var person=&#123;&#125;;Object.defineProperty(person,'name',&#123; Writable: false, Value: 'Tom',&#125;);alert(person.name); //"Tom"person.name='gray';alert(person.name); //"Tom" 把configurable设置为false，表示不能从对象中删除属性。如果调用delete，在非严格模式下什么也不会发生，在严格模式下跑出错误。而且一旦把属性定义为不可配置时，就不能再把他变为可配置属性了。在调用defineProperty()方法修改除Writable之外的特性，都会发生错误。 12345678910111213var person=&#123;&#125;;Object.defineProperty(person,'name',&#123; Configurable: false, Value: 'Tom',&#125;);alert(person.name); //Tomdelete person.name;alert(person.name); //TomObject.defineProperty(person,'name',&#123; Configurable: true, //抛出错误 Value: 'Tom'&#125;); 用Object.defineProperty()方法创建一个新属性时，如果不指定，Configurable，Writable，Enumerable默认为false。 访问器属性 [[Configurable]]: 同上 [[Enumerable]]: 同上 [[Set]]:在写入属性时调用的函数。默认undefined。 [[Get]]:在读取属性时调用的函数。默认undefined。 访问器属性不包含数据值，他们包含一对getter和setter函数。在读取访问器属性时，调用getter()。设置访问器属性时，调用setter()并传入新值。访问器属性不能直接定义，必须使用Object.defineProperty()来定义。 123456789101112131415161718var book=&#123; _year: 2004, edition: 1, &#125;; Object.defineProperty(book,&quot;year&quot;,&#123; get: function()&#123; alert(this._year); &#125;, set: function(newValue)&#123; if(newValue&gt;2004)&#123; this._year += newValue; this.edition += newValue-2004; &#125; &#125;, &#125;);book.year=2008;alert(book.edition); 只定义getter意味着属性是不能写，尝试写入属性会被忽略。类似的，只定义setter函数的属性也不能读。 1.2定义多个属性利用Object.defineProperties()方法。 12345678910111213141516171819202122var book=&#123;&#125;;Object.defineProperties(book,&#123; _year:&#123; writable:true, value:2004, &#125;, edition:&#123; writable:true, value:1, &#125; year:&#123; get:function()&#123; return this._year; &#125;, set:function(newValue)&#123; if(newValue&gt;2004)&#123; this._year += newValue; this.edition += newValue-2004; &#125; &#125; &#125;&#125;); 1.3读取属性特性利用Object.getOwnPropertyDescriptor()。接收两个参数：属性所在的对象和读取其描述符的属性名称。返回的是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get、set；如果是数据属性，这个对象的属性有configurable、enumerable、writable、value。 1var descripter=Object.getOwnPropertyDescriptor(book,"_year"); 2.创建对象虽然Object构造函数和对象自变量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量重复的代码。 2.1 工厂模式用函数来封装以特定接口创建对象的细节，如下 12345678910function createPerson(name,age,job)&#123; var o=new Object(); o.name=name; o.age=age; o.job=job; o.sayName=function()&#123; alert(this.name); &#125;; return o;&#125; 工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题，即怎样知道一个对象的类型。 2.2构造函数模式可以用构造函数创建自定义构造函数，从而定义自定义对象类型的属性和方法。构造函数始终都应该以一个大写字母开头。构造函数也是函数，只不过可以用来创建对象而已。如下 1234567891011function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=function()&#123; alert(this.name); &#125;;&#125;var person1=new Person('zhang',21,"teacher");var person2=new Person('he',20,'Doctor'); 与工厂模式的不同： 没有显式的创建对象 直接将方法和属性赋值给了this对象 没有return 创建Person的新实例，必须使用new操作符。以这种方式调用构造函数会经历四个步骤： 创建一个新对象 将构造函数的作用域赋值给新对象（因此this就指向这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 person1和person2分别保存着Person的一个不同的实例。这两个对象都有一个constructor属性，该属性指向Personperson.constructor==Person //true也可以用instanceof操作符可以得到验证person1 instanceof Person //true。创建自定义构造函数意味着将来可以将它的实例标示为一种特定的类型，优于工厂模式。 1，构造函数问题构造函数与其他函数的区别，就是调用方式不同。任何函数使用new 操作符调用，那他就可以作为构造函数，而不通过new调用则就是普通函数。 123456789101112//作为构造函数var person=new Person('Tom',29,'teacher');person.name //Tom//作为普通函数使用Person('Tom',29,teacher);window.name //Tom//在另一个对象中调用var o=new Object();Person.call(o,'Tom',29,teacher);o.name //'Tom' 2.构造函数问题构造函数的问题就是：每个方法都要在每个实例上再创建一遍。不同实例上的同名函数是不一样的。可以把函数定义转移到构造函数外部进行定义。 2.3原型模式我们创建的每个函数都有一个prototype属性。这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的方法和属性。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。 1234567891011function Person()&#123;&#125;Person.prototype.name='Tom';Person.prototype.age=29;Person.prototype.job='teacher';Person.prototype.sayName=function()&#123; return this.name;&#125;;var person1=new Person();var person2=new Person();alert(person1==person2); //true 1.理解原型对象无论什么时候，一个新函数有一个prototype属性，该属性指向函数的原型对象，原型对象又包含一个constructor属性，这个属性是一个指针，指向新函数。Person.prototype.constructor指向Person。当调用构造函数创建一个新实例的时候，该实例内部有一个属性(内部属性)，叫[[prototype]]。在Safari、Firefox、Chrome对象上都支持一个属性proto。 proto这个连接存在于实例和原型对象之间，不存在于实例与构造函数之间。可以通过isPrototypeOf()方法来确定对象之间是否存在这种联系。 注：可以通过对象实例访问原型中的值，但不能通过对象实例修改原型中的值。当为实例添加一个属性时，就会屏蔽原型对象上的同名属性，可以通过delete删除实例上的属性，从而恢复对原型对象上的属性的访问。 用hasOwnProperty(属性名)方法可以判断一个属性是否存在于实例中，还是存在于原型中。当属性存在于实例中返回true。 2.原型与in操作符单独使用in时，会在通过对象能够访问给定属性时返回true，无论属性在对象实例中还是原型中。alert(&#39;name&#39; in person1)。 可以根据hasOwnProperty()和in一起确定属性是否存在于原型链中。如下 123function isPrototypeProperty(obj,name)&#123; return !obj.hasOwnProperty(name)&amp;&amp;(name in obj);&#125; for-in可以返回存在于实例中的属性和存在于原型中的属性，即使原型中不可枚举的属性（即将把[[Enumerable]]设置为false的属性）也会在for-in循环中返回。 Object.keys(对象)，返回一个包含所有可枚举属性字符串的数组。作用：取得对象上所有可枚举的实例属性。是实例上的属性，不包括原型链上的。要取得所有的属性可以使用Object.getOwnPropertyNames() 3.更简洁的语法12345678910function Person()&#123;&#125;Person.prototype=&#123; name:'Tom', age:29, job:teacher, sayName:function()&#123; alert(this.name); &#125;&#125;; 这种语法中，将对象自变量直接赋给原型对象。使用这种方法出现了一个问题，即Person.prototype.constructor不在指向Person，而指向了Object。因为我们完全重写了prototype对象，因此constructor也变成了新的constructor，不再指向Person函数。为了解决这个问题，可以有以下两种修改方法 1234567891011function Person()&#123;&#125;Person.prototype=&#123; constructor: Person, name:'Tom', age:29, job:teacher, sayName:function()&#123; alert(this.name); &#125;&#125;; 以上面这种方式设置constructor会导致其变为可枚举的，默认情况下，它是不可枚举的所以也可以通过下述方法改进。 1234Object.defineProperty(Person.prototype,'constructor',&#123; Enumerable: false, value: Person&#125;); 4.原型的动态性由于原型查找值的过程是一次搜索，因此我们对原型的任何修改都可以体现在实例上，即使我们在创建实例后修改原型也可以立刻体现到实例中。 5.原型对象的问题最大的问题是由共享的本性所导致的。对于引用类型值的属性来说，问题就比较突出了。 12345678910111213141516171819function Person()&#123;&#125;Person.prototype=&#123; constructor: Person, name:'Tom', age:29, job:teacher, friends:["Jane","Jay"], sayName:function()&#123; alert(this.name); &#125;&#125;;var person1=new Person();var person2=new Person();person1.friends.push('Van');alert(person1.friends); //"Jane","Jay","Van"alert(person2.friends); //"Jane","Jay","Van" 修改了一个可以从另外一个实例中反映出来。 2.4组合使用构造函数模式和原型模式创建自定义类型最常见的方式。构造函数模式用于定义实例属性，而原型模式用于定义共享属性。结果就是，每个实例都会有自己的一份实例属性的副本。但同时又共享着对方法的引用，最大限度的节省内存。此外还支持构造函数传递参数 123456789101112131415161718function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.friends=["Tom","Jay"];&#125;Person.prototype=&#123; constructor: Person, sayName: function()&#123; alert(this.name); &#125;&#125;var person1=new Person("Jucy",29,"Engineer");var person2=new Person("Greg",27,"Doctor");person1.friends.push("Kobe"); alert(person1.friends) //"Tom","Jay","Kobe"alert(person2.friends) //"Tom","Jay" 2.5 动态原型模式它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型，又保持了同时使用构造函数和原型的优点。也就是，可以通过检查某个应该存放的位置是否有效，来决定是否需要初始化原型。 12345678910function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; if(typeof sayName != 'function')&#123; person.prototype.sayName=function()&#123; alert(this.name); &#125;; &#125;&#125; 2.6 寄生构造函数模式基本思想：创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。 1234567891011function Person(name,age,job)&#123; var o=new Object(); o.name=name; o.age=age; o.job=job; o.sayName=function()&#123; alert(this.name); &#125;; return o&#125;var person=new Person('Tom',29,'teacher'); 除了使用new操作符并把使用的包装函数叫做构造函数以外，这个模式和工厂模式是一模一样的。 2.7 稳妥构造函数稳妥对象：没有公共属性，而且其方法也不引用this对象。最适合一些安全的环境中。与寄生构造函数的不同：1、不使用this。 2、不使用new操作符调用构造函数。 12345678910111213function Person(name,age,job)&#123; var o=new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName=function()&#123; alert(name); &#125;; //返回对象 return o;&#125;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax和Comet学习笔记]]></title>
    <url>%2F2018%2F03%2F01%2FAjax%E5%92%8CComet%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Ajax和Comet的学习笔记 按着js高级程序设计的步骤进行笔记记录～～ ajax：Asynchronous JavaScript+XMLajax的核心技术：XMLHttpRequest对象。 1.XMLHttpRequest对象建立：var xhr=new XMLHttpRequest(); (不考虑兼容IE7之前的版本)。 1.1 XHR用法 要调用的第一个方法就是open(),接受3个参数：1、要发送请求的类型（“post”，“get”等）、请求的URL、是否异步发送请求的bool值 xhr.open(&quot;get&quot;,&quot;example.php&quot;,false) 说明：1.url相对于执行代码的当前页面2.调用open方法并不会发送请求，而是启动一个请求已备发送。 要发送特定的请求，必须像这样调用send(),xhr.send(null).send()方法接受一个参数，即要作为请求主体发送的数据。如果不需要请求主体发送数据，则必须传入null。这次请求是同步的，js代码会等到服务器响应之后再继续执行。在收到响应后，响应的数据会自动填充XHR对象的属性,相关属性如下： responseText: 作为响应主体被返回的文本。 responseXML: 如果响应的内容类型是“text/xml”或者“application/xml”，这个属性将保存着包含响应数据的XML DOM文档。 status：响应的HTTP状态。 statusText：HTTP状态的说明 过程：第一步：检查status的状态，以确定响应已经成功返回。一般来说，HTTP的状态码为200时，可以作为成功的标志。这时候，responseText属性的内容已经就绪，在内容正确的情况下responseXML也能访问了。状态码为304时表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本。这时候的响应也是有效的。可以像下面这样肩检查两种状态码。 12345if( (xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300)||xhr.status==304 )&#123; alert(xhr.responseText);&#125;else&#123; alert("request is unsucessful" +xhr.status);&#125; 通过检测status来决定下一步操作。另外，无论内容类型是什么，响应主体都会保存到responseText中；而对于非XML数据来说，responseXML属性将设置为null。 上述是发送同步请求，多数情况下，我们还是要发送异步请求，才能让JavaScript继续执行而不必响应等待。通过检测XHR对象的readyState属性，该属性表示请求/响应过程的当前活动阶段。这个属性可取： 0:未初始化。尚未调用open()方法。 1:启动，已经调用open()方法，但未调用send()方法。 2:发送，已经调用send()方法，但未接收到响应。 3:接收，已经接收到部分响应数据。 4:完成，已经接收到全部数据，而且可以在客户端使用了 只要readyState属性的值由一个值变为另一个值，都会触发一次readystatechange事件。可以利用这个事件来检测每次状态变化后readyState值。一般只对readyState的值为4的阶段感兴趣，因为这时的所有元素都已经就绪。不过，必须在调用open()之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性。 12345678var xhr=new XMLHttpRequest();xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; //code.... &#125;&#125;;xhr.open("get","example.php",true);xhr.send(null); 1.2 HTTP头部信息每个HTTP请求和响应都会带有相应的头部信息。XHR对象也提供了操作这两种头部（请求头部和响应头部）信息的方法。 请求头部：默认情况下，在发送XHR请求的同时，还会发送下列头部信息： Accept：浏览器能够处理的内容类型。 Accept-Charset：浏览器能够显示的字符集。 Accept-Encoding：浏览器能够处理的压缩编码。 Accept-Language：浏览器当前设置的语言。 Connection: 浏览器与服务器之间连接的类型。 Cookie：当前页面设置的任何cookie。 Host：发出请求的页面所在的域。 Refer：发出请求的页面的url。 User-Agent：浏览器的用户代理字符串。 使用setRequestHeader()方法可以设置自定义的请求头部信息。接收两个参数：1、头部字段的名称。 2、头部字段的值。 必须在调用open方法之后，send方法之前调用setRequestHeader()。 123456789var xhr = new XMLHttpRequest();xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; //.... &#125;&#125;;xhr.open("get","example.php",true);xhr.setRequestHeader("MyHeader","MyValue");xhr.send(null); 响应头部： 调用XHR对象的getResponseHeader()方法并传入头部字段名称，可以取得相应的响应头部信息。 调用XHR对象的getAllResponseHeaders()方法则可以取得一个包含所有头部信息的长字符串。 12var myHeader=xhr.getResponseHeader('MyHeader');var allHeaders=xhr.getAllResponseHeader(); getAllResponseHeaders()方法通常会返回如下所示的多行文本内容： 123456Date: ..Server: ..Vary: ..X-Power-By: ..Connection: ..Content-type: .. 1.3 GET请求GET是最常见的请求类型，最常用于向服务器查询某些信息。可以将查询字符串参数追加到URL的末尾，以便将信息发送给服务器。对XHR而言，位于传入open()方法的URL末尾的查询字符串必须经过正确的编码才行。使用get请求经常会发生一个错误，就是查询字符串格式有问题。查询字符串的每个参数的名称和值都必须使用encodeURIComponent()进行编码。 先解释下encodeURIComponent(URIstring)的作用以及用法。 1. 作用：函数可把字符串作为 URI 组件进行编码。&lt;br&gt; 2. 说明：该方法不会对ASCII字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * &apos; ( ) 。 其他字符（比如 ：;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。 下面这个函数可以辅助向现有URL的末尾添加查询字符串参数： 12345function addURLParam(url,name,value)&#123; url+= (url.indexOf("?")==-1 ? "?" : "&amp;"); url+= encodeURIComponent(name)+"="+encodeURIComponent(value); return url;&#125; 1.4 POST请求post通常用于向服务器发送应该被保存的数据。post请求应该把数据作为请求的主体来提交，而get请求传统上不是这样。post请求的主体可以包含非常多的数据，而且格式不限。用法: 第一步： xhr.open(&quot;post&quot;,&quot;example.php&quot;,true) 第二步： 向send()方法传入某些数据。 默认情况下，服务器对POST请求和提交Web表单请求并不会一视同仁。因此服务器端必须有程序来读取发送过来的原始数据，并从里面解析出有用的部分。可以利用XHR来模仿表单提交：首先将Content-Type头部信息设置为application/x-www-form-urlencoded，也就是表单提交时的内容类型。其次是以适当的格式创建一个字符串。 2.XMLHttpRequest2级2.1 FormData现代Web应用中频繁使用的一项功能就是表单数据的序列化，XMLHttpRequest2定义了FormData类型。作用：为序列化表单以及创建与表单格式相同的数据提供了便利。 12var data=new FormData();data.append('name','Nicholas'); 两个参数分别对应表单字段的名字和字段包含的值。向FormData构造函数传入表单元素，也可以用表单元素的数据预先向其中填入键值对：var data=new FormData(document.forms[0]);。创建FormData可以直接把它传入send()中。xhr.send(new FormData(form)). 2.2 超时设定XHR对象添加了一个timeout属性，表示请求在等待响应多少毫秒之后就终止。给timeout设置一个数值后，如果在规定的时间内浏览器还没有接收到响应，那么就会触发timeout事件，进而会调用ontimeout事件处理程序。 2.3 overridMimeType() 方法用于重写XHR响应的MIME类型 3.进度事件定义了与客户端服务器通信有关的事件。有以下6个进度事件。 loadstart：在接收到响应数据的第一个字节时触发。 progress：在接收响应期间持续不断地出发。 error：在请求发生错误时触发。 abort：调用abort()方法而终止连接时触发。 load：在接收完整的响应的触发。 可以替代readystatechange事件。 loadend：在通信完成或者在触发error、abort、load事件后触发。 过程：先触发loadstart,然后是一个或多个progress事件，然后是error、abort、load其中一个被触发，最后触发loadend事件。 4.跨域源资源通过XHR实现Ajax通信的一个主要限制就是跨域安全策略。在默认情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。CORS定义了在必须访问跨域资源时，浏览器和服务器应该如何沟通。CORS背后的基本思想，就是使用自定义的http头部让浏览器与服务器进行通信，从而决定请求或响应是否成功或失败。Origin:http://www.nczonline.net IE对CORS的实现 IE8引入XDR（XDomainRequest）类型。这个对象与XHR类似，但能实现安全可靠的跨域通信。XDR和XHR不同之处： cookie不会随请求发送，也不会随响应返回 不能访问响应头部信息 只支持GET和POST请求 只能设置请求头部信息中的Content-type 其他浏览器对CORS的实现都通过XMLHttpRequest对象实现了对CORS的原生支持。在尝试打开不同来源的资源，无需额外编写代码就可以触发这个行为。方法：使用标准的XHR对象并在open()方法中传入URL即可。例如 123456789101112var xhr=new XMLHttpRequest();xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; if((xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300) || xhr.status==304)&#123; alert(xhr.responseText); &#125;else&#123; alert("Request was unsucessful"+xhr.status); &#125; &#125;&#125;;xhr.open("get","http://www.somewhere-else.com/page/",true);xhr.send(null); 与IE的XDR对象不同，通过跨域XHR对象可以访问status和statusText属性，而且支持同步请求。跨域对象也有一些限制，如下： 不能使用setRequestHeader()设置自定义头部。 不能接受和发送cookie 调用getAllResponseHeader()方法总会返回空字符串。 Preflighted ReqeustsCORS通过一个叫做Preflighted Requests的透明服务器验证机制支持开发人员使用自定义的头部、GET或POST之外的方法，以及不同类型的主体内容。在使用高级选项来发送请求时，就会向服务器发送一个Preflight请求。这种请求使用OPTIONS方法，发送下列头部 跨浏览器的CORS所有浏览器都支持简单的请求，因此有必要实现一个跨浏览器的方案。检测XHR是否支持CORS的最简单的方式，就是检查withCredentials属性。再结合检测XDomainRequest对象是否存在，就可以检测所有浏览器了。 12345678910111213141516171819function createCORSRequest(method,url)&#123; var xhr=new XMLHttpRequest(); if("withCredentials" in xhr)&#123; xhr.open(method,url,true) &#125;else if(typeof XDomainRequest != "undefined")&#123; xhr = new XDomainRequest(); xhr.open(method,url); &#125;else&#123; xhr = null; &#125; return xhr;&#125;var request=createCORSRequest("get","http://www.somewhere-else.com/page/");if(request)&#123; request.onload=function()&#123; //对request.responseText进行处理 &#125; request.send();&#125; 5.其他跨域技术图像Ping使用标签，一个网页可以从任何网页中加载图像，不用担心跨不跨域。可以动态的创建图像，使用它们的onload和onerror事件处理程序来确定是否接收到了响应。图像Ping：是与服务器进行简单、单项的跨域通信的一种方式。通过图像Ping，浏览器得不到任何具体数据的数据，但通过监听load和error事件，它能知道响应是什么时候接收的。 12345var img=new Image();img.onload=img.onerror=function()&#123; alert("Done!");&#125;;img.src="http://www.example.com/test?name=Tom"; 图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。 JSONPJSONP：JSON with padding(填充式JSON或参数式JSON)，是应用JSON的一种新方式，JSONP和JSON差不多，只不过是包含在函数调用的JSON，callback({&quot;name&quot;:&quot;Tom&quot;});JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面调用的函数。回调函数的名字一般在请求中指定。而数据就是传入回调函数的JSON数据。典型的JSONP请求http://freegeoip.net/json/?callback=handleResponse。JSONP是通过动态创建script元素来使用的 123456function handleResponse(response)&#123; alert("Your Ip is"+response.ip+", which is in"+response.city);&#125;var script=document.createElement('script');script.src="http://freegeoip.net/json/?callback=handleResponse";document.body.insertBefore(script,document.body.firstChild); 优点：1.双向通信。2、可以访问响应文本。3、简单易用缺点：1.从其他域加载执行代码，不安全。2、确定请求是否失败并不容易。 Comet更高级的Ajax技术（也叫服务器推送）。Ajax是一种页面向服务器请求数据的技术，而Comet则是一种服务器向页面推送数据的技术。能够使信息实时地被推送到页面上。实现Comet有两种方式：长轮询和流。 短轮询：即浏览器定时向服务器发送请求，看有没有数据更新长轮询：页面发起一个到服务器的请求，然后服务器一直保持连续打开，直到有数据可以传送。发送完数据后，浏览器关闭连接，随即又发起一个到服务器的新请求。 HTTP流。他在页面的整体生命周期内只使用一个HTTP连接。就是浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性的向浏览器发送数据。可以通过监听readystatechange事件以及readyState的值是否为3，就可以利用XHR对象实现HTTP流。随着不断从服务器接收数据，readyState周期性的变为3，当readyState变为3时，responseText属性中就会保存接收到的所有数据。此时，需要比较此前接收到的数据，决定从什么位置开始取得最新的数据。实现如下 123456789101112131415161718function createStreamingClient(url,progress,finished)&#123; var xhr=new XMLHttpRequest(), receive=0; xhr.onreadystatechange=function()&#123; var result; if(xhr.readyState==3)&#123; result=xhr.reponseText.substring(received); received+=result.length; progress(result); &#125;else if(xhr.readyState==4)&#123; finished(xhr.responseText); &#125; &#125;; xhr.open("get",url,true); xhr.send(null); return xhr;&#125; Web SocketsWeb Sockets目标：在一个单独的持久连接上提供全双工、双向通信。过程：在JavaScript创建了Web Sockets之后，会有一个HTTP请求发送到浏览器以发起连接。在取得服务器响应之后，建立的连接会使用HTTP升级从HTTP协议交换为Web Socket协议。URL的模式也略有不同。未加密的连接是ws://，加密的连接是wss://。不是http://和https://好处：能够在客户端和服务器之间发送非常少的数据，而不必担心HTTP那样子节级的开销。非常适合移动应用。 1.Web Sockets API要创建web sockets，先实例一个WebSocket对象并传入要连接的URL：var socket=new WebSocket(&quot;ws://www.example.com/server.php&quot;)。必须给WebSocket构造函数传入绝对的URL。可以通过它打开到任何站点的连接。 实例化WebSocket对象后，浏览器就会马上尝试创建连接。与XHR相似，WebSocket也有一个表示当前状态的readyState属性。这个属性的值和XHR并不相同 WebSocket.OPENING(0): 正在建立连接 WebSocket.OPEN(1): 已经建立连接 WebSocket.CLOSING(2): 正在关闭连接 WebSocket.CLOSE(3): 已经关闭连接 WebSocket没有readystatechange事件；不过他有其他事件，对应不同状态，readyState的值永远都从0开始。要关闭Web Socket连接，可以在任何调用close方法().socket.close() 2.发送和接收数据使用send()方法并传入任意字符串，例如： 12var socket=new WebSocket("ws://www.example.com/server.php");socket.send("hello world"); WebSockets只能通过连接发送纯文本数据，所以对于复杂的数据结构，在发送之前，必须进行序列化。 当服务器向客户端发来消息时，WebSocket对象会触发message事件。这个message事件与其他传递消息的协议类似，也就是把返回的数据保存在event.data中。 12345socket.onmessage=function(event)&#123; var data = event.data; //处理数据&#125; 3.其他事件 open:在成功建立时触发 error：发生错误时触发 close：关闭连接时触发]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量、作用域和内存问题学习笔记]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[变量、作用域和内存问题学习笔记 之前学习过一遍，考完研发现记得不是很清楚😂，重新看了一遍js高程，在这里记录下自己的学习心得和薄弱环节～～ 1.基本和引用类型的值基本类型：简单的数据段，五种基本类型：Undefined,Null,Boolean,String,Number引用类型：是保存在内存中的对象 1.动态属性对于引用类型，我们可以为其添加属性和方法。对于基本类型变量，不能添加属性，虽然不会报错。 2.复制变量值基本类型：会在变量对象创建一个新值，然后把该值复制到为新变量分配的位置上。两个变量不会互相影响。 引用类型：同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。复制操作结束后，两个变量实际上引用同一个对象。改变其中一个变量，会影响另一个变量。 3.传递参数所有函数都是按值传递的。基本类型值的传递如同基本类型变量的复制一样。而引用类型值的传递，则如同引用类型变量的复制一样。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数外部。 1234567891011121314151617//基本类型function add(num)&#123; num+=10; return num;&#125;var count=20;var result=addTen(count);alert(count); //20,没有变化alert(result); //30//引用类型function setName(obj)&#123; obj.name="Tom";&#125;var person=new Object();setName(person);alert(person.name) //Tom 4.检测类型 1、typeof：检测一个变量是不是基本数据类型。检测基本类型时使用他，检测引用类型时用处不大。 注意：typeof null等于object 2、instanceof：在检测一个引用类型和Object构造函数时，instanceof操作符始终返回true。instanceof检测基本类型的值时，该操作符始终返回false。 2.执行环境及作用域执行环境时JavaScript最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之被销毁。每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将环境弹出，把控制权返回给之前的执行环境。当代码在一个环境中执行，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域的前端，始终都是当前执行的代码所在环境的变量对象。下一个变量来自外部环境，一直延续下去；全局执行环境的变量对象始终都是作用域链中的最后一个对象。标识符解析：是沿着作用域链一级一级搜索标示符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止。 1234567891011121314var color="blue";function changeColor()&#123; var anotherColor="red"; function swapColors()&#123; var tempColor=anotherColor; anotherColor=color; color=tempColor; //这里可以访问color、anotherColor、tempColor &#125; //这里可以访问color、anotherColor，不能访问tempColor。 swapColors();&#125;//这里只能访问color 延长作用域链：有些语句可以在作用域的前端临时加一个变量对象，该变量对象会在代码执行后被移除。以下两个语句会使作用域链得到加长。1、try-catch语句的catch块2、with语句 指定对象添加到作用域链中 3.垃圾收集js具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。原理：找出那些不再使用的变量，然后释放其占用的内存。垃圾收集器必须跟踪哪个变量有用，哪个变量没用，对于没用的变量打上标记，以便回收。具体有两个策略 3.1 标记清除最常用的垃圾收集方式。当变量进入环境时，就将这个变量标记为“进入环境”。离开环境时，将其标记为“离开环境”。过程：1、垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记。2、它会去掉环境中的变量以及被环境中的变量引用的变量的标记。 3、然后在此之后再被加上标记的变量将被视为准备删除的变量。4、最后垃圾收集器完成内存清除工作。 3.2 引用计数原理：跟踪记录每个值被引用的次数。过程：1、当声明了一个变量，并将一个引用类型值赋给该变量，则这个值的引用次数就是1.2、如果同一个值又被赋给另一个变量，该值的引用次数加1.3、假如包含这个值引用的变量又取得了另外一个值，则这个值的引用次数减1.4、如归该值的引用次数变为0，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。 3.3 性能问题垃圾收集器是周期运行的。确定垃圾收集器的时间间隔是一个非常重要的问题。 3.4 管理内存最主要问题：分配给web浏览器的可用内存数量通常要比分配给桌面应用程序的少。目的：为了防止javascript的网页耗尽全部内存而导致系统崩溃。优化内存占用的最佳方式：就是为执行中的代码保存必要的数据，一旦数据不在有用，最好通过将其设置为null，这个做法叫做解除引用。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引用类型之Function类型学习笔记]]></title>
    <url>%2F2018%2F02%2F26%2FFunction%E7%B1%BB%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Function类型函数实际上是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。由于函数名仅仅是指向函数的指针，一个函数可能会有多个名字。 函数定义的三种方式：1、函数声明 2、函数表达式 3、使用Function构造函数 var sum=new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1+num2&quot;). 1.没有重载可以将函数名想象为指针来理解为什么没有重载。如下 1234567function sum(num)&#123; return 30+num;&#125;function sum(num)&#123; return 40+num;&#125;sum(20) //60 以上代码输出60，说明第二次函数声明覆盖了第一次函数声明，这就说明了函数没有重载，以上代码等价于下面代码 123456var sum=function(num)&#123; return 30+num;&#125;;sum=function(num)&#123; return 40+num;&#125;; 切记：函数名只是指向函数对象的指针 2.函数声明和函数表达式 区别：解析器会首先读取函数声明，使任意代码都可以使用；而函数表达式则要等到执行到该代码行才会被解析。 3.作为值的函数 因为函数名本身就是变量，所以函数也可以作为值来使用。意思是，1、函数可以作为另一个函数的参数 2、函数可以作为一个函数的返回值 4.函数内部属性 在函数内部有两个特殊的对象：arguments和this。arguments是一个类数组对象，保存着函数所有参数。 arguments对象只是与数组类似，它并不是Array的实例。 123function sayhi()&#123; return arguments[0]+','+arguments[1];&#125; 以上代码不包含命名的参数，但函数功能依旧。这说明了ECMAScript函数的一个重要特点：命名的参数只提供便利，但不是必须的。arguments的length属性表示参数的个数。另外arguments对象可以和命名参数一起使用。最后，没有传递值的命名参数将自动被赋予undefined的值，跟定义了变量未初始化一样。 arguments还有个特殊的属性callee：该属性是一个指针，指向拥有这个arguments对象的函数。使用如下 1234567function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else( return num*factorial(num-1); )&#125; 上面代码将函数和函数名紧密地联系在了一起，如果将该函数名赋值给另外一个变量，再将此函数名指向另外一个函数，调用另外一个变量对应的函数时，则会受到该变量名的影响。 1234567function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return num*arguments.callee(num-1); &#125;&#125; 函数内部对象this，this的值是函数执行的环境对象。（当在网页的全局作用域调用函数时this对象的值为window） 12345678window.color='red';var o=&#123;color:'blue'&#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //red this:windowo.sayColor=sayColor;o.sayColor(); //blue this:o 还有一个函数对象的属性：caller。这个属性保存着调用当前函数的函数的引用，如果在全局作用域中调用当前函数，他的值为null。我的理解是，函数A在函数B中调用，函数A中的caller属性就指向函数B。 5.函数的属性和方法每个函数都包含了两个属性：length和prototype。length属性表示希望接受的命名参数的个数。而arguments.length表示有多少个参数传递给了函数。前者说的是命名参数的个数，后者并没有强调命名参数。 1) 对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。2)在创建自定义引用类型以及实现以及实现继承prototype属性是及其重要的。3) prototype属性是不可枚举的，因此使用for-in无法发现。 每个函数都包含两个非继承而来的的方法：apply()和call()两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。 apply()第一个参数在其中运行函数的作用域；另一个是参数数组，可以是Array实例也可以是arguments对象。 call()第一个参数是this值，其余参数都必须逐个列举出来。 他俩的作用：扩充函数赖以运行的作用域。 1234567891011window.color='red';var o=&#123;color:'blue'&#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o) //blue sayColor.call(this)和sayColor.call(window)是两种显式的在全局作用域中调用函数的方式。sayColor.call(o)此时函数体内的this对象指向了o。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5实现滑动解锁功能]]></title>
    <url>%2F2018%2F02%2F25%2Fhtml5%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E8%A7%A3%E9%94%81%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[设计思路 在刚开始做的时候，我做的是直接在html文件里把页面结构写出来，然后再一个一个功能的加上去，写了几个函数之后，发现这样做各个函数之间不好配合，而且感觉该功能的灵活性不够。所以就尝试动态创建html,并且把整个滑动解锁的功能写成一个组件，感觉这样灵活性性要强许多。 我把代码分为三个部分：页面初始化部分、绑定事件部分、密码操作部分。 1. 页面初始化部分：该部分的主要功能是，动态创建页面DOM结构；确定每个解锁圆的圆心；确定画圆函数、画线函数等。 关键代码： 12345678910111213141516171819202122232425262728293031323334 oLock.prototype.getPoint=function()&#123; //规划好每个圆心的位置,并给每个位置加上序号 var n=3; var num=0; this.r=this.oC.width/(2+4*n); //让圆心均匀分布在中心的公式 this.usedArr=[]; //重置usedArr; this.arr=[]; this.restArr=[]; //剩下的小圈圈集合 var r=this.r; for(var i=0;i&lt;n;i++)&#123; //存每个点的坐标 for(var j=0;j&lt;n;j++)&#123; num++; var obj=&#123; x: j*4*r+3*r, y: i*4*r+3*r, index:num, &#125;; this.arr.push(obj); this.restArr.push(obj); &#125; &#125; this.oGC.clearRect(0,0,this.oC.width,this.oC.height); for(var i=0;i&lt;this.arr.length;i++)&#123; this.createCle(this.arr[i].x,this.arr[i].y); &#125;&#125;oLock.prototype.createCle=function(x,y)&#123; //画每个圆圈 this.oGC.lineWidth=2; this.oGC.strokeStyle="#E6E6E6"; this.oGC.beginPath(); this.oGC.arc(x,y,this.r,0,Math.PI*2,true); this.oGC.closePath(); this.oGC.stroke();&#125; 这两个的功能是找到每个圆的圆心，并把每个圆给画出来。圆的半径r和canvas宽度有关。 r=this.oC.width/(2+4n)的得来：我想的是每个圆之间，以及圆和边界间隔一个半径，所以可以得到width=(2r)(n+1)+2rn,求得r=width/(2+4n)。 此处遇到的坑：当初没有写上this.usedArr=[]这句话，导致usedArr没有清空，第二次点击滑动的时候自动添加了上一次路径😂 2. 事件绑定部分：该部分主要就是添加touchstart、touchmove、touchend事件相对应的功能；实现滑动解锁具体操作。 **关键代码：** 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071oLock.prototype.pickPoints=function(from,to)&#123; var olength=getDis(from,to); var dir=to.index&gt;from.index?1:-1; var len=this.restArr.length; var i= dir==1?0:(len-1); var limit= dir==1?len:-1; while( i!=limit )&#123; var pt=this.restArr[i]; if(getDis(pt,from)+getDis(pt,to)==olength)&#123; this.createPoint(pt.x,pt.y); this.usedArr.push(pt); this.restArr.splice(i,1); if(limit&gt;0)&#123; i--; limit--; &#125; &#125; i+=dir; &#125;&#125;oLock.prototype.boss=function(pos)&#123; //核心方法 this.oGC.clearRect(0,0,this.oC.width,this.oC.height); for(var i=0;i&lt;this.arr.length;i++)&#123; this.createCle(this.arr[i].x, this.arr[i].y); &#125; this.createPoint(); this.createLine(pos); console.log(this.restArr.length); for(var i=0;i&lt;this.restArr.length;i++)&#123; var tp=this.restArr[i]; if(Math.abs(pos.x-tp.x)&lt;this.r &amp;&amp; Math.abs(pos.y-tp.y)&lt;this.r)&#123; this.createPoint(); this.pickPoints(this.usedArr[this.usedArr.length-1],tp); break; &#125; &#125; &#125;oLock.prototype.bindEv=function()&#123; var This=this; this.oC.addEventListener("touchstart",function(ev)&#123; var pos=This.getPos(ev); console.log(pos); for(var i=0;i&lt;This.arr.length;i++)&#123; if( Math.abs(pos.x-This.arr[i].x)&lt;This.r &amp;&amp; Math.abs(pos.y-This.arr[i].y)&lt;This.r )&#123; //判断点击的位置是不是在小圈圈里面 // alert(1); This.onOff=true; This.usedArr.push(This.arr[i]); This.restArr.splice(i,1); break; &#125; &#125; &#125;); this.oC.addEventListener("touchmove",function(ev)&#123; if(This.onOff)&#123; This.boss(This.getPos(ev)); &#125; &#125;); this.oC.addEventListener("touchend",function(ev)&#123; if(This.onOff)&#123; This.onOff=true; This.doPassword(This.usedArr); setTimeout(function()&#123; This.getPoint(); //touchend之后要初始化页面一下 &#125;,300); &#125; &#125;); &#125; 这里的usedArr是指已经被圈出的小圆圈，restArr是指剩下没被全出的小圆圈。boss函数是控制连线，里面的pickPoints函数作用是当触摸点接触到小圈圈的时候，将该小圈圈的index添入usedArr，并删除restArr里面相对应的元素 此处的坑：一开始并没有注意事件里面this的指向和外面的不同，导致错误，在bindEv里写上var This=this就OK了 3. 密码操作部分：此处功能包含，修改密码并删除localStorage里面存的东西；验证输入密码是否与设置的相同；设置密码时各种不符合规则的检查等。 关键代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556oLock.prototype.selectFun=function()&#123; var aInput=document.getElementsByTagName("input"); var that=this; aInput[0].onfocus=function()&#123; document.getElementById('header').innerHTML="请解锁"; oLock.prototype.doPassword=function(pw)&#123; if( window.localStorage.getItem('password') )&#123; if(that.pwObj.nowPw)&#123; if(that.checkPassword(that.pwObj.nowPw,pw))&#123; document.getElementById('header').innerHTML='解锁成功'; that.createCleLine('#00F90F'); &#125;else&#123; document.getElementById('header').innerHTML='解锁失败'; that.createCleLine('red'); &#125; &#125;else&#123; alert("还未设置密码"); &#125; &#125;else&#123; alert("还未设置密码"); &#125; &#125; &#125;; aInput[1].onfocus=function()&#123; document.getElementById('header').innerHTML="请绘制解锁图案"; that.pwObj=&#123;&#125;; that.getPoint(); oLock.prototype.doPassword=function(pw)&#123; if(that.pwObj.step==1)&#123; if(that.checkPassword(that.pwObj.formerPw,pw))&#123; that.pwObj.step=2; that.pwObj.nowPw=pw; document.getElementById('header').innerHTML='密码保存成功'; that.createCleLine('#00F90F'); window.localStorage.setItem('password',JSON.stringify(that.pwObj.nowPw)); &#125;else&#123; document.getElementById('header').innerHTML="两次输入不一致，请重新输入"; that.createCleLine('red'); delete that.pwObj.step; &#125; &#125;else&#123; if(pw.length&lt;5)&#123; document.getElementById('header').innerHTML="密码太短，至少需要五个点"; that.createCleLine('red'); that.pwObj=&#123;&#125;; &#125;else&#123; that.pwObj.step=1; that.pwObj.formerPw=pw; document.getElementById('header').innerHTML="再次输入"; &#125; &#125; &#125; &#125;;&#125; 这个函数主要功能就是通过单选按钮来控制是设置密码还是验证密码，具体做法就是通过改变oLock.prototype.doPassword来实现的，不同的选择会使oLock.prototype.doPassword里面对应的方法不同，从而实现模式的切换。 遇到的坑：在打开页面的时候并没有触发onfocus事件，所以oLock.prototype.doPassword就不会被定义。解决方法就是在外面先定义一下这个方法。]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据结构与算法学习笔记(一)]]></title>
    <url>%2F2018%2F02%2F25%2Fjs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[JavaScript数据结构与算法学习笔记(一) 前言：考完研啦，前端大半年没碰了，最近开始恶补一番😂。去年参加了几次实习生招聘，吃亏在数据结构和算法方面，最近在专门针对这方面进行学习。在这里记录下自己需要熟记的一些知识点以及弱项。首先从难的开始～ 排序总结六种排序方式实现：冒泡排序、选择排序、插入排序、归并排序、快速排序和堆排序 1.冒泡排序原理：比较相邻的两个项，如果第一个比第二个大，则交换他们。实现如下 12345678910111213var bubbleSort=function(arr)&#123; var length=arr.length; for(var i=0;i&lt;length;i++)&#123; for(var j=0;j&lt;length-1;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; swap(arr,j,j+1); //交换值的函数 &#125; &#125; &#125;&#125;function swap(arr,i,j)&#123; [arr[i],arr[j]]=[arr[j],arr[i]]; &#125; 外包围的循环控制经过了多少轮排序，内包围的将第一位迭代至倒数第二位，这种冒泡排序会比较已经排好的元素，性能会下降。下面是改进后的冒泡排序 12345678910var modifiedBubbleSort=function(arr)&#123; var length=arr.length; for(var i=0;i&lt;length;i++)&#123; for(var j=0;j&lt;length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; swap(arr,j,j+1); &#125; &#125; &#125;&#125; 2.选择排序大致思路：找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推 123456789101112131415var selectionSort=function(arr)&#123; var length=arr.length, indexMin; for(var i=0;i&lt;length-1;i++)&#123; indexMin=i; for(var j=i;j&lt;length;j++)&#123; if(arr[indexMin]&gt;arr[j])&#123; indexMin=j; &#125; &#125; if(i!==indexMin)&#123; swap(arr,indexMin,i); &#125; &#125;&#125; 流程： 首先假设本迭代轮次的第一个值为数组的最小值 从当前i的值开始至数组结束，比较j的值是否比当前最小值小；如果是，则将j的值作为最小值 如果最小值和原来的最小值不同，则交换他俩 冒泡排序和选择排序一样，它们都包含了嵌套的两个循环，导致了二次方的复杂度。 3.插入排序原理：插入排序每次排一个数组项，以此方式构建最后的排序数组。例如，第一项已经排好，现在比较第二项和第一项，看看第二项是呆在原地还是插入到第一项的前面？接着，操作第三项，通过和前两项的比较，看看第三项是插入到哪地方。我的个人理解就是：数组的某一项在他前面所有项依次进行比较，如果找到比他大的实现如下： 12345678910111213var insertionSort=function(arr)&#123; var length=arr.length, j,temp; for(var i=1;i&lt;length;i++)&#123; //假定第一项已经排好，所以i从1开始 j=i; temp=arr[i]; while(j&gt;0 &amp;&amp; arr[j-1]&gt;temp)&#123; arr[j]=arr[j-1]; j--; &#125; arr[j]=temp; &#125;&#125; 此算法性能好于选择排序和冒泡排序 4.归并排序 归并排序是第一个可以实际使用的排序算法，复杂度为O(nlogn) 原理：把原始数组分成比较小的数组，直到每个小数组只有一个位置，接着将小数组归并成比较大的数组，直到最后只有一个排序完毕的大数组。我的理解就是，第一步把数组切分成只有一项元素的子数组；第二步再把这些子数组依次合并，最终变成一个完整的数组。 当实现一个递归函数，我们都会实现一个实际被执行的辅助函数。如下先实现merge函数，他负责合并和排序小数组来产生大数组 12345678910111213141516171819202122var merge = function(left,right)&#123; //接收两个参数，排序发生在合并过程中 var result=[], il=0, ir=0; while(il&lt;left.length &amp;&amp; ir&lt;right.length)&#123; //依次比较来自left数组的项是否比来自right数组的项要小，如果是，则将该元素添加到result数组中，并递增迭代数组的控制变量，否则则操作right if(left[il]&lt;right[ir])&#123; result.push(left[il++]); &#125;else&#123; result.push(right[ir++]); &#125; &#125; while(il&lt;left.length)&#123; //将剩余的的项添加到result数组中 result.push(left[il++]); &#125; while(ir&lt;right.length)&#123; result.push(right[ir++]); &#125; return result;&#125; 接下来，定义一个递归函数，作用利用递归把数组切成只有一项，然后调用merge函数进行合并排序 123456789101112var mergeSortRec=function(arr)&#123; var length=arr.length; if(arr.length==1)&#123; //递归的停止条件，如果数组长度是1，则返回这个长度为1的数组。 return arr; &#125; var mid=Math.floor(length/2); var left=arr.slice(0,mid); var right=arr.slilce(mid,length); return merge(mergeSortRec(left),mergeSortRec(right));&#125; 最后，定义一个mergeSort函数完成整个归并算法 123var mergeSort=function(arr)&#123; arr=mergeSortRec(arr);&#125; 归并排序的时间复杂度为O(nlogn) 5.快速排序 步骤：1、从数组中选择中间一项作为主元2、创建两个指针，左边一个指向数组的第一项，右边一个指向数组的最后一项。移动左指针直到找到一个比主元大的元素，接着，移动右指针直到找到一个比主元小的元素，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在了主元之前，而比主元大的值都排在了主元之后。这一步叫划分操作。3、接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复前两个步骤，直到数组完全排序。 123function quickSort(arr)&#123; quick(arr,0,arr.length-1);&#125; 像归并排序一样，首先定义一个主函数来调用递归函数，传递待排数组，以及索引0及最末的位置。 5.1 划分操作的实现第一件事情就是要选择主元（pivot）。我们选择中间项作为主元 1234567891011121314151617181920var partition=function(arr,left,right)&#123; var pivot=arr[Math.floor((left+right)/2)]; var i=left; var j=right; while(i&lt;=j)&#123; while(arr[i]&lt;pivot)&#123; i++ &#125; while(arr[j]&gt;pivot)&#123; j-- &#125; if(i&lt;=j)&#123; swap(arr,i,j); i++; j-- &#125; &#125; return i;&#125; 当左指针指向的元素比主元大且右指针指向的元素比主元小，并且此时左指针索引没有右指针索引大。然后交换他俩，移动指针，并重复此过程。下面实现递归函数quick 1234567891011121314var quick=function(arr,left,right)&#123; var index; if(arr.length&gt;1)&#123; index=partition(arr,left,right); if(left&lt;index-1)&#123; quick(arr,left,index-1); &#125; if(index&lt;right)&#123; quick(arr,index,right) &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建博客心得]]></title>
    <url>%2F2018%2F02%2F24%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[MAC环境下利用Hexo+github搭建博客心得 前言：此次是利用hexo+github搭建博客，主要目的就是整理之前的项目，梳理一下思路，方便在面试的时候有所展示；同时也方便今后学习和项目的总结～ 搭建这个博客我花了一天时间，主要是通过参考他人搭建经历完成的。网上搭建流程有很多，在此就不再赘述。本文主要是记录下自己在搭建博客中学到的东西和踩过的坑。 1.what’s Hexo?Hexo是一个快速, 简洁且高效的博客框架. 让上百个页面在几秒内瞬间完成渲染. Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件. 并自己也拥有强大的插件系统. 2.Hexo相关指令 安装Hexo 之前得安装好nodejs，在安装好nodejs之后，在终端执行下列指令 1$ sudo npm install -g hexo-cli 坑一：Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。 初始化 首先必须cd到准备用来搭建博客的文件夹，执行hexo init命令 接着在该文件夹下执行npm的安装指令npm install 最后开启hexo服务器hexo s，并在浏览器中打开http://localhost:4000可以见到初始化页面 更新主题配置和部署文章 每次文章发布和主题属性都要进行以下步骤才能同步到博客上 123$ hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)$ hexo g //生成缓存和静态文件$ hexo d //重新部署到服务器 3.next主题配置 坑二：在配置站点配置文件和主题配置文件时（所有的_config.yml），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错。切记，很坑😂 菜单设置 通过修改next主题下的_config.yml的menu字段，选定显示的菜单项。 1234567menu: home: / categories: /categories about: /about archives: /archives tags: /tags #commonweal: /404.html 其中，home代表主页，categories代表分类页，about代表关于页面，archives代表归档页，commonweal代表404页面（page not found时候显示的页面）。在设置好菜单后，就会出现这一系列按钮，此时点击这些按钮时，会弹出页面不存在，这是因为这些页面还没设置的原因 添加标签页面 1.新建页面 12$ cd Blog //Blog是选择作为搭建博客的那个文件夹名称$ hexo new page tags 2.设置页面的类型在上步新生成的myBlog/source/tags/index.md中添加type: &quot;tags&quot;，index.md文件内容如下： 123title: tagsdate: 2018-02-24 09:40:00type: &quot;tags&quot; //加上这句话 添加标签才能起作用 3.设置具体文章的tags 123title: 搭建博客心得categories: 搭建博客tags: [npm, hexo, github] 添加分类页面 步骤和添加标签页面一摸一样，只需将tags改成categories 添加关于我(about)页面 1.新建页面 12$ cd myBlog$ hexo new page about 输入命令后，在myBlog/source下会新生成一个新的文件夹about，在该文件夹下会有一个index.md文件。 2.修改index.md 我的index.md配置如下 1234567891011121314---title: aboutdate: 2018-02-23 13:13:14---##关于我一只正在如饥似渴学习前端的小菜鸟～微信：zfight13QQ: 707085615Email: scty8888@163.com]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>

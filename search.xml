<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[html5实现滑动解锁功能]]></title>
    <url>%2F2017%2F03%2F29%2Fhtml5%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E8%A7%A3%E9%94%81%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[设计思路 在刚开始做的时候，我做的是直接在html文件里把页面结构写出来，然后再一个一个功能的加上去，写了几个函数之后，发现这样做各个函数之间不好配合，而且感觉该功能的灵活性不够。所以就尝试动态创建html,并且把整个滑动解锁的功能写成一个组件，感觉这样灵活性性要强许多。 我把代码分为三个部分：页面初始化部分、绑定事件部分、密码操作部分。 1. 页面初始化部分：该部分的主要功能是，动态创建页面DOM结构；确定每个解锁圆的圆心；确定画圆函数、画线函数等。 关键代码： 12345678910111213141516171819202122232425262728293031323334 oLock.prototype.getPoint=function()&#123; //规划好每个圆心的位置,并给每个位置加上序号 var n=3; var num=0; this.r=this.oC.width/(2+4*n); //让圆心均匀分布在中心的公式 this.usedArr=[]; //重置usedArr; this.arr=[]; this.restArr=[]; //剩下的小圈圈集合 var r=this.r; for(var i=0;i&lt;n;i++)&#123; //存每个点的坐标 for(var j=0;j&lt;n;j++)&#123; num++; var obj=&#123; x: j*4*r+3*r, y: i*4*r+3*r, index:num, &#125;; this.arr.push(obj); this.restArr.push(obj); &#125; &#125; this.oGC.clearRect(0,0,this.oC.width,this.oC.height); for(var i=0;i&lt;this.arr.length;i++)&#123; this.createCle(this.arr[i].x,this.arr[i].y); &#125;&#125;oLock.prototype.createCle=function(x,y)&#123; //画每个圆圈 this.oGC.lineWidth=2; this.oGC.strokeStyle="#E6E6E6"; this.oGC.beginPath(); this.oGC.arc(x,y,this.r,0,Math.PI*2,true); this.oGC.closePath(); this.oGC.stroke();&#125; 这两个的功能是找到每个圆的圆心，并把每个圆给画出来。圆的半径r和canvas宽度有关。 r=this.oC.width/(2+4n)的得来：我想的是每个圆之间，以及圆和边界间隔一个半径，所以可以得到width=(2r)(n+1)+2rn,求得r=width/(2+4n)。 此处遇到的坑：当初没有写上this.usedArr=[]这句话，导致usedArr没有清空，第二次点击滑动的时候自动添加了上一次路径😂 2. 事件绑定部分：该部分主要就是添加touchstart、touchmove、touchend事件相对应的功能；实现滑动解锁具体操作。 **关键代码：** 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071oLock.prototype.pickPoints=function(from,to)&#123; var olength=getDis(from,to); var dir=to.index&gt;from.index?1:-1; var len=this.restArr.length; var i= dir==1?0:(len-1); var limit= dir==1?len:-1; while( i!=limit )&#123; var pt=this.restArr[i]; if(getDis(pt,from)+getDis(pt,to)==olength)&#123; this.createPoint(pt.x,pt.y); this.usedArr.push(pt); this.restArr.splice(i,1); if(limit&gt;0)&#123; i--; limit--; &#125; &#125; i+=dir; &#125;&#125;oLock.prototype.boss=function(pos)&#123; //核心方法 this.oGC.clearRect(0,0,this.oC.width,this.oC.height); for(var i=0;i&lt;this.arr.length;i++)&#123; this.createCle(this.arr[i].x, this.arr[i].y); &#125; this.createPoint(); this.createLine(pos); console.log(this.restArr.length); for(var i=0;i&lt;this.restArr.length;i++)&#123; var tp=this.restArr[i]; if(Math.abs(pos.x-tp.x)&lt;this.r &amp;&amp; Math.abs(pos.y-tp.y)&lt;this.r)&#123; this.createPoint(); this.pickPoints(this.usedArr[this.usedArr.length-1],tp); break; &#125; &#125; &#125;oLock.prototype.bindEv=function()&#123; var This=this; this.oC.addEventListener("touchstart",function(ev)&#123; var pos=This.getPos(ev); console.log(pos); for(var i=0;i&lt;This.arr.length;i++)&#123; if( Math.abs(pos.x-This.arr[i].x)&lt;This.r &amp;&amp; Math.abs(pos.y-This.arr[i].y)&lt;This.r )&#123; //判断点击的位置是不是在小圈圈里面 // alert(1); This.onOff=true; This.usedArr.push(This.arr[i]); This.restArr.splice(i,1); break; &#125; &#125; &#125;); this.oC.addEventListener("touchmove",function(ev)&#123; if(This.onOff)&#123; This.boss(This.getPos(ev)); &#125; &#125;); this.oC.addEventListener("touchend",function(ev)&#123; if(This.onOff)&#123; This.onOff=true; This.doPassword(This.usedArr); setTimeout(function()&#123; This.getPoint(); //touchend之后要初始化页面一下 &#125;,300); &#125; &#125;); &#125; 这里的usedArr是指已经被圈出的小圆圈，restArr是指剩下没被全出的小圆圈。boss函数是控制连线，里面的pickPoints函数作用是当触摸点接触到小圈圈的时候，将该小圈圈的index添入usedArr，并删除restArr里面相对应的元素 此处的坑：一开始并没有注意事件里面this的指向和外面的不同，导致错误，在bindEv里写上var This=this就OK了 3. 密码操作部分：此处功能包含，修改密码并删除localStorage里面存的东西；验证输入密码是否与设置的相同；设置密码时各种不符合规则的检查等。 关键代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556oLock.prototype.selectFun=function()&#123; var aInput=document.getElementsByTagName("input"); var that=this; aInput[0].onfocus=function()&#123; document.getElementById('header').innerHTML="请解锁"; oLock.prototype.doPassword=function(pw)&#123; if( window.localStorage.getItem('password') )&#123; if(that.pwObj.nowPw)&#123; if(that.checkPassword(that.pwObj.nowPw,pw))&#123; document.getElementById('header').innerHTML='解锁成功'; that.createCleLine('#00F90F'); &#125;else&#123; document.getElementById('header').innerHTML='解锁失败'; that.createCleLine('red'); &#125; &#125;else&#123; alert("还未设置密码"); &#125; &#125;else&#123; alert("还未设置密码"); &#125; &#125; &#125;; aInput[1].onfocus=function()&#123; document.getElementById('header').innerHTML="请绘制解锁图案"; that.pwObj=&#123;&#125;; that.getPoint(); oLock.prototype.doPassword=function(pw)&#123; if(that.pwObj.step==1)&#123; if(that.checkPassword(that.pwObj.formerPw,pw))&#123; that.pwObj.step=2; that.pwObj.nowPw=pw; document.getElementById('header').innerHTML='密码保存成功'; that.createCleLine('#00F90F'); window.localStorage.setItem('password',JSON.stringify(that.pwObj.nowPw)); &#125;else&#123; document.getElementById('header').innerHTML="两次输入不一致，请重新输入"; that.createCleLine('red'); delete that.pwObj.step; &#125; &#125;else&#123; if(pw.length&lt;5)&#123; document.getElementById('header').innerHTML="密码太短，至少需要五个点"; that.createCleLine('red'); that.pwObj=&#123;&#125;; &#125;else&#123; that.pwObj.step=1; that.pwObj.formerPw=pw; document.getElementById('header').innerHTML="再次输入"; &#125; &#125; &#125; &#125;;&#125; 这个函数主要功能就是通过单选按钮来控制是设置密码还是验证密码，具体做法就是通过改变oLock.prototype.doPassword来实现的，不同的选择会使oLock.prototype.doPassword里面对应的方法不同，从而实现模式的切换。 遇到的坑：在打开页面的时候并没有触发onfocus事件，所以oLock.prototype.doPassword就不会被定义。解决方法就是在外面先定义一下这个方法。]]></content>
      <categories>
        <category>project</category>
      </categories>
  </entry>
</search>

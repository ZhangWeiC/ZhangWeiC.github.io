<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试--原型链]]></title>
    <url>%2F2020%2F02%2F25%2F%E9%9D%A2%E8%AF%95--%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原型链涉及的问题 创建对象有几种方法 原型、构造函数、实例、原型链 instanceOf原理 new运算符 创建对象有几种方法 字面量创建 构造函数创建 Object.create() 12345678var o1 = &#123;name: 'value'&#125;;var o2 = new Object(&#123;name: 'value'&#125;);var M = function() &#123;this.name = 'o3'&#125;;var o3 = new M();var P = &#123;name: 'o4'&#125;;var o4 = Object.create(P) 原型、构造函数、实例、原型链四者之间的关系 JavaScript 的所有对象中都包含了一个 __proto__ 内部属性，这个属性的值就是该对象的原型 JavaScript 的函数对象，除了原型 __proto__ 之外，还有一个 prototype 属性 当函数对象作为构造函数创建实例时，其prototype属性值将被作为实例对象的原型 __proto__ 原型链原型链是通过对象的__proto__连接的；一个对象在查找一个方法或属性时，他会先在自己的对象上去找，找不到时，他会沿着原型链依次向上查找。 注意： 函数才有prototype，实例对象只有__proto__， 而函数有__proto__是因为函数是Function的实例对象。 instanceOf原理判断实例对象的__proto__属性与构造函数的prototype是不是用一个引用。如果不是，他会沿着对象的__proto__向上查找的，直到顶端Object。 12345678910111213function myInstanceOf(left, right) &#123; let rightProto = right.prototype left = left.__proto__ while(true) &#123; if(left === null)&#123; return false &#125; if(left === rightProto)&#123; return true &#125; left = left.__proto__ &#125;&#125; new运算符12345678910function myNew(fn) &#123; var o = Object.create(fn.prototype) var k = fn.call(o) if(typeof k === 'object') &#123; return k &#125; else &#123; return o &#125;&#125;]]></content>
      <categories>
        <category>面试准备</category>
      </categories>
      <tags>
        <tag>面试准备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试--类型转换]]></title>
    <url>%2F2020%2F02%2F24%2F%E9%9D%A2%E8%AF%95--%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[类型转换涉及的问题 数据类型 显式类型转换 隐式类型转换 数据类型基础类型6种：number、string、boolean、null、undefined、symbol 引用类型：对象、函数、数组 显式类型转换 Number() 函数 数值：转换后还是原来的值 字符串：如果可以被解析为数值则转化为数值，否则转换为NaN，空字符串转换为0 布尔值：true转为1；false转为0 undefined：转为NaN null：转为0 对象： 调用对象自身的valueOf方法，如果返回值是基础类型，调用Number方法 如果返回值不是基础类型调用对象自身的toString方法，再调用Number方法 String() 函数 数值：转换为相应的字符串 字符串：转换后还是原来的值 布尔值：true转为’true’；false转为’false’ undefined：转为’undefined’ null：转为’null’ 对象： 调用对象自身的toString方法，如果返回值是基础类型，调用Number方法 如果返回值不是基础类型调用对象自身的valueOf方法，再调用Number方法 Boolean() 函数 +0、-0、’’、undefined、null、NaN转化为false 其余转换成true]]></content>
      <categories>
        <category>面试准备</category>
      </categories>
      <tags>
        <tag>面试准备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试--HTTP协议类]]></title>
    <url>%2F2020%2F02%2F24%2F%E9%9D%A2%E8%AF%95--HTTP%E5%8D%8F%E8%AE%AE%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[HTTP协议所涉及的问题 HTTP协议的主要特点 HTTP报文的组成部分 HTTP方法 POST和GET的区别 HTTP状态码 什么是持久化连接 什么是管线化 HTTP协议的主要特点 无连接 限制每次连接只处理一个请求 无状态 协议对于事务处理没有记忆能力 灵活 HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记 简单快速 客户向服务器请求服务时，只需传送请求方法和路径 HTTP报文的组成部分 请求报文 请求行 请求类型 要访问的资源 HTTP协议版本号 请求头 用来说明服务器要使用的附加信息（一些键值对） 例如：User-Agent、 Accept、Content-Type、Connection 空行 分割请求头和请求体的 请求体 请求的内容部分 响应报文 状态行 状态码 状态消息 HTTP协议版本号 响应头 说明客户端要使用的一些附加信息 如：Content-Type、charset、响应的时间 空行 响应正文 返回给客户端的文本信息 HTTP方法 GET 获取资源 POST 传输资源 PUT 更新资源 DELETE 删除资源 HEAD 获取报文首部 POST和GET的区别 GET在浏览器回退时是无害的，而POST会再次提交 GET请求能缓存，POST不能 POST相对GET相对安全一些，因为GET请求都包含在URL中，而且会被浏览器保存记录，POST不会。 POST 可以通过 request body来传输比 GET 更多的数据 URL有长度限制，会影响 GET 请求，但是这个长度限制是浏览器规定的 POST 支持更多的编码类型且不对数据类型限制；GET只支持URL编码 HTTP状态码1XX 提示信息：表示请求已接收，继续处理 2XX 成功： 200 OK 204 No content，表示请求成功，但响应报文不含实体的主体部分 206 Partial Content，进行范围请求 3XX 重定向 301 永久性重定向，表示资源已被分配了新的 URL 302 临时性重定向，表示资源临时被分配了新的 URL 304 not modify，重定位到浏览器。 4XX 客户端错误 404 not found，在服务器上没有找到请求的资源 403 forbidden，表示对请求资源的访问被服务器拒绝 400 bad request，请求报文存在语法错误 401 Unanthorized，未授权，表示发送的请求需要有通过 HTTP 认证的认证信息 5XX 服务端错误 500 Internal Server Error，服务器内部错误 503 Service Unavailable，服务器不可用 什么是持久化连接(HTTP1.1以上支持)HTTP协议采用“请求-应答”模式，并且HTTP是基于TCP进行连接的。普通模式（非keep-alive）时，每个请求或应答都需要建立一个连接，完成之后立即断开。 当使用Connection: keep-alive模式（又称持久连接、连接重用）时，keep-alive使客户端道服务器端连接持续有效，即不关闭底层的TCP连接，当出现对服务器的后继请求时，keep-alive功能避免重新建立连接。 什么是管线化(HTTP1.1以上支持) 管线化后，请求和响应不再是依次交替的了。他可以支持一次性发送多个请求，并一次性接收多个响应。 注意： 只有GET与HEAD请求可以进行管线化，POST有限制 初次创建连接时不应该启动管线机制，因为服务器不一定支持该协议]]></content>
      <categories>
        <category>面试准备</category>
      </categories>
      <tags>
        <tag>面试准备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试--CSS盒模型]]></title>
    <url>%2F2020%2F02%2F23%2F%E9%9D%A2%E8%AF%95--CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[CSS盒模型涉及的问题(由浅入深) 基本概念：标准模型+IE模型 标准模型和IE模型的区别 CSS如何设置这两种模型 JS如何设置盒模型对应的宽和高 根据盒模型解释边距重叠 BFC、IFC 基本概念：标准模型+IE模型 标准模型：width = width IE模型：width = width + padding + border 标准盒模型和IE模型的区别标准模型的宽高是指的content区宽高； IE盒模型的宽高是指的content+padding+border的宽高 CSS如何设置这两种模型 标准模型：box-sizing: content-box IE模型：box-sizing: border-box JS如何设置盒模型对应的宽和高 dom.style.width/height 只能获取到内联样式的宽和高 dom.currentStyle.width/height 能正常获取样式，但仅限于IE浏览器 window.getComputedStyle(dom).width/height 能正常获取宽高，不限浏览器 dom.getBoundingClientRect().width/height 获取绝对位置，不限浏览器 根据盒模型解释外边距重叠当两个或者更多的垂直外边距相遇时，它们将形成一个外边距，这个外边距的高度等于两个发生叠加的外边距中高度较大者。 外边距重叠只会发生在普通文档流的垂直方向，行内框、浮动框、绝对定位框之间的外边距不会发生叠加，同样水平方向也不会发生叠加。 兄弟节点 父子节点 两个空元素 一个空元素，一个非空元素 BFC块级格式化上下文，它是一个独立的渲染区域，区域内外互不干扰 BFC特点 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素 计算BFC的高度，浮动元素也参与计算 属于同一个BFC的两个相邻的子元素margin会发生重叠；分属于不同的BFC时，可以阻止margin重叠 BFC的区域不会与浮动区域重叠 如何创造一个BFC display等于inline-block、table-cell、table-caption float不等于none overflow不为visible position等于absolute或者fixed]]></content>
      <categories>
        <category>面试准备</category>
      </categories>
      <tags>
        <tag>面试准备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试--DOM事件类]]></title>
    <url>%2F2020%2F02%2F23%2F%E9%9D%A2%E8%AF%95--DOM%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[DOM事件类 基本概念：DOM事件的级别 DOM事件模型 DOM事件流 描述DOM事件捕获的具体流程 自定义事件 DOM事件的级别 DOM0 onXXX类型的事件类型。eg: onclick element.onclick=function(e) {...} DOM2 增加了addEventListener方式 element.addEventListener(&#39;click&#39;, function (e) { ... }) DOM3 增加很多事件类型，eg: keyup DOM事件模型 捕获从上到下， 冒泡从下到上。 先捕获，再到目标，再冒泡。 DOM事件流dom事件流从window开始，到达目标对象后，再返回至window处。 DOM标准规定事件流包括三个阶段： 事件捕获阶段 处于目标阶段 事件冒泡阶段 描述DOM事件捕获的具体流程window-&gt;document-&gt;html-&gt;body-&gt;…-&gt;目标元素 自定义事件 Event CustomEvent CustomEvent不仅可以用来做自定义事件，还可以在后面跟一个object做参数 123456789 var evt = new Event('myEvent') // 处理自定义事件someDom.addEventListener('myEvent', function() &#123; //some code&#125;); // 触发自定义事件 someDom.dispatchEvent(evt)]]></content>
      <categories>
        <category>面试准备</category>
      </categories>
      <tags>
        <tag>面试准备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试--页面布局]]></title>
    <url>%2F2020%2F02%2F22%2F%20%E9%9D%A2%E8%AF%95--%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[三栏布局左右定宽，中间自适应 No.1 利用float HTML结构 12345&lt;div class="container"&gt; &lt;div class='left'&gt;&lt;/div&gt; &lt;div class='right'&gt;&lt;/div&gt; &lt;div class='middle'&gt;&lt;/div&gt;&lt;/div&gt; CSS： 1234567891011.container, .container&gt;div &#123; height: 100px;&#125;.left &#123; width: 300px; float: left; &#125; .right &#123; width: 300px; float: right; &#125; No.2 利用absolute HTML结构 12345&lt;div class="container"&gt; &lt;div class='left'&gt;&lt;/div&gt; &lt;div class='middle'&gt;&lt;/div&gt; &lt;div class='right'&gt;&lt;/div&gt;&lt;/div&gt; CSS： 12345678910111213141516.container, .container&gt;div &#123; height: 100px; position: absolute;&#125;.left &#123; width: 300px; left: 0; &#125; .right &#123; width: 300px; right: 0; &#125; .middle &#123; left: 300px; right: 300px; &#125; No.3 利用flex HTML结构 12345&lt;div class="container"&gt; &lt;div class='left'&gt;&lt;/div&gt; &lt;div class='middle'&gt;&lt;/div&gt; &lt;div class='right'&gt;&lt;/div&gt;&lt;/div&gt; CSS： 123456789101112131415.container &#123; display: flex;&#125;.container&gt;div &#123; height: 100px;&#125;.left &#123; width: 300px; &#125; .middle &#123; flex: 1; &#125; .right &#123; width: 300px; &#125; No.4 利用table HTML结构 12345&lt;div class="container"&gt; &lt;div class='left'&gt;&lt;/div&gt; &lt;div class='middle'&gt;&lt;/div&gt; &lt;div class='right'&gt;&lt;/div&gt;&lt;/div&gt; CSS： 1234567891011121314.container &#123; display: table; height: 100px; width: 100%;&#125;.container&gt;div &#123; display: table-cell;&#125;.left &#123; width: 300px; &#125; .right &#123; width: 300px; &#125; No.5 利用grid HTML结构 12345&lt;div class="container"&gt; &lt;div class='left'&gt;&lt;/div&gt; &lt;div class='middle'&gt;&lt;/div&gt; &lt;div class='right'&gt;&lt;/div&gt;&lt;/div&gt; CSS： 123456.container &#123; display: gird; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; width: 100%;&#125;]]></content>
      <categories>
        <category>面试准备</category>
      </categories>
      <tags>
        <tag>面试准备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术笔记--11.27]]></title>
    <url>%2F2019%2F11%2F27%2F%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-2019.11.27%2F</url>
    <content type="text"><![CDATA[vue watch中的immediatewatch有一个特点，就是当值第一次绑定的时候，不会执行监听函数，只有值发生改变才会执行。如果需要在最初绑定值的时候也执行函数，则就需要用到immediate属性。 使用场景：父组件向子组件动态传值时，子组件props首次获取到父组件传来的默认值时，也需要执行函数，此时就需要将immediate设为true。 1234567891011121314new Vue(&#123; el: '#root', data: &#123; cityName: '' &#125;, watch: &#123; cityName: &#123; handler(newName, oldName) &#123; // ... &#125;, immediate: true &#125; &#125; &#125;) vue watch中的deep（监听对象里面的属性值发生改变）当需要监听一个对象的改变时，普通的watch方法无法监听到对象内部属性的改变，只有data中的数据才能够监听到变化，此时就需要deep属性对对象进行深度监听。 1&lt;input type="text" v-model="cityName.name"/&gt; 1234567891011121314new Vue(&#123; el: '#root', data: &#123; cityName: &#123;id: 1, name: 'shanghai'&#125; &#125;, watch: &#123; cityName: &#123; handler(newName, oldName) &#123; // ... &#125;, deep: true, immediate: true &#125; &#125; &#125;) 上述会给cityName的所有属性都加上这个监听器，当对象属性较多时，每个属性值的变化都会执行handler。 如果只需要监听对象中的一个属性值，则可以做以下优化：使用字符串的形式监听对象属性： 12345678910watch: &#123; 'cityName.name': &#123; handler(newName, oldName) &#123; // ... &#125;, deep: true, immediate: true &#125;&#125;]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode--记录]]></title>
    <url>%2F2019%2F06%2F10%2Fleetcode--%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[leetcode–记录字符串转换整数 (atoi)123var myAtoi = function(str) &#123; return Math.max(Math.min(parseInt(str) || 0, 2147483647), -2147483648)&#125;; ###知识点： parseInt： 只有字符串中的第一个数字会被返回。 开头和结尾的空格是允许的。 如果字符串的第一个字符不能被转换为数字，那么 parseInt() 会返回 NaN。 || &amp;&amp; | &amp;: || 如果前面为false，返回后面的值；如果前面为true，返回前面的值。真前假后 &amp;&amp; 如果前面为false，返回前面的值；如果前面为true，返回后面的值。假前真后 | 位运算符：|, 两个位只要有一个为1，那么结果都为1。否则就为0 &amp; 位运算符：&amp;，两个数值的个位分别相与，同时为1才得1，只要一个为0就为0。 回文数12345var isPalindrome = function(x) &#123; var s = x.toString(); var t = s.split('').reverse().join(''); return s == t&#125;; 知识点： Number to String: 变量toString()或者String(变量) 实现strStr()1234567var strStr = function(haystack, needle) &#123; if(!needle)&#123; return 0; &#125; return haystack.indexOf(needle)&#125;; 知识点：indexOf(): 返回调用 String 对象中第一次出现的指定值的索引。 语法：str.indexOf(searchValue[, fromIndex])。fromIndex代表开始查找的位置。 indexOf 方法区分大小写。 报数123456789101112131415161718var countAndSay = function(n) &#123; var result = '1'; for(var i=1; i&lt;n; i++)&#123; var count = 1; var str = ''; for(var j=0; j&lt;result.length; j++)&#123; if(result[j] == result[j+1])&#123; count++; &#125;else&#123; str += count + result[j]; count = 1; &#125; &#125; result = str; &#125; return result&#125;; 最长公共前缀1234567891011121314151617181920212223242526if(strs.length == 0)&#123; return ""&#125; var first = strs[0];var com = [];var index = 0;for(var i=0; i&lt;first.length; i++)&#123; var temp = first[i]; var count = 1; for(var j=1; j&lt;strs.length; j++)&#123; if( strs[j][i]==temp )&#123; count++; &#125; &#125; if(count == strs.length &amp;&amp; index++ == i)&#123; com.push(temp); &#125;else&#123; break &#125;&#125;if( com.length == 0 )&#123; return ""&#125;else&#123; return com.join('')&#125; 删除链表的倒数第N个节点123456789101112131415161718var removeNthFromEnd = function(head, n) &#123; var first = head, second = head; while(n&gt;0)&#123; n--; first = first.next; &#125; if(!first) return head.next; while(first.next)&#123; first = first.next; second = second.next; &#125; second.next = second.next.next; return head&#125;; 反转链表12345678910111213141516171819202122var reverseList = function (head) &#123; // 闭包 if (head === undefined || head === null) return null var originalHead = head var reverseHead var reverse = function (head) &#123; if (head.next === null) &#123; reverseHead = head return head &#125; else &#123; var node = reverse(head.next) node.next = head if (originalHead === head) &#123; head.next = null return reverseHead &#125; else &#123; return head &#125; &#125; &#125; return reverse(head)&#125;; 合并两个有序链表123456789101112var mergeTwoLists = function(l1, l2) &#123; if ( l1 == null) return l2; if ( l2 == null) return l1; console.log(l1 ,l1.val) if( l1.val &lt; l2.val)&#123; l1.next = mergeTwoLists(l1.next,l2); return l1 &#125;else &#123; l2.next = mergeTwoLists(l1,l2.next); return l2 &#125;&#125;; 回文链表123456789101112var isPalindrome = function(head) &#123; var str = ''; var reverseStr = ''; while(head)&#123; str += head.val; reverseStr = head.val + reverseStr; head = head.next; &#125; return str == reverseStr;&#125;; 环形链表1234567891011121314var hasCycle = function(head) &#123; if(!head || !head.next) return false; let p1 = head, p2 = head.next; while(p2 &amp;&amp; p2.next)&#123; if(p1 == p2) return true; p1 = p1.next; p2 = p2.next.next; &#125; return false&#125;; 二叉树的最大深度12345678910var maxDepth = function(root) &#123; if(root == null)&#123; return 0; &#125;else&#123; var rightDepth = maxDepth(root.right), leftDepth = maxDepth(root.left); var childDepth = rightDepth&gt;leftDepth ? rightDepth : leftDepth; return 1+childDepth; &#125;&#125;;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js--SSR]]></title>
    <url>%2F2019%2F06%2F04%2FVue-SSR%2F</url>
    <content type="text"><![CDATA[Vue-SSR什么是服务器端渲染（SSR）Vue.js 是构建客户端应用程序的框架。 SSR: 将组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记“激活”为客户端上完全可交互的应用程序。 服务器渲染的 Vue.js 应用程序也可以被认为是”同构”或”通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行。 为什么使用服务器端渲染(SSR) 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。 更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6--class基本语法]]></title>
    <url>%2F2019%2F06%2F02%2FClass%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ES6笔记–Class的基本语法简介JavaScript 语言中，生成实例对象的传统方法是通过构造函数。 12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2); 上面的代码用 ES6 的class改写，就是下面这样。 12345678910class Point &#123; constructor(x, y)&#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 上面代码定义了一个“类”，里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5 的构造函数Point，对应 ES6 的Point类的构造方法。 Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 ES6 的类，完全可以看作构造函数的另一种写法。 123456class Point &#123; // ...&#125;typeof Point // "function"Point === Point.prototype.constructor // true 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。 12345678class Bar &#123; doStuff()&#123; console.log('stuff'); &#125;&#125;var b = new Bar();b.doStuff() // "stuff" 构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。 123456789101112131415161718192021class Point &#123; constructor()&#123; //... &#125; toString() &#123; // ... &#125; toValue() &#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;,&#125;; 在类的实例上面调用方法，其实就是调用原型上的方法。 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。 Object.assign方法可以很方便地一次向类添加多个方法。 12345678910class Point &#123; constructor()&#123; // ... &#125;&#125;Object.assign(Point.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;) prototype对象的constructor属性，直接指向“类”的本身，这与 ES5 的行为是一致的。 1Point.prototype.constructor == Point // true 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。这一点与 ES5 的行为不一致。 constructor 方法constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 1234567class Point &#123;&#125;// 等同于class Point &#123; constructor() &#123;&#125;&#125; constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo// false 类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别。 类的实例生成类的实例的写法，与 ES5 完全一样，也是使用new命令。 123456789class Point &#123; // ...&#125;// 报错var point = Point(2, 3);// 正确var point = new Point(2, 3); 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上） 12345678910111213141516171819202122//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty('x') // truepoint.hasOwnProperty('y') // truepoint.hasOwnProperty('toString') // falsepoint.__proto__.hasOwnProperty('toString') // true 与 ES5 一样，类的所有实例共享一个原型对象。 12345var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__ === p2.__proto__//true 这也意味着，可以通过实例的proto属性为“类”添加方法。 注意： __proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。 取值函数（getter）和存值函数（setter）与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// 'getter' 属性表达式类的属性名，可以采用表达式。 1234567891011let methodName = 'getArea';class Square &#123; constructor(length) &#123; // ... &#125; [methodName]() &#123; // ... &#125;&#125; Class 表达式类也可以使用表达式的形式定义 12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是Me，但是Me只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用MyClass引用。 123let inst = new MyClass();inst.getClassName() // MeMe.name // ReferenceError: Me is not defined 采用 Class 表达式，可以写出立即执行的 Class。 1234567891011let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;('张三');person.sayName(); // "张三" 注意点严格模式类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。 不存在提升类不存在变量提升（hoist），这一点与 ES5 完全不同。 12new Foo(); // ReferenceErrorclass Foo &#123;&#125; 上面代码中，Foo类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6--async函数]]></title>
    <url>%2F2019%2F06%2F01%2FES6%E7%AC%94%E8%AE%B0--async%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[ES6笔记–async函数含义ES2017 标准引入了 async 函数，使得异步操作变得更加方便。 Generator 函数，依次读取两个文件。 1234567891011121314151617const fs = require('fs');const readFile = function (fileName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) return reject(error); resolve(data); &#125;); &#125;);&#125;;const gen = function* () &#123; const f1 = yield readFile('/etc/fstab'); const f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 上面代码的函数gen可以写成async函数 123456const asyncReadFile = async function () &#123; const f1 = await readFile('/etc/fstab'); const f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await async函数对 Generator 函数的改进，体现在以下四点。 内置执行器Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 asyncReadFile()会自动执行，输出最后结果。 这不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。 更好的语义async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 更广的适用性co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象。但是await命令后面，可以是 Promise 对象和原始类型的值（会自动转成立即 resolved 的 Promise 对象） 返回值是 Promiseasync函数的返回值是 Promise 对象， Generator 函数的返回值是 Iterator 对象。 进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象；而await命令就是内部then命令的语法糖。 基本用法async函数返回一个 Promise 对象，可以使用then方法添加回调函数。 当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 123456789async function getStockPriceByName(name)&#123; const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then(function (result) &#123; console.log(result);&#125;); 上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。 下面是另一个例子，指定多少毫秒后输出一个值。 123456789101112function timeout(ms)&#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms)&#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 50); 上面代码指定 50 毫秒以后，输出hello world。 async函数返回的是 Promise 对象，可以作为await命令的参数。 123456789101112async function timeout(ms) &#123; await new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 50); async 函数有多种使用形式。 123456789101112131415161718192021222324252627// 函数声明async function foo() &#123;&#125;// 函数表达式const foo = async function () &#123;&#125;;// 对象的方法let obj = &#123; async foo() &#123;&#125; &#125;;obj.foo().then(...)// Class 的方法class Storage &#123; constructor() &#123; this.cachePromise = caches.open('avatars'); &#125; async getAvatar(name) &#123; const cache = await this.cachePromise; return cache.match(`/avatars/$&#123;name&#125;.jpg`); &#125;&#125;const storage = new Storage();storage.getAvatar('jake').then(…);// 箭头函数const foo = async () =&gt; &#123;&#125;; 语法返回 Promise 对象async函数返回一个 Promise 对象。 async函数内部return语句返回的值，会成为then方法回调函数的参数。 1234567async function f()&#123; return 'hello world'&#125;f().then(v =&gt; &#123; console.log(v)&#125;) 函数f内部return命令返回的值，会被then方法回调函数接收到。 async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。 123456789async function f() &#123; throw new Error('出错了');&#125;f().then( v =&gt; console.log(v), e =&gt; console.log(e))// Error: 出错了 Promise 对象的状态变化async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。 也就是说，只有async函数内部的异步操作执行完，才会执行外部的then方法指定的回调函数。 123456789async function getTitle(url)&#123; let res = await fetch(url); let html = await response.text(); return html.match(/&lt;titile&gt;([\s\S]+)&lt;\/title&gt;/);&#125;getTitle('https://tc39.github.io/ecma262/').then(console.log)// "ECMAScript 2017 Language Specification" 函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的console.log。 await命令正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。 12345678async function f() &#123; // 等同于 // return 123; return await 123;&#125;f().then(v =&gt; console.log(v))// 123 await命令的参数是数值123，这时等同于return 123 另一种情况是，await命令后面是一个thenable对象（即定义then方法的对象），那么await会将其等同于 Promise 对象。 1234567891011121314151617class Sleep &#123; constructor(timeout) &#123; this.timeout = timeout; &#125; then(resolve, reject) &#123; const startTime = Date.now(); setTimeout( () =&gt; resolve(Date.now() - startTime), this.timeout ); &#125;&#125;(async () =&gt; &#123; const actualTime = await new Sleep(1000); console.log(actualTime);&#125;)(); 上面代码中，await命令后面是一个Sleep对象的实例。这个实例不是 Promise 对象，但是因为定义了then方法，await会将其视为Promise处理。 await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。 1234567async function f()&#123; await Promise.reject('出错了');&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e)) 上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。 任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。 1234async function f() &#123; await Promise.reject('出错了'); await Promise.resolve('hello world'); // 不会执行&#125; 有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。时可以将第一个await放在try…catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。 1234567891011async function f() &#123; try &#123; await Promise.reject('出错了'); &#125; catch(e) &#123; &#125; return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v))// hello world 另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。 12345678910async function f() &#123; await Promise.reject('出错了') .catch(e =&gt; console.log(e)); return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v))// 出错了// hello world 错误处理如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。 1234567891011async function f() &#123; await new Promise(function(resolve, reject)&#123; throw new Error('出错了'); &#125;)&#125;f().then(v =&gt; cnosole.log(v)).catch(e =&gt; console.log(e))// Error：出错了 防止出错的方法，也是将其放在try...catch代码块之中。 12345678910async function()&#123; try&#123; await new Promise(function(resolve, reject)&#123; throw new Error(&apos;出错了&apos;); &#125;) &#125;catch(e)&#123; &#125; return await(&apos;Hellow world&apos;)&#125; 如果有多个await命令，可以统一放在try…catch结构中。 123456789101112async function main() &#123; try &#123; const val1 = await firstStep(); const val2 = await secondStep(val1); const val3 = await thirdStep(val1, val2); console.log('Final: ', val3); &#125; catch (err) &#123; console.error(err); &#125;&#125; 下面try…catch结构，实现多次重复尝试。 123456789101112131415const superagent = require('superagent');const NUM_RETRIES = 3;async function test() &#123; let i; for (i = 0; i &lt; NUM_RETRIES; ++i) &#123; try &#123; await superagent.get('http://google.com/this-throws-an-error'); break; &#125; catch(err) &#123;&#125; &#125; console.log(i); // 3&#125;test(); 上面代码中，如果await操作成功，就会使用break语句退出循环；如果失败，会被catch语句捕捉，然后进入下一轮循环。 使用注意点第一，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。 12345678910111213141516async function myFunction() &#123; try &#123; await somethingThatReturnsAPromise(); &#125; catch (err) &#123; console.log(err); &#125;&#125;// 另一种写法async function myFunction() &#123; await somethingThatReturnsAPromise() .catch(function (err) &#123; console.log(err); &#125;);&#125; 第二，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。 12let foo = await getFoo();let bar = await getBar(); 上面代码中，只有getFoo完成以后，才会执行getBar；若他俩为两个独立的异步操作，可以让他俩同时触发。 12345678// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; 第三，await命令只能用在async函数之中，如果用在普通函数，就会报错。 第四，async 函数可以保留运行堆栈。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6--Generator函数]]></title>
    <url>%2F2019%2F06%2F01%2FES6%E7%AC%94%E8%AE%B0--Generator%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[ES6笔记–Generator函数简介Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-CLI]]></title>
    <url>%2F2019%2F05%2F16%2FVue-CLI%2F</url>
    <content type="text"><![CDATA[Vue-CLI基础Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统。 CLI可以通过 vue create 快速创建一个新项目的脚手架，或者直接通过 vue serve 构建新想法的原型。 CLI服务是一个开发环境依赖。 CLI 插件CLI 插件是向你的 Vue 项目提供可选功能的 npm 包，例如 Babel/TypeScript 转译、ESLint 集成、单元测试和 end-to-end 测试等。 快速原型开发使用 vue serve 和 vue build 命令对单个 *.vue 文件进行快速原型开发。 它会在当前目录自动推导入口文件——入口可以是 main.js、index.js、App.vue 或 app.vue 中的一个。你也可以显式地指定入口文件vue serve MyComponent.vue 创建一个项目使用vue create hello-world创建一个新项目。 插件插件可以修改 webpack 的内部配置，也可以向 vue-cli-service 注入命令。在项目创建的过程中，绝大部分列出的特性都是通过插件来实现的。 在现有项目中安装插件vue add @vue/eslint 开发HTML和静态资源index文件public/index.html 文件是一个会被 html-webpack-plugin 处理的模板。在构建过程中，资源链接会被自动注入。 插值 index 文件被用作模板，可以使用 lodash template 语法插入内容： &lt;%= VALUE %&gt; 用来做不转义插值； &lt;%- VALUE %&gt; 用来做 HTML 转义插值； &lt;% expression %&gt; 用来描述 JavaScript 流程控制。 所有的客户端环境变量也可以直接使用，例如： 1&lt;link rel="icon" href="&lt;%= BASE_URL %&gt;favicon.ico"&gt;]]></content>
      <categories>
        <category>vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-router]]></title>
    <url>%2F2019%2F05%2F16%2FVue-router%2F</url>
    <content type="text"><![CDATA[Vue-router基础Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。 123456789101112131415161718192021222324252627// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)// 1. 定义（路由组件）// 可以从其他文件 import 进来const Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;' &#125;const Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;' &#125;// 2. 定义路由// 每个路由应该映射一个组件。// 其中"component" 可以是通过 Vue.extend() 创建的组件构造器// 或者，只是一个组件配置对象。const routes = [ &#123;path: '/foo', component: Foo&#125;, &#123;path: '/bar', component: Bar&#125;];// 3. 创建router实例，然后传‘routes’配置const router = new VueRouter(&#123; routes &#125;)// 4. 创建和挂在根实例// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount('#app') 通过注入路由器，我们可以在任何组件内通过 this.$router 访问路由器，也可以通过 this.$route 访问当前路由。 动态路由匹配可以在 vue-router 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果： 12345678910const User = &#123; template: '&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125; &lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes: [ // 动态路径参数 &#123; path: '/user/:id', component: User &#125; ]&#125;) 可以在一个路由中设置多段“路径参数”，对应的值都会设置到 $route.params 中。 响应路由参数的变化当使用路由参数时，例如从 /user/foo 导航到 /user/bar，原来的组件实例会被复用。 同时，这也意味着组件的生命周期钩子不会再被调用。 捕获所有路由或 404 Not found 路由12345678&#123; // 会匹配所有路径 path: '*'&#125;&#123; // 会匹配以 `/user-` 开头的任意路径 path: '/user-*'&#125; 当使用一个通配符时，$route.params内会添加一个属性，叫做pathMatch；用于显示通配符匹配的那部分。 1234567// 路由&#123; path: '/user-*' &#125;this.$router.push('/user-admin')this.$router.params.pathMatch //'admin'// 路由 &#123; path: '*' &#125;this.$router.push('/non-existing')this.$router.params.pathMatch //'non-existing' 高级匹配模式vue-router 使用 path-to-regexp 作为路径匹配引擎。就是路由里面能用正则匹配。 匹配优先级有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。 嵌套路由实际生活中的应用界面，通常由多层嵌套的组件组合而成。URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如： 12345678/user/foo/profile /user/foo/posts+------------------+ +-----------------+| User | | User || +--------------+ | | +-------------+ || | Profile | | +------------&gt; | | Posts | || | | | | | | || +--------------+ | | +-------------+ |+------------------+ +-----------------+ 一个被渲染的组件同样可以嵌套&lt;router-view&gt;，如下： 123456789101112131415161718192021222324252627282930const User = &#123; template: ` &lt;div class="user"&gt; &lt;h2&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/h2&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; `&#125;const router = new VueRouter(&#123; routes: [ &#123; path: /user/:id, component: User, children: [ &#123; // 当 /user/:id/profile 匹配成功 // UserProfile会被渲染在 User 的 router-view path: 'profile', component: UserProfile &#125;,&#123; // 当 /user/:id/posts 匹配成功 // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中 path: 'posts', component: UserPosts &#125; ] &#125; ]&#125;) 注意：以/开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。 基于上面的配置，当你访问 /user/foo 时，User 的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个 空的 子路由： 1234567891011121314const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, children: [ &#123; path: '', component: UserHome &#125; ] &#125; ]&#125;); 编程式的导航除了使用 &lt;router-link&gt; 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。 router.push(location, onComplete?, onAbort?)在 Vue 实例内部，你可以通过 $router 访问路由实例。因此你可以调用 this.$router.push router.push会向 history 栈添加一个新的记录。当点击浏览器后退按钮时，则回到之前的URL。 点击 &lt;router-link :to=&quot;...&quot;&gt; 等同于调用 router.push(...)。push的参数可以是一个字符串路径，或者一个描述地址的对象。 1234567891011// 字符串router.push('home')// 对象router.push(&#123; path: 'home' &#125;)// 命名的路由router.push(&#123; name: 'user', params: &#123;userId: '123'&#125; &#125;)// 带查询参数，变成 /register?plan=provaterouter.push(&#123; path: 'register', query: &#123;plan: 'private'&#125; &#125;) 如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。 1234567const userId = '123'router.push(&#123;name: 'user', params: &#123;userId&#125;&#125;) // -&gt; /user/123router.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123// 这里的 params 不生效router.push(&#123; path: '/user', params: &#123;userId&#125; &#125;) // -&gt; /user onComplete: 在所有的异步钩子被解析之后调用。 onAbort: 导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由调用 router.replace(location, onComplete?, onAbort?)与router.push不同的是，它不会像history添加新纪录，而是替换掉当前的history记录。 router.go(n)go的参数是一个整数，意思是在history记录中向前或者后退多少步，类似window.history.go(n) 123456789101112// 在浏览器记录中前进一步，等同于 history.forward()router.go(1)// 后退一步记录，等同于 history.back()router.go(-1)// 前进 3 步记录router.go(3)// 如果 history 记录不够用，那就默默地失败呗router.go(-100)router.go(100) 命名路由有时候，通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称。 123456789const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:userId', name: 'user', component: User &#125; ]&#125;) 要连接到一个命名路由，可以给router-link的to属性传一个对象。 1&lt;router-link :to="&#123;name: 'user', params: &#123; userId:123 &#125;&#125;"&gt;User&lt;/router-link&gt; 这和调用router.push()是一回事： 1router.push(&#123;name: 'user', params: &#123;userId: 123&#125;&#125;) 命名视图有时候的需求是同时展示多个视图，而不是嵌套显示。例如创建一个布局，有 sidebar (侧导航) 和 main (主内容) 两个视图，就可以用命名视图。 在页面中可以拥有多个单独命名的视图，而不是只有一个单独的出口。 如果router-view没有设置名字，默认为default 123&lt;router-view class="view one"&gt;&lt;/router-view&gt;&lt;router-view class="view two" name="a"&gt;&lt;/router-view&gt;&lt;router-view class="view three" name="b"&gt;&lt;/router-view&gt; 一个视图使用一个组件渲染，所以对于同一个路由，多个视图就需要多个组件。确保正确使用 components 配置 (带上 s)： 123456789101112const router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; default: Foo, a: Bar, b: Baz &#125; &#125; ]&#125;); 嵌套命名视图我们也有可能使用命名视图创建嵌套视图的复杂布局。例如： 123456789/settings/emails /settings/profile+-----------------------------------+ +------------------------------+| UserSettings | | UserSettings || +-----+-------------------------+ | | +-----+--------------------+ || | Nav | UserEmailsSubscriptions | | +------------&gt; | | Nav | UserProfile | || | +-------------------------+ | | | +--------------------+ || | | | | | | | UserProfilePreview | || +-----+-------------------------+ | | +-----+--------------------+ |+-----------------------------------+ +------------------------------+ UserSettings组件的&lt;template&gt;部分应该是类似于下面这段代码： 1234567&lt;!-- UserSettings.vue --&gt;&lt;div&gt; &lt;h1&gt;User Settings&lt;/h1&gt; &lt;NavBar/&gt; &lt;router-view/&gt; &lt;router-view name="helper"&gt;&lt;/div&gt; 然后用下面这个路由配置完成该布局 12345678910111213141516&#123; path: '/settings', component: UserSettings, children: [ &#123; path: 'emails', component: UserEmailsSubscriptions &#125;,&#123; path: 'profile', components: &#123; default: UserProfile, helper: UserProfilePreview &#125; &#125; ]&#125; 重定向和别名重命名重定向也是通过 routes 配置来完成，下面例子是从 /a 重定向到 /b： 12345const router = new VueRouter(&#123; routes: [ &#123; path: '/a', redirect: '/b' &#125; ]&#125;) 重定向的目标也可以是一个命名的路由 12345const router = new VueRouter(&#123; routes: [ &#123; path: '/a', redirect: &#123;name: 'foo'&#125; &#125; ]&#125;) 也可以是一个方法，动态返回重定向目标 12345678consr router = new VueRouter(&#123; routes: [ path: '/a', redirect: to =&gt; &#123; // 方法接收 目标路由 作为参数 // return 重定向的 字符串路径/路径对象 &#125; ]&#125;) 别名/a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。 12345const router = new VueRouter(&#123; routes: [ &#123; path: '/a', component: A, alias: '/b' &#125; ]&#125;) “别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。 路由组件传参在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。 使用 props 将组件和路由解耦： 123456789101112const User = &#123; template: '&lt;div&gt;User &#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User &#125; ]&#125;) 通过props解耦 1234567891011121314151617const User = &#123; props: ['id'], template: '&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, props: true &#125;, // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项： &#123; path: '/user/:id', components: &#123; default: User, sidebar: Sidebar &#125;, props: &#123; default: true, sidebar: false &#125; &#125; ]&#125;) 布尔模式如果 props 被设置为 true，route.params 将会被设置为组件属性。 对象模式如果 props 是一个对象，它会被按原样设置为组件属性。当 props 是静态的时候有用。 12345const router = new VueRouter(&#123; routes: [ &#123; path: '/promotion/from-newsletter', component: Promotion, props: &#123; newsletterPopup: false &#125; &#125; ]&#125;) 函数模式你可以创建一个函数返回 props。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。 12345const router = new VueRouter(&#123; routes: [ &#123; path: '/search', component: SearchUser, props: (route) =&gt; (&#123; query: route.query.q &#125;) &#125; ]&#125;) HTML5 History 模式vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。 如果不想要很丑的 hash，可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。 1234const router = new VueRouter(&#123; mode: 'history', routes: [...]&#125;) 不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 http://oursite.com/user/id 就会返回 404，这就不好看了。 所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。 后端配置原生node.js 1234567891011121314151617const http = require('http');const fs = require('fs');const httpPort = 80;http.createServer( (req, res) =&gt; &#123; fs.readFile('index.html', 'utf-8', (err, content)=&gt;&#123; if(err) console.log('We cannot open "index.htm" file.'); res.writeHead(200, &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;) res.end(content) &#125;)&#125; ).listen(httpPort, () =&gt; &#123; console.log('Server listening on: http://localhost:%s', httpPort)&#125;) 警告这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。 12345678const router = new VueRouter(&#123; routes: [ &#123; path: '*', component: NotFoundComponent &#125; ]&#125;); 导航守卫导航：表示路由正在发生改变。 vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。 全局前置守卫使用 router.beforeEach 注册一个全局前置守卫： 12345const router = new VueRouter(&#123; ... &#125;);router.beforeEach((to, from, next) =&gt; &#123; // ...&#125;) 当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于等待中。 每个守卫方法接收三个参数： to: Route：即将要进入的目标路由 from: Route: 当前导航正要离开的路由 next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。 next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。 next(&#39;/&#39;) 或者 next({ path: &#39;/&#39; }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: ‘home’ 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。 next(error): 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。 全局解析守卫可以用 router.beforeResolve 注册一个全局解析守卫。调用的时间：在导航被确认之前，在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。 全局后置钩子全局后置钩子不会接受 next 函数也不会改变导航本身。 123router.afterEach((to, from) =&gt; &#123; //...&#125;) 路由独享的守卫可以在路由配置上直接定义 beforeEnter 守卫： 1234567891011const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ]&#125;) 组件内的守卫可以在组件内直接定义以下路由导航守卫： beforeRouteEnter beforeRouterUpdate beforeRouterLeave 123456789101112131415161718const Foo = &#123; template: '...', beforeRouterEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 &#125;, beforeRouterUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;, beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` &#125;&#125; beforeRouteEnter不能访问this。因为守卫在导航确认前被调用。 可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。 12345beforeRouteEnter (to, from, next) &#123; next(vm =&gt; &#123; // 通过 `vm` 访问组件实例 &#125;)&#125; 注意：beforeRouteEnter 是支持给 next 传递回调的唯一守卫。 离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。 12345678beforeRouteLeave (to, from , next) &#123; const answer = window.confirm('Do you really want to leave? you have unsaved changes!') if (answer) &#123; next() &#125; else &#123; next(false) &#125;&#125; 完整的导航解析流程 导航被触发。 在失活的组件里调用离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve。 导航被确认。 调用afterEach钩子 触发DOM更新 用创建好的实例调用beforeRouterEnter守卫中传给next的回调函数 路由元信息定义路由的时候可以配置 meta 字段。 一个路由匹配到的所有路由记录会暴露为 $route 对象 (还有在导航守卫中的路由对象) 的 $route.matched 数组。 12345678910111213141516router.beforeEach((to, from, next) =&gt; &#123; if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123; // this route requires auth, check if logged in // if not, redirect to login page. if (!auth.loggedIn()) &#123; next(&#123; path: '/login', query: &#123; redirect: to.fullPath &#125; &#125;) &#125; else &#123; next() &#125; &#125; else &#123; next() // 确保一定要调用 next() &#125;&#125;) 过渡动效&lt;router-view&gt; 是基本的动态组件，可以用 &lt;transition&gt; 组件给它添加一些过渡效果： 123&lt;transition&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; 单个路由的过渡上面的用法会给所有路由设置一样的过渡效果，如果让每个路由组件有各自的过渡效果，可以在各路由组件内使用 &lt;transition&gt; 并设置不同的 name。 1234567891011121314const Foo = &#123; template: ` &lt;transition name="slide"&gt; &lt;div class="foo"&gt;...&lt;/div&gt;1 &lt;/transition&gt; `&#125;const Bar = &#123; template: ` &lt;transition name="fade"&gt; &lt;div class="bar"&gt;...&lt;/div&gt; &lt;/transition&gt;` 基于路由的动态过渡可以基于当前路由和目标路由的变化关系，动态设置过渡效果 123&lt;transition :name="transitionName"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; 123456789// 接着在父组件内// watch $route 决定使用哪种过渡watch: &#123; '$route' (to, from) &#123; const toDepth = to.path.split('/').length const fromDepth = from.path.split('/').length this.transitionName = toDepth &lt; fromDepth ? 'slide-right' : 'slide-left' &#125;&#125; 数据获取有时候，进入某个路由后，需要从服务器获取数据。可以通过两种方式来实现： 导航完成之后获取：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示。 导航完成之前获取：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。 在导航完成之后获取数据使用这种方式，会马上导航和渲染组件，然后在组件的created钩子中获取数据。 12345678910111213141516&lt;template&gt; &lt;div class="post"&gt; &lt;div class="loading" v-if="loading"&gt; loading... &lt;/div&gt; &lt;div class="error" v-if="error"&gt; &#123;&#123; error &#125;&#125; &lt;/div&gt; &lt;div v-if="post" class="content"&gt; &lt;h2&gt;&#123;&#123; post.title &#125;&#125;&lt;/h2&gt; &lt;p&gt;&#123;&#123; post.body &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930export default &#123; data () &#123; return &#123; loading: false, post: null, error: null &#125; &#125;, created () &#123; this.fetchData() &#125;, watch: &#123; '$route': 'fetchData' &#125;, methods: &#123; fetchData () &#123; this.error = this.post = null this.loading = true // replace getPost with your data fetching util / API wrapper getPost(this.$route.params.id, (err, post) =&gt; &#123; this.loading = false if (err) &#123; this.error = err.toString() &#125; else &#123; this.post = post &#125; &#125;) &#125; &#125;&#125; 在导航完成前获取数据12345678910111213141516171819202122232425262728293031export default &#123; data () &#123; return &#123; post: null, error: null &#125; &#125;, beforeRouteEnter (to, from, next) &#123; getPost(to.params.id, (err, post) =&gt; &#123; next(vm =&gt; vm.setData(err, post)) &#125;) &#125;, // 路由改变前，组件就已经渲染完了 // 逻辑稍稍不同 beforeRouteUpdate (to, from, next) &#123; this.post = null getPost(to.params.id, (err, post) =&gt; &#123; this.setData(err, post) next() &#125;) &#125;, methods: &#123; setData (err, post) &#123; if (err) &#123; this.error = err.toString() &#125; else &#123; this.post = post &#125; &#125; &#125;&#125; 滚动行为路由懒加载1234567&#123; path: '/', component: resolve =&gt; require(['../pages/index.vue'], resolve), meta: &#123; title: 'home' &#125;&#125;]]></content>
      <categories>
        <category>vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa--笔记]]></title>
    <url>%2F2019%2F05%2F16%2Fkoa--%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[koa–文档笔记应用程序Koa 应用程序是一个包含一组中间件函数的对象，它是按照类似堆栈的方式组织和执行的。 12345678const Koa = require('koa');const app = new Koa();app.use(async ctx =&gt; &#123; ctx.body = 'Hellow World'&#125;);app.listen(3000); 级联Koa 中间件以更传统的方式级联。使用async功能，可以实现”真实”的中间价。Koa 调用“下游”，然后控制流回“上游”。 123456789101112131415161718192021222324252627const Koa = require('koa');const app = new Koa();// loggerapp.use(async (ctx, next) =&gt; &#123; await next(); const rt = ctx.response.get('X-Response-Time'); console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;rt&#125;`);&#125;);// x-response-timeapp.use(async (ctx, next) =&gt; &#123; const start = Date.now(); await next(); const ms = Date.now() - start; ctx.set('X-Response-Time', `$&#123;ms&#125;ms`);&#125;);// responseapp.use(async ctx =&gt; &#123; ctx.body = 'Hello World';&#125;);app.listen(3000); app.listen(…)Koa应用程序不是HTTP服务器的1对1呈现。可以将多个Koa 应用程序安装在一起以形成具有单个HTTP服务器的更大应用程序。 下面是一个无作用的Koa程序被绑定到3000端口 123const Koa = require('koa');const app = new Koa();app.listen(3000); 这里的 app.listen(…) 方法只是以下方法的语法糖: 1234const http = require('http');const Koa = require('koa');const app = new Koa();http.createServer(app.callback()).listen(3000); 所以可以将同一个应用程序同时作为 HTTP 和 HTTPS 或多个地址： 123456const http = require(&apos;http&apos;);const https = require(&apos;https&apos;);const Koa = require(&apos;koa&apos;);const app = new Koa();http.createServer(app.callback()).listen(3000);https.createServer(app.callback()).listen(3001); app.callback()用于 http.createServer() 方法的回调函数来处理请求。 app.use(function)将给定的中间件方法添加到此应用程序 app.keys设置签名的 Cookie 密钥。 app.contextapp.context 是 ctx 的原型。可以通过编辑 app.context 为 ctx 添加其他属性。这可以实现变量和方法在整个应用程序中的使用。 例如，从ctx添加对数据库的引用。 12345app.context.db = db();app.use(async ctx =&gt; &#123; console.log(ctx.db)&#125;) 错误处理要执行自定义错误处理逻辑，可以添加一个 “error” 事件侦听器： 123app.on('error', err =&gt; &#123; log.error('server error', err);&#125;) 如果 req/res 期间出现错误，并且 _无法_ 响应客户端，Context实例仍然被传递： 123app.on('error', (err, ctx) =&gt; &#123; log.error('server error', err, ctx)&#125;); 上下文(Context)Koa Context 将 node 的 request 和 response 对象封装到单个对象中。并强制中间件重新实现此通用功能。 12345app.use(async ctx =&gt; &#123; ctx; // 这是Context ctx.request; // 这是 koa Request ctx.response; // 这是 koa Response&#125;) 为方便起见许多上下文的访问器和方法直接委托给它们的 ctx.request或 ctx.response ，不然的话它们是相同的。 例如 ctx.type 和 ctx.length 委托给 response 对象，ctx.path 和 ctx.method 委托给 request。 ctx.reqNode 的 request 对象.注意：是Node的，不是koa的 ctx.resNode 的 response 对象。绕过Koa的response处理是不被支持的，因避免使用以下node属性： res.stateCode res.writeHead() res.write() res.end() ctx.requestkoa 的 Request 对象. ctx.responsekoa 的 Response 对象. ctx.state推荐的命名空间，用于通过中间件和你的前端视图传递信息。 1ctx.state.user = await User.find(id); ctx.app.emitctx.app.emit 发出一个类型由第一个参数定义的事件。 ctx.cookies.get(name, [options])获取 cookie ctx.cookies.set(name, value, [options])设置名为name，值为value的cookie。 ctx.throw([status], [msg], [properties])默认抛出500的错误。 123ctx.throw(400);ctx.throw(400, 'name required');ctx.throw(400, 'name required', &#123; user: user &#125;); ctx.assert(value, [status], [msg], [properties])ctx.respond为了绕过 Koa 的内置 response 处理，你可以显式设置 ctx.respond = false;。注意，Koa _不_ 支持使用此功能。这可能会破坏 Koa 中间件和 Koa 本身的预期功能。]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB相关知识]]></title>
    <url>%2F2019%2F04%2F26%2FWEB%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[WEB相关知识TCPTCP: Transmission Control Protocol, 传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。 通讯双方建立一次tcp连接，也需要经过三个步骤（握手）。 客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认。 服务端收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态。 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 SYN：synchronous 建立联机 ACK：acknowledgement 确认 SYN_SENT: 请求连接 SYN_RECV：服务端被动打开后，接受到了客户端的SYN并且发送了ACK时的状态。再进一步接收到客户端的ACK就进入ESTABLISHED状态 注意：tcp在握手过程中并不携带数据，而是在三次握手完成之后，才会进行数据传输。 至于它的应用场景，其实是根据它本身的特点而定的，比如对网络通讯质量有要求，需要保证数据准确性时，就需要用到TCP协议了，如HTTP、ftp等文件传输协议、或一些邮件传输协议（SMTP、pop等） UDPUDP：User Datagram Protocol 用户数据报协议 相比于TCP的面向连接需要反复确认的繁琐步骤，UDP是一种性格特立独行且主观性超强的非面向连接的协议，使用udp协议经常通信并不需要建立连接，它只是负责把数据尽可能快的发送出去，简单粗暴，并且不可靠，而在接收端，UDP把每个消息断放入队列中，接收端程序从队列中读取数据。 虽然UDP不可靠，但是它的传输速度快，效率高，在一些对数据准确性要求不高的场景，UDP就变得很有用了，比如qq语音、qq视频。 套接字socketTCP或UDP都是一种协议，也就是计算机网络通信中在传输层的一种协议，简单地说，就是一种约定，就像合作双方的合同一样，然后合同是死的，只有履行合同才是实质性的行动，因此无论是TCP还是UDP要产生作用，都需要有实际的行为去执行才能体现协议的作用。 socket：也叫套接字，是一组实现TCP/UDP通信的接口API，也就是无论TCP还是UDP，通过对socket的编程，都可以实现TCP/UCP通信，作为一个通信链的句柄，它包含网络通信必备的5种信息： 连接使用的协议 本地主机的IP地址 本地进程的协议端口 远地主机的IP地址 远地进程的协议端口 socket包含了通信本方和对方的ip和端口以及连接使用的协议（TCP/UDP）。通信双方中的一方（暂称：客户端）通过scoket（嵌套字）对另一方（暂称：服务端）发起连接请求，服务端在网络上监听请求，当收到客户端发来的请求之后，根据socket里携带的信息，定位到客户端，就相应请求，把socket描述发给客户端，双方确认之后连接就建立了。 套接字之间连接过程有三个步骤： 服务器监听：服务器实时监控网络状态等待客户端发来的连接请求。 客户端请求：客户端根据远程主机服务器的IP地址和协议向其发起连接请求。 连接确认：服务端收到套接字的连接请求之后，就响应请求，把服务端套接字描述发给客户端，客户端收到后一旦确认，则双方建立连接，进行数据交互。 socket在即时通讯（qq等各种聊天软件）等应用上应用广泛。 HTTP协议HTTP协议：Hypertext Transfer Protocol 也叫超文本传送协议，它是一种基于TCP/IP协议栈、在表示层和应用层上的协议（TCP在传输层的协议），通俗一点说就是： TCP/IP是位于传输层上的一种协议，用于在网络上传输数据。 HTTP协议是应用层协议，基于TCP协议，用于包装数据，程序使用它包装数据，可以简单高效的处理通信中数据的传输和识别处理 而在现在应用非常广泛的HTTP连接则是建立在HTTP协议上的、处于应用层中的一种具体应用。 上面说到socket连接一旦建立就保持连接状态，而HTTP连接则不一样，它基于tcp协议的短连接，也就是客户端发起请求，服务器响应请求之后，连接就会自动断开，不会一直保持。 URL前面讲了tcp、udp、http…等等都是为了讲一个具体问题而做的知识点铺垫，那就是：我们开发的web应用中请求的发起和响应，是一个怎样的底层原理。 web应用绝大部分都是通过HTTP来进行请求的，而URL则是HTTP用来做连接建立和传输数据的一种具体实现。 URL：Uniform Resource Locator 统一资源定位符。说白了就是网络上用来标识具体资源的一个地址，包含了用户查找该资源的信息，HTTP使用它来传输数据和建立连接。 一个URL有以下组成部分： 协议 服务器地址(域名或IP+端口) 路径 文件名 比如 https://www.baidu.com/index.html https://是一种协议，当然，HTTP也是，ftp也是… www.baidu.com是服务器地址，通过ping命令得到百度的ip 14.215.177.39，那么我们可以用http://14.215.177.39打开百度 index.html包含了路径和文件名，当天通常index.html是可以省略的，所以打开百度时，并没有看到这个 DNSDNS：Domain Name Server，域名服务器。 是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。 DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。 在平时我们进行开发时，后端提供的接口地址通常是有IP地址加上端口号（8080什么鬼的）组成的，但是当我们把网站发布出去时，通常都需要把IP改成用域名。 因此，当用户在浏览器输入https://www.baidu.com回车时，它经历了以下步骤： 浏览器根据地址去本身缓存中查找dns解析记录，如果有，则直接返回IP地址，否则浏览器会查找操作系统中（host文件）是否有该域名的dns解析记录，如果有则返回。 如果浏览器缓存和操作系统hosts中均无dns解析记录，或者已经过期，此时就会向域名服务器发起请求来解析这个域名。 请求会先到LDNS（本地域名服务器），让它来尝试解析这个域名，如果LDNS也解析不了，则直接到根域名解析器请求解析 根域名服务器给LDNS返回一个所查询的主域名服务器（gTLDServer）地址。 此时LDNS再向上一步返回的gTLD服务器发起解析请求。 gTLD服务器接收到解析请求后查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是你注册的域名服务器（比如阿里dns、腾讯dns等） Name Server域名服务器会查询存储的域名和IP的映射关系表，正常情况下都根据域名得到目标IP记录，连同一个TTL值返回给DNS Server域名服务器 返回该域名对应的IP和TTL值，Local DNS Server会缓存这个域名和IP的对应关系，缓存的时间由TTL值控制。 把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。 HTTP请求发起和响应在一个web程序开发中，一般都有前端和后端之分，前端负责向后端请求数据和展示页面，后端负责接收请求和做出响应发回给前端，他们之间的协作的桥梁是什么呢？是API 从用户输入URL，到浏览器呈现给用户页面，经历了什么过程？ 用户输入URL，浏览器获取到URL 浏览器(应用层)进行DNS解析(如果输入的是IP地址，此步骤省略) 根据解析出的IP地址+端口，浏览器(应用层)发起HTTP请求，请求中携带请求头(header)、请求体(body) 请求到达传输层，tcp协议为传输报文提供可靠的字节流传输服务，它通过三次握手等手段来保证传输过程中的安全可靠。通过将大块数据分割成一个个报文段的方式传送大量数据 到网络层，网络层通过ARP寻址得到接收方的Mac地址，IP协议把在传输层被分割的一个个数据包发给传送接收方。 数据到达数据链路层，请求阶段完成。 接收方在数据链路层收到数据包之后，层层传递到应用层，接收方应用程序就获得请求报文。 接收方收到发送方的HTTP请求之后，进行请求文件资源（如HTML页面）的寻找并响应报文。 发送方收到响应报文之后，如果报文中的状态码表示请求成功，则接受返回的资源，进行页面渲染。 header包含： 请求的方法（post、get、put） 协议（http、https、ftp、smtp） 目标url（具体的请求路径以及文件名） 一些必要信息（缓存、cookie之类） body包含： 请求的内容 页面的渲染当一个请求的发起和响应都完成之后，浏览器就会收到响应内容，但浏览器收到的是一串串的代码或URL链接，怎么把这些代码转换成用户可以看得懂的界面呈现出来，就是浏览器的工作了。 浏览器通过HTMLParser根据深度遍历的原则把HTML解析成DOM Tree。 将CSS解析成CSS Rule Tree(CSSOM Tree)。 根据DOM树和CSSOM树来构造render Tree. layout：根据得到的render tree来计算所有节点在屏幕的位置。 paint：遍历render树，并调用硬件图形API来绘制每个节点。 前端性能优化为了找到可优化的点，在此对页面渲染过程中几个关键步骤进行说明 HTML解析HTML解析是浏览器的HTML解析器把HTML解析成dom tree，在解析过程中，浏览器根据HTML文件的结构从上到下解析html，HTML元素是以深度优先的方式解析，而script、link、style等标签会使解析过程产生阻塞，阻塞的情况有： 外部样式会阻塞内部脚本的执行。 外部样式和外部脚本并行加载，但外部样式会阻塞外部脚本执行。 如果外部脚本async属性，则外部脚本的加载和执行不受外部样式的影响。 如果link标签是动态创建，不管有无async属性，都不会阻塞外部脚本的加载与执行。 CSS解析CSS Parser作用就是将很多个CSS文件中的样式合并解析出具有树形结构Style Rule，在对样式解析的过程中，默认CSS选择器是从右往左进行解析的。因为 右边的tree复杂度要比左边的低。 右边的tree公用样式重合度比左边低。 右边的tree从根开始的节点要比左边的少。 可能光看这几点没看出什么问题，但你要知道：浏览器中的css解析器负责css的解析，并为每个节点计算出样式，因此虽然css解析器要做的事情不多，但要每个节点都要进行遍历查找计算，计算量极大，因此解析的方式是决定其性能的关键点。 脚本执行浏览器解析HTML时，当遇到&lt;script&gt;标签就会立即解析脚本，同时阻塞解析文档直到脚本执行完毕（你可能问为什么要这样设计，明显啊，脚本的执行是改变css和dom，会造成render tree不停的重绘和重排的），而当&lt;script&gt;是引入外部js文件时，会阻塞到js文件下载完成并且执行完成为止（除非加了defer或者async属性）。脚本在解析过程中将对dom或css的操作解析出来加入到DOM Tree和cssom中。 性能优化对于css 优化选择器路径：健全的css选择器固然是能让开发者看起来更清晰，然后对于css的解析来说却是一个很大的性能问题，因此相比于.a .b .c{}，更推荐写.c{}。 压缩文件：尽可能压缩你的css文件大小，减少资源下载的负担。 选择器合并：把有共同的属性内容的一系列选择器组合到一起，能压缩空间和资源开销。 精准样式：尽可能减少不必要的属性设置，比如只要设置{padding-left: 10px},就要避免{padding: 0 0 0 10px}的写法。 雪碧图：在合理的地方把一些小图标合并到一张图中，这样所有的图片只需要一次请求，然后所有的图片只需要一次请求，然后通过定位的方式获取相应的图标，这样就能一个图标一次请求的资源浪费。 避免通配符：.a .b *{} 像这样的选择器，根据从右到左的解析顺序在解析过程中遇到通配符（*）回去遍历整个dom的，这样性能问题就大大的了。 少用Float：Float在渲染时计算量比较大，尽量减少使用。 0值去单位：对于为0的值，尽量不要加单位，增加兼容性。 对于HTML 避免在HTML中写入css代码。 使用Viewport加速页面的渲染。 使用语义化标签，减少css的代码，增加可读性和SEO。 减少标签的使用，dom解析是一个大量遍历的过程，减少无必要的标签，能降低遍历的次数。 避免src，href等的值为空。 减少dns查询的次数。 对于JavaScript 尽可能把script标签放到body之后，避免页面需要等待js执行完成之后dom才能继续执行，最大程度保证页面能够展示出来。 尽可能合并script代码。 css能干的事情，尽量不要用JavaScript来干。毕竟JavaScript的解析执行过于直接和粗暴，而css效率更高。 尽可能压缩的js文件，减少资源下载的负担。 尽可能避免在js中逐条操作dom样式，尽可能与定义好css样式，然后通过改变样式名来修改dom样式，这样集中式的操作能减少reflow或repaint的次数。 尽可能少的在js中创建dom，而是预先埋到HTML中用display:none来隐藏，在js中按需调用，减少js对dom的暴力操作。]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[summary]]></title>
    <url>%2F2019%2F04%2F11%2FJavascript%20Summary%2F</url>
    <content type="text"><![CDATA[Javascript Summary原始类型有哪几种？null 是对象吗？原始数据类型和复杂数据类型存储有什么区别？ null undefined number string bool symbol。 null不是对象，是基本类型。 原始数据类型存储在栈内存，存储的是值；复杂数据类型存储在堆内存，存储的是地址。把对象赋值给另外一个变量时，复制的是地址，指向同一块内存空间，当其中一个对象变化时，另一个对象也会变化。 typeof 是否正确判断类型? instanceof呢？ instanceof 的实现原理是什么？ typeof能够正确判断基本类型，除了typeof null为object.但是不能判断对象类型。typeof 函数可以输出function，其他都是object。 instanceof可以准确判断复杂类型，不能判断基础类型 instanceof是通过原型链判断的，A instanceof B，在A的原型链中层层查找，是否有原型等于B.prototype, 如果一直找到A的原型链的顶端（null），仍然不等于B.prototype，则返回false，否则返回true 12345678910111213//L instanceof Rfunction instance_of(L, R)&#123; var O = R.prototype; //取R的显示原型 var L = L.__proto__; //取L的隐示原型 while(true)&#123; if(L === null)&#123; return false; &#125; if(0 === L) return true; L = L._proto_; &#125;&#125; for of, for in, forEach, map的区别 for…of: 具有iterator接口，就可以用for..of循环遍历它的成员（属性值)。for…of循环可以使用的范围包括数组、Set和Map结构、某些类似数组的对象、Generator对象，字符串。对于普通的对象，for…of不能直接使用，会报错，必须部署了Iterator接口才能使用。for…of遍历数组返回值 for…in: 遍历对象自身的和继承的可枚举的属性，不能直接获取属性值。可以中断循环。 forEach：只能遍历数组，不能中断，没有返回值 map: 只能遍历数组，可以中断，返回的是修改后的数组 如何判断一个变量是不是数组？ 使用arr.isArray判断，如果返回true，说明是数组。 使用instanceof Array判断，如果返回true，说明是数组。 arr.constructor === Array Object.prototype.toString.call 为[object Array] 类数组和数组的区别 具有length属性，其他属性为非负整数。 不具有数组所具有的方法。 类数组是普通对象，数组是Array类型的对象。 常见的类数组：函数参数arguments，DOM对象列表（document.querySelectorAll得到的列表），jQuery对象（$(‘div’)) 类数组转成数组 123456//1Array.prototype.slice.call(arrayLike, start);//2[...arrayLike]//3Array.from(arrayLike) PS: 任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组。 Array.from方法用于将两类对象转换为真数组：类似数组的对象（array-like object）和可遍历（iterable）的对象。 == 和 === 有什么区别？===不需要进行类型转换，只有类型相同并且值相同时，才返回true。 ==类型不同时，首先需要进行类型转换。 判断[] == ![] 为true。首先！的优先级高于==；![]为false。当比较一方为boolean时，将boolean转化成number，所以将false转换成0；根据有一方为number，另一方也要转化成number，[]转为number为0，如果数组有一个数字，那么转成number就是这个数字，其他情况均为NaN。 ES6中的class和ES5的类有什么区别？ ES6 class内部所定义的方法都是不可枚举的。 ES6 class必须用new调用。 ES6 class不存在变量提升。 ES6 class默认即是严格模式。 ES6 class子类必须在在父类的构造函数中调用super()，这样才有this对象；ES5中类的继承关系是相反的，先有子类的this，然后用父类的方法应用在this上。 数组的哪些API会改变原数组改变数组的API有： splice/reverse/unshift/shift/push/pop/sort/fill使用固定值填充数组/copyWithin方法用于从数组的指定位置拷贝元素到数组的另一个指定位置中 不改变数组的API有： slice/filter/forEach/map/every/find/reduce/entries let/const/var的区别是什么？ let和const不会出现变量提升，var会。 let和const是块级作用域。 let和const不能重复声明。 let和const定义的变量在定义语句之前，会抛出错误。 const声明一个只读常量，一旦声明不能修改。 在JS中什么是变量提升？什么是暂时性死区？变量提升就是变量声明之前就可以使用，值为undefined. 暂时性死区：在使用let/const命令声明变量之前，该变量都是不可用的。在语法上，就称为“暂时性死区”。暂时性死区的本质是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可取，只有等到声明变量那一行代码出现，才可以获取和使用该变量。 如何正确的判断this? 箭头函数的this是什么？this的绑定规则有四种：默认绑定，隐式绑定，显示绑定，new绑定。 函数是new调用的，则this绑定的是新创建的对象。 函数通过apply、call、bind调用，this绑定的是指定的对象。 函数是否在某个上下文对象中调用，如果是，this指向这个上下文对象。 如果以上都不是，使用默认绑定。严格模式下绑定到undefined，否则绑定到全局对象。 如果把null，undefined传入call，apply，bind，则应用默认绑定规则。 箭头函数没有自己的this，它的this继承于上一层的this 词法作用域和this的区别 词法作用域是由你在写代码时将变量和块作用于写在哪里来决定的。 this是在调用时被绑定的，this指向什么，完全取决于函数调用的位置。 谈谈对JS执行上下文栈和作用域链的理解执行上下文就是当前JavaScript代码被解析和执行所在的环境，JS执行上下文栈可以认为是一个存储函数调用的栈结构，遵循先进后出的原则。 JavaScript执行在单线程上，所有的代码都是排队进行。 一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。 每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。 浏览器的js引擎总是访问栈顶的执行上下文。 全局上下文只有唯一的一个，他在浏览器关闭的时候出栈。 作用域链：无论是LHS还是RHS查询，都会在当前的作用域开始查找，如果没有找到，就会向上级作用域继续查找目标标识符，每次上升一个作用域，一直到全局作用域为止。 什么是闭包？闭包的作用是什么？闭包有哪些使用场景？闭包是一个函数，它能够访问另外一个函数作用域中的变量。创建闭包最常用的方式就是在一个函数内部创建另一个函数。 闭包的作用： 封装私有变量 模仿块级作用域 实现js模块 call, apply有什么区别？call，apply和bind内部是如何实现的？call和apply作用相同, 区别在于传参的方式不一样。call是一个一个参数的传，apply是传一个参数数组。 call内部实现如下： 将函数设为传入参数的属性 指定this到函数并传入给定参数，然后执行函数 如果不传入参数或者参数为null, 默认指向为window/global 删除参数上的函数 123456789101112Function.prototype.call = function(context)&#123; /** 如果第一个参数传入的是 null 或者是 undefined, 那么指向this指向 window/global */ /** 如果第一个参数传入的不是null或者是undefined, 那么必须是一个对象 */ if(!context)&#123; context = typeof window === 'undefined'?global:window; &#125; context.fn = this; let rest = [...arguments].slice(1); let result = context.fn(...rest); delete context.fn; return result;&#125; bind的区别：一个函数被call/apply的时候，会直接调用，但是bind会创建一个新函数。在这个函数被调用时，bind()的第一个参数将作为他运行时的this，之后一系列的参数将会在传递的实参钱传入作为他的参数。 new的原理是什么？通过new的方式创建对象和通过字面量创建有什么区别？new的原理： 首先创造一个空对象obj 这个新对象会被执行原型连接 this指向obj 返回obj 123456789function new(func)&#123; var target = &#123;&#125;; target.__proto__ = func.prototype; let res = func.call(target); if(typeof(res)=="object" || typeof(res)=="function")&#123; return res; &#125; return target;&#125; 字面量创建对象，不会调用Object构造函数，简洁且性能更好。 new Object()方式创建对象本质上是方法调用，涉及到在proto链中遍历按该方法，当找到该方法后，又会产生方法调用必须的堆栈信息，方法调用结束后，还要释放该堆栈，性能不如字面量的方式。 谈谈你对原型的理解？在JavaScript中，每当定义一个对象的时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype属性，这个属性指向函数的原型对象。使用原型链的好处是让所有对象实例都共享它所包含的属性和方法 什么是原型链？【原型链解决的是什么问题？】原型链解决的主要是继承问题。 每个对象都有一个原型对象，通过proto属性指向原型对象，并从中继承属性和方法，同时原型对象也可能拥有原型，这样一层一层，最终指向null(Object.prototype.__proto__)。这关系被称为原型链，通过原型链一个对象可以拥有定义在其他对象中的属性和方法。 prototype 和 __proto__ 区别是什么？prototype是构造函数的属性。 __proto__是每个实例都有的属性，可以访问[[prototype]]属性。 实例的__proto__与其构造函数的prototype指向的是同一个对象。 1234567891011function Student(name)&#123; this.name = name;&#125;Student.prototype.setAge = function()&#123; this.age = 20;&#125;let Jack = new Student('jack');console.log(Jack.__proto__);console.log(Student.prototype);console.log(Jack.__proto__ === Student.prototype); //true 使用ES5实现一个继承组合继承 1234567891011121314151617181920function SuperType()&#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;SuperType.prototype.sayName = function()&#123; console.log(this.name);&#125;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;SuperType.prototype = new SuperType();SubType.prototype.construct = SubType;SubType.prototype.sayAge = function()&#123; console.log(this.age);&#125; 什么是深拷贝？深拷贝和浅拷贝有什么区别？浅拷贝：只复制第一层对象，但是对象的属性是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。 深拷贝：深拷贝复制变量值，对于非基本类型的变量，则递归到基本类型变量后，再复制。深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响到另一个对象。 实现一个深拷贝 1234567891011121314151617function deepClone(obj)&#123; if(obj == null) return null; if(obj instanceof RegExp) return new RegExp(obj); if(obj instanceof Date) return new Date(obj); if(typeof obj !== 'object')&#123; return obj; &#125; let t = new obj.construct(); for(let key in obj)&#123; t[key] = deepClone(obj[key]); &#125; return t;&#125; 防抖和节流的区别是什么？防抖和节流的实现。防抖和节流的作用都是防治函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于设置的事件，防抖的情况只会调用一次，而节流的情况每个一定的时间调用一次函数。 ES6新的特性 新增了块级作用域(let, const) 提供了定义类的语法糖(class) 新增了一种基本数据类型(Symbol) 新增了变量的解构赋值 函数参数允许设置默认值，引入rest参数，新增箭头函数 数组新增了一些API，如isArray/from/of方法；数组实例新增了entries()、keys()和values()等方法。 对象和数组新增了扩展运算符 ES6新增了模块化(import/export) ES6新增了Set和Map构造函数 ES6原生提供Proxy构造函数，用来生成Proxy实例 ES6新增了生成器和遍历器。 setTimeout倒计时为什么会出现误差setTimeout()只是将事件插入了“任务队列”，必须等到当前代码(执行栈)执行完，主线程才会去执行它指定的回调函数。要是当前代码消耗时间很长，也有可能要等很久，所以并没有办法保证回调函数一定会在setTimeout()指定的时间执行。所以，setTimeout()的第二个参数表示的是最少时间，并非确切时间。 HTML5标准规定了setTimeout()的第二个参数的最小值不得小于4毫秒，如果低于这个值，则默认是4毫秒。在此之前，老版本的浏览器都将最短时间设为10毫秒。另外，对于DOM的变动，通常是间隔16毫秒执行，这时使用requestAnimationFrame()的效果好于setTimeout(). 为什么0.1+0.2 != 0.3 ？因为在进制转换和进阶运算的过程中出现精度损失。 详细解释如下： JavaScript使用Number类型表示数字(整数和浮点数)，使用64位表示一个数字。 进制转换 计算机无法直接对十进制的数字进行运算, 需要先对照 IEEE 754 规范转换成二进制，然后对阶运算。 但是由于IEEE 754尾数位数限制，需要将后面多余的位截掉，这样在进制之间的转换中精度已经损失。 对阶运算 由于指数位数不相同，运算时需要对阶运算，这部分也可能产生精度损失。 Promise有几种状态, Promise有什么优缺点？promise有三种状态：fulfilled、rejected、pending 优点 一旦状态改变，就不会改变，任何时候都可以得到这个结果。 可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的函数问题。 缺点 无法取消Promise。 当处于pending状态时，无法得知目前进展到哪一个阶段。 Promise构造函数是同步还是异步执行，then中的方法呢？构造函数是同步执行的，then方法是异步执行的。 Promise和setTimeout的区别？Promise是微任务，setTimeout是宏任务，同一个事件循环中，promise.then总是先于setTimeout执行。 如何实现Promise.all ？ 如果传入的参数是一个空的可迭代对象，那么此promise对象回调完成(resolve),只有此情况，是同步执行的，其它都是异步返回的。 如果传入的参数不包含任何 promise，则返回一个异步完成.promises 中所有的promise都“完成”时或参数中不包含 promise 时回调完成。 如果参数中有一个promise失败，那么Promise.all返回的promise对象失败。 在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组。 如何实现Promise.finally ?不管成功还是失败，都会走到finally中，并且在finally之后，还可以继续then。并且会将值原封不动的传递给后面的then。 什么是函数柯里化？实现 sum(1)(2)(3) 返回结果是1,2,3之和函数柯里化是把接受多个参数的函数变为接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术 123456789function sum(a)&#123; return function(b)&#123; return function(c)&#123; return a+b+c; &#125; &#125;&#125;console.log(sum(1)(2)(3)); //6 将普通函数进行柯里化 1234567891011121314151617function curry(fn, args = []) &#123; return function()&#123; let rest = [...args, ...arguments]; if (rest.length &lt; fn.length) &#123; return curry.call(this,fn,rest); &#125;else&#123; return fn.apply(this,rest); &#125; &#125;&#125;//testfunction sum(a,b,c) &#123; return a+b+c;&#125;let sumFn = curry(sum);console.log(sumFn(1)(2)(3)); //6console.log(sumFn(1)(2, 3)); //6]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript--防抖]]></title>
    <url>%2F2019%2F04%2F11%2Fjavascript--%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[javascript–防抖防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行。 第一版–防抖原始版1234567function debounce(func, wait)&#123; var timeout; return function()&#123; clearTimeout(timeout); timeout = setTimeout(func, wait); &#125;&#125; 第二版–修改this指向12345678910111213function debounce(func, time)&#123; var context = this; var timeout = null; return function()&#123; if(timeout)&#123; clearTimeout(timeout); &#125; timeout = setTimeout(function()&#123; func.apply(context); &#125;, time); &#125;&#125; 第三版–event对象1234567891011121314function debounce(func, time)&#123; var context = this; var args = arguments; var timeout = null; return function()&#123; if(timeout)&#123; clearTimeout(timeout); &#125; timeout = setTimeout(function()&#123; func.apply(context, args); &#125;, time); &#125;&#125; 第四版–立即执行1234567891011121314151617181920212223function debounce(func, time, immediate)&#123; var context = this; var args = arguments; var timeout = null; return function()&#123; if(timeout)&#123; clearTimeout(timeout); &#125; if(immediate)&#123; var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait); if (callNow) func.apply(context, args) &#125;else&#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; &#125;&#125; 第五版–返回值12345678910111213141516171819202122232425function debounce(func, wait, immediate) &#123; var timeout, result; return function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; // 如果已经执行过，不再执行 var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) result = func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; return result; &#125;&#125; 第六版–取消1234567891011121314151617181920212223242526272829303132function debounce(func, wait, immediate) &#123; var timeout, result; var debounced = function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; // 如果已经执行过，不再执行 var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) result = func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; return result; &#125;; debounced.cancel = function() &#123; clearTimeout(timeout); timeout = null; &#125;; return debounced;&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket]]></title>
    <url>%2F2019%2F03%2F28%2FHTML5%20WebSocket%2F</url>
    <content type="text"><![CDATA[HTML5 WebSocketWebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。 当获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。 123456789var ws = new WebSocket(“ws://echo.websocket.org”);ws.onopen = function()&#123;ws.send(“Test!”); &#125;; //连接时候触发ws.onmessage = function(evt)&#123;console.log(evt.data);ws.close();&#125;; //收到信号触发ws.onclose = function(evt)&#123;console.log(“WebSocketClosed!”);&#125;; //关闭请求时候触发ws.onerror = function(evt)&#123;console.log(“WebSocketError!”);&#125;; //出错时触发]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[准备面试--Promise 对象]]></title>
    <url>%2F2019%2F03%2F27%2FPromise%20%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Promise 对象含义所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。 基本用法1234567const promise = new Promise(function(resolve, reject)&#123; if(/*异步操作成功*/)&#123; resolve(value); &#125;else&#123; reject(err); &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject，它们是两个函数。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 1promise.then(function(value)&#123;...&#125;, function(err)&#123;...&#125;); 第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 123456789function timeout(ms)&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done'); &#125;);&#125;timeout(1000).then(function(value)&#123; console.log(value); &#125;); 上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。 Promise 新建后就会立即执行 1234567891011121314var promise = new Promise((resolve, reject)&#123; console.log('Promise'); resolve();&#125;);promise.then(function(value)&#123; console.log('resolved');&#125;);console.log('end')// Promise// end// resolved 异步加载图片 123456789101112131415function loadImgAsync(url)&#123; return new Promise((resolve, reject)&#123; var img = new Image(); img.onload = function()&#123; resolve(img); &#125; img.onerror = function()&#123; reject(new Error('Could not load image at '+ url)); &#125; img.src = url; &#125;);&#125; Promise实现ajax 12345678910111213141516171819202122232425262728const getJSON = function(url)&#123; const promise = new Promise((resolve, reject)&#123; const handler = function()&#123; if(this.readyState != 4)&#123; return; &#125; if(this.status == 200)&#123; rosolve(this.response); &#125;else&#123; reject(new Error(this.statusText)); &#125; &#125; const client = new XMLHttpRequest(); client.open('GET', url); client.onreadystatechange = handler; client.responseType = 'json'; client.setRequestHeader('Accept', 'application/json'); client.send(); &#125;); return promise;&#125;getJSON('/posts.json').then(function(value)&#123; console.log(value);&#125;,function(err)&#123; console.log(err);&#125;); 如果调用 resolve 函数和 reject 函数时带有参数，那么它们的参数会被传递给回调函数，也就是then里面的两个函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例 resolve和reject函数并不会终结promise参数函数的执行。因为这两个是回调函数啊😂，异步的函数，怎么终结函数的执行嘛。so，如果不想执行resolve和reject后续代码。在resolve和reject`函数前面加上return。 Promise.prototype.then()它的作用是为 Promise 实例添加状态改变时的回调函数。then方法返回的是一个新的 Promise 实例（注意，不是原来那个 Promise 实例）。 Promise.prototype.catch()Promise.prototype.catch 方法是 .then(null, rejection) 或 .then(undefined, rejection) 的别名，用于指定发生错误时的回调函数。 一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。 Promise.prototype.finally()finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。 1234promise.then(()=&gt;&#123;&#125;).catch(()=&gt;&#123;&#125;).finally(()=&gt;&#123;&#125;) 上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 Promise.all()Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1var newPromise = Promise.all([p1,p2,p3]); p1,p2,p3状态都为fulfilled，p为fulfilled。有一个为rejected，则p为rejected。 Promise.race()Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1var p = Promise.race([p1,p2,p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.resolve()有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。 123Promise.resolve(&apos;foo&apos;)// 等价于new Promise(resolve =&gt; resolve(&apos;foo&apos;)) Promise.resolve方法的参数分成四种情况。 参数是一个 Promise 实例 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 参数是一个thenable对象 thenable对象指的是具有then方法的对象，比如下面这个对象。 12345let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;; Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。 1234567891011let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function(val)&#123; console.log(val); //&#125;); 上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 42。 参数不是具有then方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。 123456const p = Promise.resolve(&apos;Hello&apos;);p.then(function (s)&#123; console.log(s)&#125;);// Hello 不带有任何参数 Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。 所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve方法。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[准备面试--css3新特性]]></title>
    <url>%2F2019%2F03%2F27%2Fcss3%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[css3新特性过渡CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。要实现这一点，必须规定两项内容：指定要添加效果的CSS属性指定效果的持续时间。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[准备面试--JavaScript 执行机制]]></title>
    <url>%2F2019%2F03%2F26%2FJavaScript%20%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[JavaScript 执行机制关于javascriptjavascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！ javascript事件循环既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类： 同步任务 异步任务 当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。过程如下 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 123456789let data = [];$.ajax(&#123; url: www.javascript.com, data: data, success: function()&#123; console.log('发送成功'); &#125;&#125;);console.log("代码执行结束"); ajax 进入Event table，注册回调函数success。 执行主线程console.log(&quot;代码执行结束&quot;)。 ajax事件完成，回调函数进入Event Queue。 主线程从Event Queue读取回调函数success并执行。 磨人的setTimeout小弟对他的第一印象就是延时执行，like this 123setTimeout(() =&gt; &#123; console.log("延时三秒");&#125;, 3000); 但有时候他又不止延时三秒，小弟也是一脸懵逼。 12345setTimeout(() =&gt; &#123; task();&#125;, 3000);sleep(1000000); 一执行，三秒之后毛都没有，等了很久很久task才执行，很奔溃😢。仔细一想，过程如下： task()进入Event Table, 并注册。 主线程执行sleep函数，很慢，非常慢，计时仍在继续。 三秒计时到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。 sleep终于执行完了，task()终于从Event Queue进入了主线程执行。 上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。 我们还经常遇到setTimeout(fn,0)这样的代码。setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。 123456789101112131415161718//代码1console.log('先执行这里');setTimeout(() =&gt; &#123; console.log('执行啦')&#125;,0);//先执行这里//执行啦//代码2console.log('先执行这里');setTimeout(() =&gt; &#123; console.log('执行啦')&#125;,3000);//先执行这里//3秒后//执行啦 关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。 继续磨人的setInterval上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。 唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。 总结js异步javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。 事件循环Event Loop事件循环是js实现异步的一种方法，也是js的执行机制。 总结之总结 javascript是一门单线程语言 Event Loop是javascript的执行机制]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[准备面试--BFC]]></title>
    <url>%2F2019%2F03%2F26%2F%E5%AD%A6%E4%B9%A0%20BFC%20(Block%20Formatting%20Context)%2F</url>
    <content type="text"><![CDATA[学习 BFC (Block Formatting Context)什么是BFCBFC全称是Block Formatting Context，即块格式化上下文。是关于CSS渲染定位的一个概念。 视觉格式化模型是用来处理文档并将它显示在视觉媒体上的机制。 视觉格式化模型定义了盒（Box）的生成，盒主要包括了块盒、行内盒、匿名盒（没有名字不能被选择器选中的盒）以及一些实验性的盒（未来可能添加到规范中）。盒的类型由display属性决定。 块盒（block box） 当元素的CSS属性display为block，list-item或 table时，它是块级元素 block-level； 视觉上呈现为块，竖直排列； 块级盒参与(块格式化上下文)； 每个块级元素至少生成一个块级盒，称为主要块级盒(principal block-level box)。一些元素，比如`，生成额外的盒来放置项目符号，不过多数元素只生成一个主要块级盒。 行内盒（inline box） 当元素的CSS属性display的计算值为inline，inline-block或inline-table时，称它为行内级元素； 视觉上它将内容与其它行内级元素排列为多行；典型的如段落内容，有文本(可以有多种格式譬如着重)，或图片，都是行内级元素； 行内级元素生成行内级盒(inline-level boxes)，参与行内格式化上下文(inline formatting context)。同时，参与生成行内格式化上下文的行内级盒称为行内盒(inline boxes)。所有display:inline的非替换元素生成的盒是行内盒； 匿名盒（anonymous box）匿名盒也有分匿名块盒与匿名行内盒，因为匿名盒没有名字，不能利用选择器来选择它们，所以它们的所有属性都为inherit或初始默认值； 如下面例子，会创键匿名块盒来包含毗邻的行内级盒 12345&lt;div&gt; Some inline text &lt;p&gt;followed by a paragraph&lt;/p&gt; followed by more inline text.&lt;/div&gt; 三个定位方案在定位的时候，浏览器就会根据元素的盒类型和上下文对这些元素进行定位，可以说盒就是定位的基本单位。定位时，有三种定位方案，分别是常规流，浮动以及绝对定位。 常规流(Normal flow) 在常规流中，盒一个接着一个排列; 在块级格式化上下文里面， 它们竖着排列； 在行内格式化上下文里面， 它们横着排列; 当position为static或relative，并且float为none时会触发常规流； 对于静态定位(static positioning)，position: static，盒的位置是常规流布局里的位置 对于相对定位(relative positioning)，position: relative，盒偏移位置由这些属性定义top，bottom，leftandright。即使有偏移，仍然保留原有的位置，其它常规流不能占用这个位置。 浮动(Floats) 盒称为浮动盒(floating boxes)； 它位于当前行的开头或末尾 这导致常规流环绕在它的周边，除非设置 clear 属性 绝对定位(Absolute positioning) 绝对定位方案，盒从常规流中被移除，不影响常规流的布局； 它的定位相对于它的包含块，相关CSS属性：top，bottom，left及right； 如果元素的属性position为absolute或fixed，它是绝对定位元素； 对于position: absolute，元素定位将相对于最近的一个relative、fixed或absolute的父元素，如果没有则相对于body； 块格式化上下文块格式上下文是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。 BFC创建方法 根元素或其它包含它的元素； 浮动 (元素的float不为none)； 绝对定位元素 (元素的position为absolute或fixed)； 行内块 inline-blocks(元素的 display: inline-block) 表格单元格(元素的display: table-cell，HTML表格单元格默认属性)； overflow的值不为visible的元素； 弹性盒 flex boxes (元素的display: flex或inline-flex)； 但其中，最常见的就是overflow:hidden、float:left/right、position:absolute。也就是说，每次看到这些属性的时候，就代表了该元素已经创建了一个BFC了。 BFC范围一个BFC包括所有创建了BFC元素的子元素，但并不包含已经创建新BFC的子元素的内部元素。 class名为.BFC代表创建了新的块格式化： 12345678910&lt;div id=&apos;div_1&apos; class=&apos;BFC&apos;&gt; &lt;div id=&apos;div_2&apos;&gt; &lt;div id=&apos;div_3&apos;&gt;&lt;/div&gt; &lt;div id=&apos;div_4&apos;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&apos;div_5&apos; class=&apos;BFC&apos;&gt; &lt;div id=&apos;div_6&apos;&gt;&lt;/div&gt; &lt;div id=&apos;div_7&apos;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 这段代码表示，#div_1创建了一个块格式上下文，这个上下文包括了#div_2、#div_3、#div_4、#div_5。即#div_2中的子元素也属于#div_1所创建的BFC。但由于#div_5创建了新的BFC，所以#div_6和#div_7就被排除在外层的BFC之外。 这从另一方角度说明，一个元素不能同时存在于两个BFC中. BFC的一个最重要的效果是，让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。这是利用BFC清除浮动所利用的特性，关于清除浮动将在后面讲述。 如果一个元素能够同时处于两个BFC中，那么就意味着这个元素能与两个BFC中的元素发生作用，就违反了BFC的隔离作用，所以这个假设就不成立了。 BFC的效果就如刚才提到的，BFC的最显著的效果就是建立一个隔离的空间，断绝空间内外元素间相互的作用。然而，BFC还有更多的特性。 内部的盒会在垂直方向一个接一个排列（可以看作BFC中有一个的常规流） 处于同一个BFC中的元素相互影响，可能会发生margin collapse 每个元素的margin box的左边，与容器块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此； BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然； 计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算 浮动盒区域不叠加到BFC上 帮助理解：html的根元素就是&lt;html&gt;，而根元素会创建一个BFC，创建一个新的BFC时就相当于在这个元素内部创建一个新的&lt;html&gt;，子元素的定位就如同在一个新&lt;html&gt;页面中那样，而这个新旧html页面之间时不会相互影响的。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[准备面试--CSS&HTML-2]]></title>
    <url>%2F2019%2F03%2F12%2F%E5%87%86%E5%A4%87%E9%9D%A2%E8%AF%95--CSS%26HTML-2%2F</url>
    <content type="text"><![CDATA[准备面试–CSS&amp;HTML-2No.1 两列布局1234&lt;body&gt; &lt;div id=&quot;left&quot;&gt;&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;&lt;/div&gt;&lt;/body&gt; 左列定宽，右列自适应 利用float+margin 1234567891011#left&#123; background: #f00; width: 100px; height: 500px; float: left;&#125;#right&#123; background: #0f0; height: 500px; margin-left: 100px;&#125; 利用float+overflow 1234567891011#left&#123; background: #f00; width: 100px; height: 500px; float: left;&#125;#right&#123; overflow: hidden; background-color: #0f0; height: 500px;&#125; 使用table实现 123456789101112131415#parent&#123; width: 100%; display: table; height: 500px;&#125;#left&#123; width: 100px; background-color: #f00;&#125;#right &#123; background-color: #0f0;&#125;#left,#right&#123; display: table-cell; /*利用单元格自动分配宽度*/&#125; 使用绝对定位实现 12345678910111213141516171819#parent&#123; position: relative; /*子绝父相*/&#125;#left &#123; position: absolute; top: 0; left: 0; background-color: #f00; width: 100px; height: 500px;&#125;#right &#123; position: absolute; top: 0; left: 100px; /*值大于等于#left的宽度*/ right: 0; background-color: #0f0; height: 500px;&#125; 使用flex实现 12345678910111213#parent&#123; width: 100%; height: 500px; display: flex;&#125;#left &#123; width: 100px; background-color: #f00;&#125;#right &#123; flex: 1; /*均分了父元素剩余空间*/ background-color: #0f0;&#125; 左列自适应,右列定宽 使用float+margin实现 1234567891011121314151617#parent&#123; height: 500px; padding-left: 100px; /*抵消#left的margin-left以达到#parent水平居中*/&#125;#left &#123; width: 100%; height: 500px; float: left; margin-left: -100px; /*正值等于#right的宽度*/ background-color: #f00;&#125;#right &#123; height: 500px; width: 100px; float: right; background-color: #0f0;&#125; 使用float+overflow实现 html: 123456&lt;body&gt;&lt;div id=&quot;parent&quot;&gt; &lt;div id=&quot;right&quot;&gt;右列定宽&lt;/div&gt; &lt;div id=&quot;left&quot;&gt;左列自适应&lt;/div&gt; &lt;!--顺序要换一下--&gt;&lt;/div&gt;&lt;/body&gt; css: 123456789101112#left &#123; overflow: hidden; /*触发bfc*/ height: 500px; background-color: #f00;&#125;#right &#123; margin-left: 10px; /*margin需要定义在#right中*/ float: right; width: 100px; height: 500px; background-color: #0f0;&#125; 使用table实现 1234567891011121314#parent&#123; width: 100%; height: 500px; display: table;&#125;#left &#123; background-color: #f00; display: table-cell;&#125;#right &#123; width: 100px; background-color: #0f0; display: table-cell;&#125; 使用绝对定位实现 12345678910111213141516171819#parent&#123; position: relative; /*子绝父相*/&#125;#left &#123; position: absolute; top: 0; left: 0; right: 100px; /*大于等于#rigth的宽度*/ background-color: #f00; height: 500px;&#125;#right &#123; position: absolute; top: 0; right: 0; background-color: #0f0; width: 100px; height: 500px;&#125; 使用flex 123456789101112#parent&#123; height: 500px; display: flex;&#125;#left &#123; flex: 1; background-color: #f00;&#125;#right &#123; width: 100px; background-color: #0f0;&#125; 一列不定,一列自适应 使用float+overflow实现 1234567891011#left &#123; margin-right: 10px; float: left; /*只设置浮动,不设宽度*/ height: 500px; background-color: #f00;&#125;#right &#123; overflow: hidden; /*触发bfc*/ height: 500px; background-color: #0f0;&#125; 使用flex 12345678910111213#parent&#123; display: flex;&#125;#left &#123; /*不设宽度*/ margin-right: 10px; height: 500px; background-color: #f00;&#125;#right &#123; height: 500px; background-color: #0f0; flex: 1; /*均分#parent剩余的部分*/&#125; No.2 三列布局两列定宽,一列自适应 float+margin html: 1234567&lt;body&gt;&lt;div id=&quot;parent&quot;&gt; &lt;div id=&quot;left&quot;&gt;左列定宽&lt;/div&gt; &lt;div id=&quot;center&quot;&gt;中间定宽&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;右列自适应&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; css: 123456789101112131415161718192021#parent&#123; min-width: 310px; /*100+10+200,防止宽度不够,子元素换行*/&#125;#left &#123; margin-right: 10px; /*#left和#center间隔*/ float: left; width: 100px; height: 500px; background-color: #f00;&#125;#center&#123; float: left; width: 200px; height: 500px; background-color: #eeff2b;&#125;#right &#123; margin-left: 320px; /*等于#left和#center的宽度之和加上间隔,多出来的就是#right和#center的间隔*/ height: 500px; background-color: #0f0;&#125; 使用float+overflow实现 12345678910111213141516171819202122#parent&#123; min-width: 320px; /*100+10+200+20,防止宽度不够,子元素换行*/&#125;#left &#123; margin-right: 10px; /*间隔*/ float: left; width: 100px; height: 500px; background-color: #f00;&#125;#center&#123; margin-right: 10px; /*在此定义和#right的间隔*/ float: left; width: 200px; height: 500px; background-color: #eeff2b;&#125;#right &#123; overflow: hidden; /*触发bfc*/ height: 500px; background-color: #0f0;&#125; 使用flex 123456789101112131415161718#parent &#123; height: 500px; display: flex;&#125;#left &#123; margin-right: 10px; /*间距*/ width: 100px; background-color: #f00;&#125;#center &#123; margin-right: 10px; /*间距*/ width: 200px; background-color: #eeff2b;&#125;#right &#123; flex: 1; /*均分#parent剩余的部分达到自适应*/ background-color: #0f0;&#125; 两侧定宽,中间自适应 双飞翼布局方法 html： 12345678910111213&lt;body&gt;&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;&lt;div id=&quot;parent&quot;&gt; &lt;!--中间栏需要放在前面--&gt; &lt;div id=&quot;center&quot;&gt; &lt;div id=&quot;center_inbox&quot;&gt;中间自适应&lt;/div&gt; &lt;hr&gt; &lt;!--方便观察原理--&gt; &lt;/div&gt; &lt;div id=&quot;left&quot;&gt;左列定宽&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;右列定宽&lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;footer&quot;&gt;&lt;/div&gt;&lt;/body&gt; css： 123456789101112131415161718192021222324252627282930313233343536#header &#123; height: 60px; background-color: #ccc;&#125;#left &#123; float: left; width: 100px; height: 500px; margin-left: -100%; /*调整#left的位置,值等于自身宽度*/ background-color: #f00; opacity: 0.5;&#125;#center &#123; height: 500px; float: left; width: 100%; background-color: #eeff2b;&#125;#center_inbox&#123; height: 480px; border: 1px solid #000; margin: 0 220px 0 120px; /*关键!!!左右边界等于左右盒子的宽度,多出来的为盒子间隔*/&#125;#right &#123; float: left; width: 200px; height: 500px; margin-left: -200px; /*使right到指定的位置,值等于自身宽度*/ background-color: #0f0; opacity: 0.5;&#125;#footer &#123; clear: both; /*注意清除浮动!!*/ height: 60px; background-color: #ccc;&#125; 圣杯布局方法 1234567891011121314151617181920212223242526272829303132333435363738394041#header&#123; height: 60px; background-color: #ccc;&#125;#parent &#123; box-sizing: border-box; height: 500px; padding: 0 215px 0 115px; /*为了使#center摆正,左右padding分别等于左右盒子的宽,可以结合左右盒子相对定位的left调整间距*/&#125;#left &#123; margin-left: -100%; /*使#left上去一行*/ position: relative; left: -115px; /*相对定位调整#left的位置,正值大于或等于自身宽度*/ float: left; width: 100px; height: 500px; background-color: #f00; opacity: 0.5;&#125;#center &#123; float: left; width: 100%; /*由于#parent的padding,达到自适应的目的*/ height: 500px; box-sizing: border-box; border: 1px solid #000; background-color: #eeff2b;&#125;#right &#123; position: relative; left: 215px; /*相对定位调整#right的位置,大于或等于自身宽度*/ width: 200px; height: 500px; margin-left: -200px; /*使#right上去一行*/ float: left; background-color: #0f0; opacity: 0.5;&#125;#footer&#123; height: 60px; background-color: #ccc;&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[准备面试--CSS&HTML-1]]></title>
    <url>%2F2019%2F02%2F28%2F%E5%87%86%E5%A4%87%E9%9D%A2%E8%AF%95--HTML%26CSS-1%2F</url>
    <content type="text"><![CDATA[准备面试–CSS&amp;HTML-1No.1 块级元素和行内元素有哪些？块级：&lt;div&gt;, &lt;p&gt;, &lt;form&gt;, &lt;h1&gt;~&lt;h6&gt;, &lt;hr&gt;, &lt;ul&gt;, &lt;ol&gt;, &lt;address&gt; 行内：&lt;a&gt;, &lt;span&gt;, &lt;i&gt;, &lt;em&gt;, &lt;br&gt;, &lt;strong&gt; No.2 块级元素和行内的特点。 块级：1、独占一行。 2、长度、宽度、行高可设置。 3、宽度没有设置时，默认为100%。 4、块级元素中可以包含块级元素和行内元素。 行内：1、和其他元素在一行中。2、高度，宽度以及内边距都是不能设置的。3、宽高就是内容的宽高，不能设置。4、行内元素内部只能包含行内元素，不能包含块级元素 No.3 img是什么类型的元素？ img属于行内替换元素 行内替换元素：height/width/padding/margin均可用。效果等于块级元素。 行内非替换元素：height/width/padding top、bottom/margin top、bottom均没有效果，只能用padding left、right/margin left、right改变宽度。 从元素本身的特点来说，分为不可替换元素和替换元素。HTML大多数元素是不可替换元素，即其内容直接表现给客户端。 替换元素就是根据元素的标签和属性，来决定元素的具体显示内容。例如浏览器会根据的src属性的值来读取图片的信息并显示出来。 HTML中的&lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;object&gt;都是替换元素 No.4 Doctype的作用？标准模式和兼容模式各有什么区别？ Doctype作用：用于向浏览器声明使用标准模式来解析文档。 标准模式：以浏览器最高级别来解析文档。 兼容模式：向后兼容的方式来解析文档。 No.5 为什么HTML5只需要写&lt;!DOCTYPE html&gt;？ 因为HTML5不是SGML的子集，所以不需要DTD引用，但是需要DOCTYPE来规范行为。 而HTML4.01是基于SGML，所以需要DTD引用，来告诉浏览器文档所使用的文档类型。 SGML：标准通用标记语言。 DTD：Docuemnt Type Definition，文档类型定义。 No.6 页面导入样式时，使用link和@import有什么区别？ link 在浏览器加载页面的时候并行加载，而@import需要等页面加载完成之后才会加载。 link 不存在兼容性问题，而@import是css2.1提出的，IE5以上才能支持。 link 还可以加载RSS和使用rel属性，@import只能加载css。 link 加载的样式可以通过JS更改，而@import加载的样式不可以被JS更改。 No.7 介绍一下你对浏览器内核的理解？ 渲染引擎：负责取得网页的内容(HTML,XML,图像等等)，整理讯息(引入CSS等)，通过计算来显示出网页(这个过程也称为回流)，然后输出至显卡，最后渲染为网页(这个过程称为重绘) JS引擎：获取网页的JS部分用来解析和执行以实现网页的动态效果 No.8 水平居中文本/行内元素/行内块级元素:text-align只控制行内内容(文字、行内元素、行内块级元素)如何相对他的块父元素对齐 123#parent&#123; text-align: center;&#125; 单个块级元素1234#son&#123; width: 100px; margin: 0 auto;&#125; 必须定宽，并且值不能为auto；宽度要小于父元素，否则无效 多个块级元素123456#parent&#123; text-align: center;&#125;.son&#123; display: inline-block; /*改为行内或者行内块级形式，以达到text-align对其生效*/&#125; 只对行内内容有效；属性会继承影响到后代行内内容；块级改为inline-block换行、空格会产生元素间隔 使用绝对定位原理：子绝父相，top、right、bottom、left的值是相对于父元素尺寸的，然后margin或者transform是相对于自身尺寸的，组合使用达到水平居中的目的 12345678910111213#parent&#123; height: 200px; width: 200px; position: relative; &#125;#son&#123; position: absolute; left: 50%; /*父元素宽度一半,这里等同于left:100px*/ transform: translateX(-50%); /*自身宽度一半,等同于margin-left: -50px;*/ width: 100px; /*定宽*/ height: 100px; background-color: #00ff00; 代码较多；脱离文档流；使用margin-left需要知道宽度值；使用transform兼容性不好（ie9+） 任意个元素原理：就是设置当前主轴对齐方式为居中。flex无非就是主轴侧轴是重点，然后就是排列方式的设置。 1234#parent&#123; display: flex; justify-content: center;&#125; No.9 垂直居中单行文本/行内元素/行内块级元素1234#parent&#123; height: 100px; line-height: 100px; /*与height等值*/&#125; 只能用于单行行内内容，要知道高度的值 多行文本/行内元素/行内块级元素1234#parent&#123; height: 150px; line-height: 30px; // 元素在页面呈现为5行，则line-height的值为height/5&#125; 只能用于行内内容；需要知道高度和最终呈现多少行来计算出line-height的值，建议用span包裹多行文本 图片123456#parent&#123; height: 150px; line-height: 150px; font-size: 0;&#125;img#son&#123;vertical-align: middle;&#125; 需要添加font-size: 0; 才可以完全的垂直居中；不过需要主要，html#parent包裹img之间需要有换行或空格 单个块级元素 使用table-cell实现 1234#parent&#123; display: table-cell; vertical-align: middle;&#125; 使用绝对定位实现 12345678910#parent&#123; position: relative; height: 150px;&#125;#son&#123; position: absolute; top: 50%; transform: translateY(-50%); height: 50px;&#125; 1234567891011//原理：当top、bottom为0时,margin-top&amp;bottom会无限延伸占满空间并且平分#parent&#123; position: relative;&#125;#son&#123; position: absolute; margin: auto 0; top: 0; bottom: 0; height: 50px;&#125; 使用flex 123456789#parent&#123; display: flex; align-items: center;&#125;//else#parent&#123; display: flex; &#125;#son&#123; align-self: center; &#125; 任意个元素12345678910111213#parent&#123; display: flex; align-items: center;&#125;//else#parent&#123; display: flex;&#125;.son&#123; align-self: center;&#125; No.10 水平垂直居中行内/行内块级/图片12345678910#parent&#123; text-align: center; height: 150px; line-height: 150px; font-size: 0;&#125;#son&#123; // display: inline 如果是块级元素需要改为行内元素才能生效 vertical-align: middle;&#125; table-cell123456789101112#parent&#123; height: 150px; width: 200px; display: table-cell; vertical-align: middle; // text-align: center; 行内元素&#125;#son&#123; // margin: 0 auto; 块级元素 width: 100px; height: 50px;&#125; 绝对定位123456789#parent&#123; position: relative;&#125;#son&#123; position: absolute; top: 50%: left: 50; transform: translate(-50%, -50%);&#125; 绝对居中原理：当top、bottom为0时,margin-top&amp;bottom设置auto的话会无限延伸占满空间并且平分；当left、right为0时,margin-left&amp;right设置auto的话会无限延伸占满空间并且平分 12345678910111213#parent&#123; position: relative;&#125;#son&#123; position: absolute; margin: 0; top: 0; left: 0; right: 0; bottom: 0; height: 50px; width: 60px;&#125; flex123456789101112131415#parent&#123; display: flex; justify-content: center; align-item: center;&#125;//else#parent&#123; display: flex; justify-content: center;&#125;#son&#123; align-self: center;&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Express构建Web程序]]></title>
    <url>%2F2019%2F02%2F16%2F%E4%BD%BF%E7%94%A8Express%E6%9E%84%E5%BB%BAWeb%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[使用Express构建Web程序12var express = require(&apos;express&apos;);var app = express(); app为一个Express应用程序实例对象，app.listen(1337, &#39;127.0.0.1&#39;)指定服务器所要监听的地址。 app.get(path,callback)接收客户端提供的GET请求并返回服务器端响应结果。callback =&gt; function(req,res){...} 在Express框架中，为http.ServerResponse对象提供一个send方法，用于发送一个服务器的响应结果。该方法不需要单独发送响应头信息，会自动计算头信息；也不需要用end方法结束响应的发送。 设置路由在路由中，可以使用：+参数名的方式指定一个参数。在路由中，可以使用正则表达式。在路由中，可以使用通配符。 使用各种提交数据或请求数据的方法12345app.get(path, callback)app.post(path, callback)app.put(path, callback)app.delete(path, callback)app.all(path, callback) 中间件在Express框架中，允许通过中间件的使用来调用各种第三方库，这让我们的开发工作变得更为方便，也使得我们可以开发出各种更为强大的应用程序。 一个中间件是一个用于处理客户端请求的函数。一个HTTP服务器中可能会使用到各种中间件。当接收到一个客户端时，首先将该请求提交给第一个中间件函数，每一个中间件函数内部都封装一个next回调函数，在一个中间件函数内部可以判断是否调用next回调函数来处理客户端请求。function middleware(req,res,next){next()} 在Express中，使用应用程序实例对象的use方法来调用一个中间件，app.use([path],function) path用于指定何种路径应用中间件 12345app.get(path, [callback], callback)app.post(path, [callback], callback)app.put(path, [callback], callback)app.delete(path, [callback], callback)app.all(path, [callback], callback) 在这些方法path和callback中间，可以使用一个或多个参数，每一个参数值均为一个中间件函数。在使用多个中间件函数时，当在前一个中间件函数中调用next方法时，调用后一个中间件函数；当在最后一个中间件函数中调用next方法时，调用最后一个callback参数值的回调函数。 Express框架中内置的中间件basicAuth中间件为网站添加身份认证功能。在使用该中间件之后，用户访问网站时必须输入用户名与密码才能访问网站。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于TCP与UDP的数据通信]]></title>
    <url>%2F2019%2F02%2F13%2F%E5%9F%BA%E4%BA%8ETCP%E4%B8%8EUDP%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[基于TCP与UDP的数据通信使用net模块实现基于TCP的数据通信创建TCP服务器123var server = net.createServer([option],[connectionListener])[connectionListener] ==&gt; function(socket)&#123;...&#125; //socket为该TCP服务器监听的socket端口对象 在创建TCP服务器之后，使用listen方法通知服务器开始监听客户端链接。三种方法。 server.listen(port,[host],[backlog],[callback]) port监听端口号，参数值为0时随机分配；host指定监听的IP地址或主机名，省略则监听全部客户端链接；backlog指定位于等待队列的客户端链接的最大数量，默认511。 server.listen(path,[callback]) 用于通知一个使用unix端口的服务器开始监听来自于指定路径的客户端链接，path指定需要监听的路径。 server.listen(handle,[callback]) 用于通知一个TCP服务器开始监听来自于socket句柄。句柄可以是TCP服务器对象，可以是socket端口对象，文件描述等。 如果不使用callback，也可以通过server.on(&#39;listening&#39;, function(){...}。当监听地址或端口被占用，将产生“EADDRINUSE”的错误，并触发error事件。 可以用address方法来查看该服务器所监听的地址信息，在服务器触发listening事件之后再调用该方法。var address = server.address()，address是一个对象，其下有三个属性，port监听端口号，address监听地址，family表明是ipv4还是ipv6 可以使用getConnections方法查看当前与TCP服务器建立连接的客户端数量。可以通过server.maxConnections设置最大链接数量 1234server.getConnections(function(err,count)&#123; ...&#125;)//count 为获取到的客户端链接数 最后可以使用close方法让服务器拒绝所有新的客户端链接，server.close([callback])。在调用时并不会断开现有连接。 socket端口对象使用net.Socket代表一个socket端口对象。在使用createServer方法的connectionListener参数所指定的回调函数的参数值即为一个被自动创建的net.Socket对象。 socket对象可被用来读取客户端发送的流数据，每次接收到客户端发送的流数据时触发data事件 pipe将客户端发送的流数据写入文件等对象中 socket.pipe(destination,[options]),destination为可写入数据流对象。使用socket.unpipe([destination])取消目标对象的写入操作，若不用参数，则取消所有的pipe写入操作。 创建TCP客户端var net = new net.Socket([options])options的内容：fd，socket文件描述符；type，协议；allowHalfOpen。 创建socket端口对象之后，可以使用两种connect方法连接TCP服务器 socket.connect(port, [host], [connectListener]) port需要链接的TCP服务器端口；host需要连接的TCP服务器地址，不指定则默认为localhost；最后一个参数为连接成功时的回调函数。也可以不指定connectListener参数，而是通过监听socket对象的connect事件来处理连接成功时的操作。 socket.connect(path, [connectListener]) 用于与unix端口的服务器进行连接。 socket建立连接后，客户端和服务端都具有如下属性：remoteAddress、remotePort、localAddress、localPort。 socket.write(data,[encoding],[callback])用来向客户端或者服务端写入数据。 发生错误触发error事件，socket.on(&#39;error&#39;, function(err){})，在捕捉到错误之后，要使用socket.destroy()销毁该socket端口对象，确保该socket端口对象不会被利用。 使用socket.end([data],[encoding])关闭客户端和服务端的连接。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建HTTP与HTTPS服务器及客户端]]></title>
    <url>%2F2019%2F02%2F11%2F%E5%88%9B%E5%BB%BAHTTP%E4%B8%8EHTTPS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8A%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[创建HTTP与HTTPS服务器及客户端HTTP服务器创建HTTP服务器123var server = http.createServer([requestListener]);requestListener ==&gt; function(request, response)&#123;...&#125; 回调函数中有两个参数，第一个参数代表客户端请求，第二个参数代表一个服务器响应对象。若不在createServer方法中使用参数，也可以通过监听服务器对象的request事件server.on(&#39;request&#39;, function(request,response){...})。 在创建了http服务器之后，需要指定服务器监听的地址server.listen(port, [host], [bocklog], [callback])可使用listen回调函数指定listening事件的回调函数，也可以使用server对象监听listening事件 关闭http服务器server.close()，当服务器关闭时，触发close事件server.on(&#39;close&#39;,function(){...}) 若http服务器监听的端口或地址已被占用，将产生错误代码为”EADDRINUSE”的错误，同时将触发HTTP服务器的error事件 客户端和服务端建立连接时，触发connect事件server.on(&#39;connection&#39;,function(socket){...})。在浏览器访问HTTP服务器时，浏览器会发出两次客户端请求，一次是用户发出的请求，另一次是浏览器为页面在收藏加中的显示图标（favicon.ico）自动发出的。 设置超时server.setTimeout(msecs, callback)超时触发timeout事件。 获取客户端请求信息HTTP服务器接收到客户端请求时调用回调函数中的第一个参数值为http.IncomingMessage对象，该对象用于读取客户端请求流中的数据。当读取代新数据触发data事件，读取完毕触发end事件。 req下的data事件和end事件。 转换URL字符串与查询字符串在node.js中，提供了一个url模块和一个Query String模块，分别用来转换完整URL字符串和URL中的查询字符串。 在一个完整的URL字符串中，从？字符之后到#号字符之前或者到URL字符串结束的这一部分为查询字符串 可以使用Query String模块中的parse方法将查询字符串转化为一个对象，querystring.parse(str,[sep],[eq],[options])sep用于指定查询字符串的分割字符，默认为“&amp;”；eq用于指定查询字符串中的分配字符，默认为“=”；options为一个对象，对象中设置maxKeys来指定转换后的对象属性个数。 querystring.stringify(obj,[sep],[eq])将对象转换为一个查询字符串，sep指定查询字符串中的分隔符，默认为&amp;；eq指定查询字符串中使用的分配字符，默认为=。 URL模块专门用于对完整的URL字符串进行转换。 parse方法将一个URL字符串转化为一个对象。url.parse(urlStr, [parseQueryString]) format方法将URL字符串经过转换后的对象还原成一个URL字符串。url.format(urlobj) resolve方法将两个路径结合成为一个路径 url.resolve(from, to) 如果from为网络路径，to为非网络路径的绝对路径，则返回网络根目录+参考路径 其他情况下，to为绝对路径，则返回参考路径 如果from为一个不以“/”字符结尾的根目录且to为相对路径，则返回根目录+/+参考路径去除开头./或../ 如果from为一个以“/”字符结尾的根目录且to为相对路径，则返回根目录+/+参考路径去除开头./或../ url.resolve(&#39;http://www.example.com/a/b/c&#39;, &#39;one&#39;)返回http://www.example.com/a/b/one url.resolve(&#39;http://www.example.com/a/b/c/&#39;, &#39;one&#39;)返回http://www.example.com/one url.resolve(&#39;http://www.example.com/a/b/c&#39;, &#39;./one&#39;)返回http://www.example.com/a/b/one url.resolve(&#39;http://www.example.com/a/b/c/&#39;, &#39;./one&#39;)返回http://www.example.com/a/b/c/one url.resolve(&#39;http://www.example.com/a/b/c&#39;, &#39;../one&#39;)返回http://www.example.com/a/one url.resolve(&#39;http://www.example.com/a/b/c&#39;, &#39;../one&#39;)返回http://www.example.com/a/one 发送服务器端相应流在createServer方法的参数值回调函数或服务器对象的request事件函数中的第二个参数值为一个http.ServerResponse对象，可以利用该对象发送服务器端响应流。 response.writeHead(statusCode,[reasonPhrase],[headers])statusCode指定一个HTTP状态码，例如404。reasonPhrase指定对于状态码的描述信息。第三个参数为一个对象，指定服务器端创建的响应头对象。在响应头中包含的常用字段如下： content-type: 指定内容类型 location: 将客户端重定向到另一个URL地址 content-disposition: 指定一个被下载的文件名 content-length: 指定服务器端响应内容的字节数 set-cookie: 在客户端创建一个cookie content-encoding: 指定服务器端响应内容的编码方式 Cache-Control: 开启缓存机制 Expires: 用于指定缓存过期时间 Etag: 用于指定当前服务器响应的内容没有变化时不重新下载数据 若服务器端口为1337，并从80端口的网站运行HTML5页面，这是一种跨域操作。需要在HTTP响应头中添加Access-Control-Allow-Origin字段，并且将参数值指定为允许向服务器请求数据的端口+端口号（省略端口号时允许该域名下的任何端口向服务器请求数据） 12res.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;,&apos;Access-Control-Allow-Origin&apos;: &apos;http://localhost&apos;&#125;) response.setHeader(name, value)单个设置头信息 response.getHeader(name)获取响应字段 response.removeHeader(name)删除响应字段，必须在ServerResponse对象的write方法之前被调用 在调用writeHead方法时即发送响应头。在使用setHeader时，调用write方法即发送响应头。两种方法发送响应头的时间不一样。 默认情况下，HTTP服务器自动将服务器端的当前时间作为响应头的Date字段发给客户端，可以设置sendDate为false删除Date字段。statusCode获取HTTP服务器返回的状态码。 res.addTrailers(headers)在响应数据的尾部追加一个头信息，headers为一个对象 res.write(chunk, [encoding])发送响应内容。 HTTP客户端var req = http.request(options, callback)向其他网站发送请求数据。 req.on(&#39;resposne&#39;,function(res){})当客户端请求获取到响应流之后，触发response事件 req.write(chunk,[encoding]) 向目标网站发送数据 req.end([chunk],[callback])结束本次请求 在建立连接的过程中，当为该连接分配端口时，触发http.ClientRequest对象的socket事件req.on(&#39;socket&#39;,funcition(socket){...})]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack--入口起点]]></title>
    <url>%2F2018%2F11%2F22%2F%20webpack--%E5%85%A5%E5%8F%A3%E8%B5%B7%E7%82%B9%2F</url>
    <content type="text"><![CDATA[入口起点(entry points)单个入口（简写）语法12345const config = &#123; entry: &apos;./path/to/my/entry/file.js&apos;&#125;;module.exports = config; 对象语法123456const config = &#123; entry: &#123; app: &apos;./src/app.js&apos;, vendors: &apos;./src/vendors.js&apos; &#125;&#125;; 常见应用分离 应用程序(app) 和 第三方库(vendor) 入口多页面应用程序]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack--概念]]></title>
    <url>%2F2018%2F11%2F22%2FWebpack%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Webpack概念 入口(entry) 输出(output) loader 插件(plugins) 入口(entry)入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 输出(output)output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段。 loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 插件(plugins)plugins插件可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。 想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6--变量的解构赋值]]></title>
    <url>%2F2018%2F04%2F24%2FES6--%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[变量的解构赋值数组的解构赋值基本用法ES6允许按照一定模式从数组和对象中提取值，然后对变量进行赋值，这被称为解构。例如： 12345let a=1;let b=2;let c=3;//上面等价于let [a,b,c]=[1,2,3]; 默认值解构赋值允许有默认值。 1234let [foo=true]=[];foo //truelet [x,y='b']=['a'] //x='a', y='b' 如果默认值是一个表达式，那么这个表达式是惰性求值的。默认值可以引用解构赋值的其他变量，但改变量必须已经声明。 对象的解构赋值解构不仅可以用于数组，还可以用于对象 123let &#123;foo, bar&#125;=&#123;foo: 'aaa',bar: 'bbb'&#125;;foo //aaabar //bbb 对象的解构和数组有一个重要的不同。对象的属性没有次序，变量必须与属性同名才能取得正确的值。如果变量名和属性名不一致，必须写成下面这样 12var &#123;foo:baz&#125;=&#123;foo:'aaa',bar:'bbb'&#125;;baz //aaa 对象的解构赋值的内部机制是先找到同名属性，然后再赋值给相应的变量。真正被赋值的是后者，而不是前者。对象的解构也可以指定默认值。默认值生效的条件是：对象属性值严格等于undefined。 对象的解构赋值可以很方便的将现有对象的方法赋值到某个变量例如let {log,sin,cos}=Math;另外数组本质是特殊的对象，可以有如下操作 1234let arr=[1,2,3];let &#123;0:first,[arr.length-1]:last&#125;=arr;first //1last //3 字符串的解构赋值字符串也可以解构赋值。这是因为此时的字符串被转化成了一个类似数组的对象。 1const [a,b,c,d,e]='hello'; 类似数组的对象都有一个length属性，因此可以对这个属性进行解构赋值 12let &#123;length:len&#125;='hello';len //5 数值和布尔值的解构赋值解构属性时，如果等号右边是数值和布尔值，则会先转化为对象。 函数参数的解构赋值12345function add([x,y])&#123; return x+y;&#125;add([x,y]); //3 上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成x和y。对于函数内部的代码来说，他们能感受到的就是x和y。函数参数的解构也可以使用默认值。 圆括号问题解构赋值虽然很方便，但是解析起来不是很容易。 不能使用圆括号的情况 变量声明语句。let [x: (c)]=[1]; //报错 函数参数。 function f(z, (x)){return x;} 赋值语句模式。 ({p: a})={p: 42}) 将整个模式放在圆括号之中 可以使用圆括号的情况赋值语句的非模式部分可以使用圆括号。 用途交换变量的值1234let x=1;let y=2;[x,y]=[y,x]; 从函数返回多个值函数只能返回一个值，如果返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213function example()&#123; return [1,2,3];&#125;let [a,b,c]=example()//返回一个对象function example()&#123; return &#123; foo: 1, bar: 2 &#125;&#125;let &#123;foo,bar&#125;=example(); 函数参数的定义解构赋值可以方便地将一组参数与变量名对应起来 提取JSON数据对于提取JSON对象中的数据尤其有用 123456789let jsonData=&#123; id: 42, status: "OK", data: [867, 5309]&#125;let &#123;id, status, data:number&#125;=jsonData;id //42status //"OK"number //"[867, 5309]" 函数参数的默认值遍历Map结构任何部署了Iterator接口的对象都可以用for…of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值获取键名和键值就非常方便。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基础--计算属性]]></title>
    <url>%2F2018%2F04%2F23%2FVue--%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[计算属性 模版内的表达式常用于简单的运算，当其过长或逻辑复杂时，会难以维护。计算属性则是解决该问题的。 什么是计算属性上一章已经学到，我们可以通过&#123;&#123; &#125;&#125;双向绑定一些数据或者表达式，但是如果数据或者表达式过长，就会变得臃肿甚至难以阅读和维护。比如 123&lt;div&gt; &#123;&#123; text.split(',').reverse().join(',') &#125;&#125;&lt;/div&gt; 这里的表达式包含3个操作，并不是很清晰，所以我们遇到复杂的逻辑时，应该用计算属性。上面可以改写为如下： 12345678910111213141516&lt;div id="app"&gt; &#123;&#123;reversedText&#125;&#125;&lt;/div&gt;&lt;script&gt; var app=new Vue(&#123; el: '#app', data: &#123; text: '123,456', &#125;, computed: &#123; reversedText: function()&#123; return this.text.split(',').reverse().join(','); &#125;, &#125; &#125;);&lt;/script 所有的计算属性都以函数的形式写在Vue实例内的computed选项内，最终返回计算后的结果。 计算属性用法在一个计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结果就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;hello&lt;/title&gt; &lt;script src="vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;总价：&#123;&#123; prices &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var app=new Vue(&#123; el: '#app', data: &#123; package1: [ &#123; name: 'iphone 7', price: 7199, count: 2, &#125;, &#123; name: 'ipad', price: 2888, count: 3, &#125; ], package2: [ &#123; name: 'apple', price: 3, count: 5, &#125;, &#123; name: 'banana', price: 2, count: 10, &#125; ], &#125;, computed: &#123; prices: function()&#123; var prices=0; for(let i=0;i&lt;this.package1.length;i++)&#123; prices += this.package1[i].price*this.package1[i].count; &#125; for(let i=0;i&lt;this.package2.length;i++)&#123; prices += this.package2[i].price*this.package2[i].count; &#125; return prices; &#125;, &#125;, &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当package1或package2中的商品有任何变化，比如购买数量变化或增删商品时，计算属性prices就会自动更新，视图中的总价也会变化。每一个计算属性都包含一个getter和一个setter，上面使用的都是getter。setter的作用是，当手动修改计算属性的值就像修改一个普通数据那样，就会触发setter函数。计算属性的两个小技巧： 可以依赖其他计算属性 计算属性不仅可以依赖当前Vue实例的数据，还可以依赖其他实例数据 计算属性缓存计算属性是基于它的缓存的。一个计算属性所依赖的数据发生变化时，他才会重新取值。只要数据不改变，计算属性也就不更新。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基础--v-bind及class与style绑定]]></title>
    <url>%2F2018%2F04%2F23%2FVue.js--v-bind%E5%8F%8Aclass%E4%B8%8Estyle%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[v-bind及class与style绑定 DOM元素经常会动态地绑定一些class类名或style样式。 了解v-bind指令]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6--let和const]]></title>
    <url>%2F2018%2F04%2F21%2FES6--let%E5%92%8Cconst%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[let和const命令1.let命令1.1 基本用法let用于申明变量，其用法类似于var。但是所有申明的变量只在let命令所在的代码块内有效。for循环有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环内部是一个单独的子作用域。 1234567for(let i=0;i&lt;3;i++)&#123; let i=0; console.log(i);&#125;//abc//abc//abc 1.2 不存在变量提升使用var声明变量会有变量提升的情况，即变量可以在声明之前使用，值为undefined。为了纠正这种情况，let命令改变了语法行为，他所声明的变量一定要在声明之后使用，否则会报错。 12345console.log(foo); //undefinedvar foo=2;console.log(foo1); //报错let foo1=2; 1.3 暂时性死区只要块级作用域内存在let命令，他所声明的变量就“binding”绑定这个区域，不再受外部的影响。 12345var tmp=123;if(true)&#123; tmp='abc'; let tmp;&#125; 上面存在全局作用域tmp，但是块级作用域内又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明之前，调用tmp会报错。总之，暂时性死区的本质就是只要进入当前作用域，所要使用的变量就已经存在，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 1.4 不允许重复声明let不允许在相同的作用域中重复声明同一个变量 1234567891011//报错function()&#123; let a=10; var a=1;&#125;//报错function()&#123; let a=10; let a=1;j&#125; 2.块级作用域2.1 为什么使用块级作用域ES5只有全局作用域和函数作用域，没有块级作用域，这导致很多场景不合理。 内层变量可能会覆盖外层变量 12345678910var tmp=new Date();function f()&#123; console.log(tmp); if(false)&#123; var tmp="hello world"; &#125;&#125;f(); //undefined 用来计数的循环变量泄漏为全局变量 2.2 ES6的块级作用域let实际上为JavaScript新增了块级作用域 12345678function f1()&#123; let n=5; if(true)&#123; let n=10; &#125; console.log(n);&#125;f1(); // 5 外层代码不受内层代码的影响，如果使用var定义变量n，最后输出的值就是10.ES6允许块级作用域的任意嵌套，并且外层作用域无法读取内层作用域的变量。内层作用域可以定义和外层作用域的同名变量块级作用的出现，实际上使得立即执行匿名函数不再必要 2.3 块级作用域和函数声明ES5规定，函数只能在顶层作用域和函数作用域中声明，不能在块级作用域中声明。但是浏览器并没有遵守这个规定。ES6引入块级作用域，明确允许在块级作用域之中声明函数。在块级作用域之中声明函数类似于let，在块级作用域之外不可引用。 2.4 do表达式本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。现在有一个提案使得块级作用域可以变为表达式，即可以返回值，操作如下： 1234let x=do&#123; let t=f(); t*t+1;&#125;; 3.const命令3.1 基本用法const声明一个只读常量。一旦声明，常量的值不能改变。const一旦声明常量，就必须立即初始化，不能留到以后赋值。其余特性和let一样。 3.2 本质const实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据而言，值就保存在变量指向的内存地址中,因此等同于常量。但对于复合类型的数据，变量指向的内存地址只是一个指针，const只能保证这个指针是固定的，至于他指向的数据结构是不是可变的，这完全不能控制。如果想将对象冻结，应该使用Object.freeze方法。const foo=Object.freeze({}); 3.3 ES6声明变量的6种方法ES5: 使用var命令和function命令。ES6: 添加了let和const命令，还有import和class命令。 4.顶层对象属性顶层对象在浏览器中是指window对象，在Node环境中指的是global对象。在ES5中，顶层对象属性和与全局变量是等价的。ES6规定，var命令和function命令声明的全局变量依旧是顶层对象属性；其次，let命令、const命令、class命令声明的全局变量不属于顶层对象属性。 5.global对象ES5的顶层对象本身也是一个问题，因为他在各种实现中是不统一的。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基础]]></title>
    <url>%2F2018%2F04%2F19%2FVue_No1%2F</url>
    <content type="text"><![CDATA[What’s Vue.js综述：简单小巧的核心，渐进式技术栈。可以一步一步，有阶段的使用vue.js。他提供了现代web开发中常见的高级功能。 解耦视图与数据 可复用组件 前端路由 状态管理 虚拟DOM 1.1 MVVM模式Vue.js在设计上使用MVVM。当View发生变化时，会自动更新到ViewModel(视图模型)。View和ViewModel之间通过双向绑定建立联系。Vue.js通过MVVM的模式拆分为视图和数据两个部分，并将其分离。只需要操作数据。 How do we use it?2.1 实例与数据绑定Vue.js创建： 1234var app=new Vue(&#123; //选项 el: document.getElementById('app'); //或者是'#app'&#125;); 不可缺少的选项：el。el用于指定一个页面中已经存在的DOM元素。该元素用来挂载Vue实例，他可以是HTMLElement或者CSS选择器。 data选项，可以声明应用内需要双向绑定的数据。 2.1.1 生命周期每个Vue实例创建时，都会经历一系列初始化过程，同时也会调用相应的生命周期钩子，利用相应的生命周期钩子，在合适的时机执行我们的业务逻辑。 created：实例创建完成后调用，此阶段完成了数据的观测，但尚未挂载。$el还不能用。 mounted: el挂载到实例上调用。 beforeDestroy：实例销毁之前调用。 2.1.2 插值与表达式插值表达方式：“&#123;&#123; &#125;&#125;”。作用：他会自动将我们双向绑定的数据显示出来。 如果想输出HTML，而不是纯文本，可以用v-html。 如果想显示&#123;&#123; &#125;&#125;，使用v-pre即可跳过这个元素和它的籽元素编译的过程。 在&#123;&#123; &#125;&#125;中，除了简单的绑定属性值外，还可以使用Javascript表达式进行运算。但是，他只支持单个表达式，不支持语句和流控制。 2.1.3 过滤器在&#123;&#123; &#125;&#125;插值的尾部添加一个管道符(|)对数据进行过滤，经常用于格式化文本。过滤规则是自定义的，通过给Vue实例添加filters来设置 2.2 指令与事件指令是Vue.js模版中最常用的一项功能，他带有前缀v-。指令的主要职能就是当其表达式的值改变时，相应地将某些行为应用到DOM上。数据驱动DOM是Vue.js的核心理念，不到万不得已不要主动操作DOM。 v-bind:基本用途是动态更新HTML元素上的属性，比如id、class等。 v-on:用来绑定事件监听器，]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM扩展]]></title>
    <url>%2F2018%2F03%2F19%2FDOM%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[DOM扩展 之前都是学习的DOM，最近准备学习下DOM扩展和DOM2、DOM3 DOM扩展目的：为了实现更多的功能。DOM主要扩展的两方面：Selectors API和HTML5。 1.选择符API最常用的的就是根据CSS选择符选择与某个模式匹配的DOM元素。jQuery的核心就是通过CSS选择符查询DOM文档取得元素引用。Selectors API的核心是两个方法：querySelector()和querySelectorAll()。 1.1 querySelector()方法querySelector()接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回null。 123456//取得body元素var body=document.querySelector("body");//取得ID为myDiv的元素var myDiv=document.querySelector("#myDiv");//取得类为selected的第一个元素var selected=document.querySelector(".selected"); 通过Document类型调用querySelector()方法时，会在文档元素范围内查找匹配的元素。而通过Element类型调用quertSelector()方法时，只会在该元素后代元素的范围内查找匹配的元素。 1.2 querySelectorAll()接收的参数和querySelector()一样，都是一个css选择符，但返回的是所有匹配元素而不仅仅是一个元素。这个方法返回一个NodeList的实例。 1.3 matchesSelector()方法这个方法接收一个参数，即css选择符，如果调用元素与该选择符匹配，返回true；否则，返回false。 2.元素遍历对于元素间的空格，IE9及之前的版本不会返回文本节点，而其他所有浏览器都会返回文本节点。为了保持一致。定义以下新属性。 childElementCount：返回子元素的个数（不包含文本节点和注释） firstElementChild: 返回第一个元素；firstChild元素版。 lastElementChild: 指向最后一个元素；lastChild元素版。 previousElementSibling: 指向前一个同辈元素。previousSibling的元素版。 nextElementSibling：指向后一个同辈元素。nextSibling的元素版。 遍历某元素的子元素 1234567var i, len, child=element.firstElementChild;while( child != element.lastElementChild )&#123; processChild(child); child=child.nextElementSibling;&#125; 3.HTML5HTML5规范围绕如何使用新增标记定义了大量的JavaScript API 3.1 与类相关的扩充 getElementsByClassName()方法接收一个参数，即一个包含一个或多个类名的字符串。返回带有指定类的所有元素的NodeList。 12//取得所有类中包含“username”和“current”的元素，类名的先后顺序无所谓var allCurrentUsernames=document.getElementsByClassName("username current"); 调用这个方法时，只有位于调用子树中的元素才会返回。在document对象上调用getElementsByClassName()始终会返回与类名匹配的所有元素，在元素上调用该方法就只会返回后代元素中匹配的元素。 classList属性classList属性有一个表示自己包含多少元素的length属性，而取得每个元素可以使用item()或者方括号语法。此外这个属性还定义了如下方法。 add(value): 将给定的字符串值添加到列表中。如果存在，则不添加了。 contains(value): 表示列表中是否存在给定的值。如果存在则返回true，否则则返回false。 remove(value): 从列表中删除给定的字符串。 toggle(value): 如果存在给定值，则删除它，如果不存在给定值，则添加它。 123456789div.classList.remove("disabled");div.classList.add("current");div.classList.toggle("ueser");if(div.classList.contains("bd"))&#123; ...&#125;for(var i=0;i&lt;classList.length;i++)&#123; doSomething(div.classList[i]);&#125; 3.2 焦点管理HTML5也添加了辅助管理DOM焦点的功能。首先就是document.activeElement属性，作用：始终引用DOM中当前获得了焦点的元素。元素获得焦点的方式有页面加载、用户输入、在代码中调用focus()方法。 123var button=document.getElementById('myButton');button.focus();alert(document.activeElement==button); //true;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络之数据网络层学习笔记]]></title>
    <url>%2F2018%2F03%2F15%2F%E7%BD%91%E7%BB%9C%E5%B1%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[网络层学习笔记1.网络层提供的两种服务英特网的设计思路：网络层向上只提供简单灵活的、无连接的、尽量大努力交付数据报服务。网络层不提供服务质量的承诺。好处：网络造价大大降低，运行方式灵活，能够适应各种应用。 2.网际协议IP是最重要的因特网标准协议之一，与之配套的使用的还有三个协议。 地址解析协议ARP 网际控制报文协议ICMP 网际组管理协议IGMP RARP逆地址解析协议（弃用） 2.1 虚拟互联网路不能让大家都使用相同的网络，因为用户的需求是多样的。没有一种单一的网络能够适应所有的需求。将网络互相连接起来要使用一些中间设备。 物理层使用的中间设备转发器 数据链路层使用的中间设备网桥和桥接器 网络层使用的中间设备路由器 在网络层以上使用的中间设备叫做网关。用网关连接两个不兼容的系统需要在高层进行协议的转换。 现在我们讨论网络互联时，都是指用路由器进行网络互联和路由选择。TCP/IP体系在网络互联上采用的做法是在网络层采用了标准化协议，但相互连接的网络则可以是异构的。由于参与互联的计算机网络都使用相同的网际协议IP，因此可以把互联以后的计算机网络看成一个虚拟互连网络。虚拟互联网络：即逻辑互联网络，互连起来的各种物理网络的异构性客观存在，利用IP协议就可以使这些性能各异的网路在网络层上看起来好像是一个统一的网络。总之，互联网可以由多种异构网络组成。 2.2 分类的IP地址有关IP的文档就是RFC 791. IP地址及其表示方法 IP地址就是给因特网上的每一个主机的每一个接口分配一个全世界范围内唯一的32位标识符。IP地址的编码经过了三个历史阶段 分类的IP地址 子网的划分 构成超网 分类的IP地址就是将IP地址划分为若干固定类，每一类地址都由两个固定的长度的字端组成，其中第一个字段是网络号，它标志主机所连接到的网络。第二个字段是主机号，它标记该主机。一个IP地址在整个因特网范围内。A、B、C类地址都是单播地址（一对一通信），是最常用的。 A、B、C类地址的网络号分别为1，2，3字节。而在网络号前面有1～3位类别号。分别是0，10，110。 IP地址不仅标示了一个主机，还指明了主机算连接到的网络。 IP地址都是32位，用点分计数法，每八位为一个单位。 常用的三种类别的IP地址 A类：A类地址的网络号占一个字节，可指派的网络号为2^7-2个，126个。为什么减2？因为IP中全0是个保留地址，意思是“本网络”。第二，网络号为127保留作为本地软件环回测试。A类主机号三个字节有2^24-2个。减去全0的主机号，因为它表示所连接到的单个网络地址。全1表示该网络上的所有主机。A类地址占整个空间的50%。 B类：B类地址的网络号占两个字节，前面两位固定（10），B类网络地址128.0.0.0是不指派的，可指派的最小的网络地址是128.1.0.0。所以，网络数为2^16-1。B类地址主机数2^16-2. 25% C类：三个字节的网络的字段三个字节。最前面三位（110），192.0.0.0是不指派的，所以网络号有2^21-1个。C类地址最大的主机号2^8-2. 12.5% IP地址特点： 分等级的地址结构。管理机构只分配网络号。路由器仅根据目的主机所连接的网络号来分组，减少了路由表所占存储空间以及查找路由表时间。 IP地址标志一个主机和一条链路的接口。当一个主机同时接入两个网络时，它就必须拥有两个不同的IP地址，这种主机叫多归属主机。所以路由器至少都有两个IP地址。每一个接口都有一个不同的网络号的IP地址。 用转发器或网桥连接起来的若干局域网仍为一个网络。不同网络号必须用路由器进行连接。 所有网络号的网络都是平等的。 2.3 IP地址与硬件地址 区别：物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址。IP地址放在IP数据报的首部，而硬件地址则放在MAC帧的首部，在网络层和网络层以上使用的是IP地址，而数据链路层及以下使用的是硬件地址。在数据链路层看不见数据报的地址。 需要强调的是： 在IP层抽象的互联网只能看见IP数据包。 虽然在IP数据包首部有源站IP地址，但路由器只根据目的站的IP地址的网络号进行路由选择。 在局域网的链路层，只能看见MAC帧。 IP层抽象的互联网屏蔽了下层这些很复杂的细节。 2.4 地址解析协议ARP ARP协议含义：已经知道了一个机器的IP地址，需要找出其相应的硬件地址。即从网络层的IP解析出在数据链路层使用的MAC地址。还又个叫RARP逆解析协议。 地址解析协议ARP解决IP到MAC的映射是在主机ARP高速缓存中存放一个IP地址到硬件地址的映射表，并且这个映射表还经常动态更新。 每一个主机里面都设有一个ARP高速缓存，里面有本局域网上的各主机和路由器的IP地址到硬件地址的映射表。 写入映射表的过程： ARP进程在本局域网上广播发送一个ARP请求分组 在本局域网上的所有主机上运行的ARP进程都收到此ARP请求 若主机B的IP地址与ARP请求分组中要查询的IP地址一致，就收下这个ARP请求，并向主机A发送ARP响应分组。 主机A收到主机B的ARP响应分组之后，就在其中ARP高速缓存中写入主机B的IP地址到硬件地址的映射。 ARP把保存在高速缓存中的每一个映射项目都设置生存生存时间，超过了这个时间的项目就从高速缓存中删除。 ARP解决的是同一个局域网上的主机或路由器的IP地址到硬件地址的 映射问题。 IP地址到硬件地址的解析是自动进行的。主机的用户对这种地址解析过程是不知道的。 使用ARP的四种典型情况： 主机到同网络主机 主机到异网络主机 路由器到同网络主机 路由器到异网络主机 为什么不直接使用硬件地址来通信？ 原因：由于世界上存在着各种各样的网络，他们使用不同的硬件地址，要使这些异构的网络互相通信就必须进行非常复杂的硬件地址转换工作。 2.5 IP数据报的格式一个IP数据包有首部和数据两个部分组成，首部的前一部分是固定长度，共20字节。是所有IP数据报都必须拥有的。后一部分是一些可选字段，其长度是可变的。 IP数据报首部固定部分中的各字段 版本：占4位，指IP协议版本。通信双方使用的IP协议版本必须一致。 首部长度：占4位，可表示最大十进制数为15。 区分服务：占8位，用来获得更好的服务。这个字段在旧标准中叫做服务类型。 总长度：首部和数据之和的长度，单位为字节。IP层下面的每一种数据链路协议都规定了一个数据帧中的数据字段的最大长度，这称为最大传送单元MTU。IP数据报越短，路由器转发的速度越快。为此，IP协议规定，因特网中所有的主机和路由器，必须能够接收长度不超过576字节的数据报。超过这个长度时，就要进行分片。 标示：占3位，目前只有两位有意义。标志字段中的最低位记位MF，MF=1则表示后面还有分片。MF=0则表示这已是若干数据的报片中的最后一个 片偏移：占13位，某片在原分组中的相对位置。片偏移以8个字节为偏移单位。 生存时间TTL：占8位，表明是数据报在网络中的寿命。其目的是防止无法交付的数据报无限制地在因特网中兜圈子。 协议：占8位，协议字段指出此数据报携带的数据是使用何种协议。 首部检验和：只检验数据报的首部，但不包括数据部分。 IP数据报的可变部分 就是一个选项字段，选项字段用来支持排错、测量以及安全措施，内容很丰富。最后用全0字节的填充字段补齐成为4个字节的整数倍。增加可变部分就是为了增加IP数据报的功能。 2.6 IP层转发分组的流程在互联网上转发分组时，是从一个路由器转发到下一个路由器。(目的网络地址，下一跳地址)。有如下结果： IP数据报最终一定可以找到目的主机所在目的网络上的路由器(也许要通过多次的间接交付) 只有达到最后一个路由器时，才试图向目的主机直接交付。 因特网的分组转发都是基于目的主机所在的网络。但也允许特定主机路由：即对特定的目的主机指明一个路由。采用特定主机路由可使网络管理人员能更方便的控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种方式路由器还可以采用默认路由以减少路由表所占的空间和搜索路由表所用的时间。这种转发方式在一个网络只有很少的对外连接是很有用的。 分组转发算法如下： 从数据报的首部提取目的主机的IP地址D，得出目的网络的地址为N。 若N就是与此路由器直接相连的某个网络地址，则进行直接交付。 若路由表中有目的地址为D的特定主机路由，则把数据报传给路由表中所指明的下一跳路由器。 若路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器。 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器。 报告转发分组出错。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[严格模式学习笔记]]></title>
    <url>%2F2018%2F03%2F10%2F%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[严格模式通过严格模式，可以在函数内部选择进行较为严格的全局和局部的错误条件检测。好处：可以提早知道代码中存在的错误，及时捕获一些导致编程错误的ECMAScript行为 1.选择使用要选择进入严格模式，可以使用严格模式的编译指示，实际上就是一个不会符给任何变量的字符串：“use strict”。这种语法可以向后兼容那些不支持严格模式的JavaScript引擎。 如果是在全局作用域中给出这个编译指示，则整个脚本都处于严格模式。也可以只在函数中打开严格模式。如下 1234function doSomething()&#123; "use strict" ...&#125; 2.变量在严格模式下，什么时候创建变量以及怎么创建变量都是有限制的。首先，不允许意外创建全局变量 像这样 message=&quot;hello world&quot;在严格模式下，如果给一个没有声明的变量赋值，那代码会抛出错误 其次，不能对变量调用delete操作符。非严格模式下允许这种操作，但会返回false。严格模式下抛出错误 3.对象在严格模式下操作对象比非严格模式下操作对象更容易导致错误。在开发中使用非严格模式会加大发现错误的可能性。在下列情形下操作对象的属性会导致错误。 为只读属性赋值 为不可配置的属性使用delete操作符 为不可扩展的对象添加属性 在使用对象自变量时，属性名必须唯一。 4.函数首先，严格模式要求命名函数的参数必须唯一。其次，在非严格模式下，修改命名参数的值也会反映到arguments中，而严格模式下这两个值则是保持独立 1234567function showValue(value)&#123; value="foo"; alert(value); //"foo" alert(arguments[0]); //严格模式"Hi" 非严格模式“Foo”&#125;showValue("Hi"); 另外，淘汰了arguments.callee和arguments.caller。在非严格模式下，一个引用函数本身，一个引用调用函数。最后，就是只能在脚本的顶级和函数的内部声明函数。也就是说，在if语句中声明函数会导致语法错误。 eval()eval()函数在严格模式下也得到了提升。最大的变化就是它在包含上下文中不再创建变量或者函数。 1234function doSomething()&#123; eval("var x=10"); alert(x); //非严格模式下10 严格模式下抛出错误。&#125; eval和arguments在严格模式下，禁止使用eval和arguments作为标示符。 抑制this在非严格模式下使用函数apply（）和call（）方法时，null和undefined值会被转换成全局对象。而在严格模式下，函数this的值始终是指定的值，无论指定什么值。 12345var color='red';function displayColor()&#123; alert(this.color);&#125;displayColor.call(null); //非严格模式this的值为全局对象，弹出red，严格模式下，这个this的值时null，抛出错误 其他 抛弃with语句 抛弃八进制自变量，以0开头的八进制自变量 修改parseInt()的行为。如今，八进制自变量在严格模式下会被当作0开头的十进制自变量。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象程序设计之继承]]></title>
    <url>%2F2018%2F03%2F10%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承学习笔记许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。 1、原型链 基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。过程：A.prototype=B的实例。然后这就意味着A.prototype的内部有一个内部属性[[prototype]]，这个指针指向B的原型B.prototype。如下 12345678910111213141516171819function A()&#123; this.aProperty=true;&#125;A.prototype.getAValue=function()&#123; return this.property;&#125;function B()&#123; this.bProperty=false;&#125;B.prototype=new A();B.prototype.getBValue=function()&#123; return this.bProperty;&#125;var instance=new B();alert(instance.getAValue()); //true 实现的本质是重写原型对象，用另外一个对象的实例赋值给这个原型对象。调用getAValue()会经历三个步骤：1、搜索实例。2、搜索B.prototype. 3、搜索A.prototype 1.1 默认的原型所有引用类型默认继承了Object，这个继承也是通过原型链来实现的。所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。所以上述就是，A继承了B，B继承了Object。调用instance.toString()，实际上是调用Object.prototype上的方法。 1.2 确认原型和实例的关系 调用instanceof操作符，只要用这个操作符测试实例与原型链中出现过的构造函数，结果就返回true。 123alert(instance instanceof Object); //truealert(instance instanceof A); //truealert(instance instanceof B); //true 使用isPrototypeof()方法。只要在原型链中出现过的原型，都可以说是该原型链派生的实例的原型，因此isPrototypeOf()方法也会返回true。 123alert(Object.prototype.isPrototypeOf(instance));alert(A.prototype.isPrototypeOf(instance));alert(B.prototype.isPrototypeOf(instance)); 1,3 谨慎的定义方法自类型有时候需要覆盖超类型中的某个方法，或者需要添加超类型中不存在的某个方法。给原型添加方法的代码一定要放在替换原型的语句之后。 1234567891011121314151617181920212223function A()&#123; this.aProperty=true;&#125;A.prototype.getAValue=function()&#123; return this.property;&#125;function B()&#123; this.bProperty=false;&#125;B.prototype=new A(); //替换原型的语句B.prototype.getBValue=function()&#123; //添加新方法 return this.bProperty;&#125;B.prototype.getAValue=function()&#123; //重写超类型中的方法 return false;&#125;var instance=new B();alert(instance.getAValue()); //true 使用原型链实现继承时，不能使用对象自变量创建原型方法。 1.4 原型链的问题最主要的问题来自包含引用类型值的原型。 1234567891011121314function SuperType()&#123; this.colors=['red','blue','green'];&#125;function SubType()&#123;&#125;Subtype.prototype=new SuperType();var instance1=new Subtype();instance1.colors.push('black');alert(instance1.colors); //'red','blue','green','black'var instacne2=new Subtype();alert(instance2.colors); //'red','blue','green','black' 2、借用构造函数为了解决原型中包含引用类型的值所带来的问题，可以使用一种叫做借用构造函数的技术。思路：在子类型构造函数的内部调用超类型构造函数。函数只不过是在特定环境中执行代码的对象，因此使用apply()和call()方法也可以在新创建的对象上执行构造函数。如下 1234567891011121314function SuperType()&#123; this.colors=["red","blue","green"];&#125;function SubType()&#123; SuperType.call(this); //借调了超类型构造函数&#125;var instance1=new SubType();instance.colors.push("black");alert(instance1.colors); //"red","blue","green","black"var instance2=new SubType();alert(instance2.colors); //"red","blue","green" 2.1 传递参数相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。 12345678910function SuperType(name)&#123; this.name=name&#125;function Subtype()&#123; SuperType.call(this,'Tom'); this.age=29&#125;var instance=new Subtype();alert(instance.name); //Tomalert(instance.age); //29 问题：不能避免构造函数模式的问题，方法都在构造函数中定义，因此函数复用就无从谈起。 3、组合继承将原型链和借用构造函数组合在一块。思路：使用原型链实现对原型属性和方法的基础，通过构造函数实现对实例属性的继承 1234567891011121314151617181920function SuperType(name)&#123; this.name=name; this.colors=["red","blue","green"];&#125;Supertype.prototype.sayName=function()&#123; alert(this.name);&#125;;function SubType(name,age)&#123; //继承属性 SuperType.call(this,name); this.age=age;&#125;//继承方法SubType.prototype=new SuperType();SubType.prototype.constructor=SubType;SubType.prototype.sayAge=function()&#123; alert(this.age);&#125;; 4、原型式继承借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。 12345function object(o)&#123; function F()&#123;&#125; F.prototype=o; return new F();&#125; 在这个object()函数内部，先创建了一个临时性的构造函数，然后传入的对象作为这个构造函数的原型。最后返回这个临时类型的一个新实例。从本质上说，object()对传入的对象执行了一次浅拷贝。 123456789101112var person=&#123; name: "Tom", friends: ["Tom","Court","Van"]&#125;;var anotherPerson=object(person);anotherPerson.name="Grey";anotherPerson.friends.push("Rob");var yetAnotherPerson=object(person);yetAnotherPerson.name='Linda';yetAnotherPerson.friends.push('Jay'); 这种方式必须要有一个对象作为另一个对象的基础。ECMAScript通过Object.create(新对象原型的对象，一个为新对象定义额外属性的对象)方法规范了原型式继承 1234567var person=&#123; name: "Tom", friends: ["Tom","Court","Van"]&#125;;var person1=Object.create(peron);... 5、寄生式继承与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回对象 1234567function createAnother(o)&#123; var clone=object(o); clone.sayHi=function()&#123; alert('Hi'); &#125;; return clone;&#125; 作用：在主要考虑对象而不是自定义类型的构造函数的情况下，寄生式构造函数也是一种有用的模式。 6、寄生组合式继承组合继承最大的问题就是：无论在何种情况下，都会调用两次构造函数：一次是在创建子类型原型的时候，另一次是在子类构造函数内部。 原理：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。思路：不必为了指定子类型的原型而调用超类型的构造函数，我们所需的无非就是超类型的一个副本而已。 如下 12345function inheritPrototype(subType,superType)&#123; var prototype=object(subType.prototype); //创建对象 prototype.constructor=subType; //增强对象 subType.prototype=prototype; //指定对象&#125;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络之数据链路层学习笔记]]></title>
    <url>%2F2018%2F03%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[计算机网络之数据链路层学习笔记1、使用广播信道的数据链路层广播信道可以进行一对多信道，局域网使用的就是广播信道。 1.1局域网的数据链路层 局域网特点：网络为一个单位所有，且地理范围和站点数目均有限。 局域网优点： 具有广播功能，从一个站点可以方便的访问全网。 便于系统的扩展和逐渐的演变。 提高了系统的可靠性、可用性和生存性。 局域按网络拓扑分类： 星型网 环型网 总线网 共享信道要着重考虑的一个问题就是如何使众多用户能够合理而方便的共享信通媒体资源，有两种方法： 静态划分信道 动态媒体接入控制，又称多点接入。特点：信道并非在用户通信时固定分配给用户。分为：随机接入和受控接入 为了使数据链路层更好的适应多种局域网标准，把数据链路层拆成两个字层：逻辑链路控制LLC字层和媒体接入控制子层 适配器：即网络接口卡，简称网卡。作用：负责计算机与外界局域网的连接。适配器上有处理器和存储器。适配器和局域网之间通过电缆和双绞线以串行传输方式进行。适配器与计算机通过计算机主板I/O主线以并行传输进行。适配器包含了数据链路层和物理层两层次的功能 1.2 CSDA/CD协议 载波监听多点接入/碰撞检测 总线特点：当一个站点发送数据时，总线上所有计算机都能检测到这个数据。实现一对一通信的方式：在帧首部写上接收站点位置。 为了方便通信，以太网采取了以下两种方式 无连接的工作方式。即不必建立连接就可以直接发送数据。适配器对发送的帧不进行编号，也不要求对方发回确认。以太网提供的服务是尽最大努力的交付，即不可靠交付。在同一时刻只能允许一台计算机发送数据。 以太网发送的数据都使用曼彻斯特码 CSMA/CD协议的要点 “多点接入”：说明这是总线型网络。 “载波监听”：用电子技术检测总线上有没有其他计算机也在发送。载波监听就是检测信道。不管在发送前还是在发送中，每个站都必须不停地检测信道。 “碰撞检测”：就是边发送边监听。即适配器边发送数据边检测信道上的信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。一旦发现总线上出现了碰撞，其适配器就要立即停止发送，免得进行无效发送。 电磁波在1Km电缆传播时延约5us。在使用CSMA/CD协议时，一个站不可能同时进行发送和接收。所以只能进行半双工通信。每一个站在自己发送数据后一小段时间内，存在遭遇碰撞的可能性，这一小段时间是不确定的，称为发送的不确定性。以太网端到端往返时间2t称为争用期（碰撞窗口），经过争用期还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 CSMA/CD协议过程： 准备发送：适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器缓存中。发送之前，必须检测信道。 检测信道：若检测到信道忙，则不停的检测，一直等待信道变为空闲。若检测到信道空闲，并在96比特内保持信道空闲（帧间最小间隔9.6us，相当于96比特时间），就发送这个帧。 在发送过程中仍不停的检测信道，即网络适配器要边发送边监听。两种可能性：一是发送成功，二是发送失败 2、使用广播信道的以太网2.1 使用集线器的星型拓扑 传统以太网最初使用粗同轴电缆，后来演变到比较便宜的细同轴电缆，最后发展为使用更便宜更灵活的双绞线。这种以太网采用星型结构，在中心有一个可靠性非常高的设备，叫集线器（hub） 10BASE-T双绞线以太网是星型结构，是局域网历史上一个非常重要的里程碑。 集线器的特点： 使用集线器的以太网逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA/CD协议。在同一个时刻只允许一个站发送数据。10BASE-T以太网又称为星型总线或盒中总线。 一个集线器有许多接口。因此一个集线器像一个多接口的转发器 集线器工作在物理层，它的每个接口仅仅简单的转发比特，不进行碰撞检测。 采用专门的芯片。 2.2 以太网信道利用率以太网总的信道利用率并不能达到100%。当数据率一定时，以太网的连接长度收到了限制，同时以太网的帧长不能太短。 2.3 以太网的MAC层 MAC层的硬件地址在局域网中，硬件地址又称为物理地址或MAC地址。在所有计算机系统中，标示系统都是一个核心问题。在标示系统中，地址就是为识别某个系统的一个非常重要的标示符。严格来说，名字应该与系统所在地无关，但IEEE802 规定了一种48位全球地址，是指局域网上的每一台计算机中固化在适配器的ROM中的地址。局域网上的某个主机的地址根本不可能告诉我们这台主机位于什么地方，因此，严格来说，局域网的‘地址’应当是每一个站的‘名字’或标识符。现在局域网适配器使用的都是6字节的MAC地址。MAC的前三个子节为公司标识符，后三个子节则有厂家自行指派，成为扩展标识符。一个地址块可生成2^24个不同的地址。MAC地址就是适配器地址或者适配器标识符。适配器有过滤功能，但适配器从网络上收到每一个MAC帧就先用硬件检测MAC帧中的目的地址，如果是发往本站的帧则收下，然后再进行其他的处理。否则将此帧丢弃。发往‘本站的帧’包括以下三种帧：单播帧、广播帧、多播帧，所有适配器都至少识别单播和多播地址，只有目的地址使用广播地址和多播地址。 MAC帧格式有两种标准，一种是以太网标准，另一种是IEEE的802.3标准。第一种最常用。以太网v2标准由5个字段组成，前两个字段分别为6字节长的目的地址和源地址字段第三个字段是2字节的类型字段，用来表示上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层这个协议。第四个字段为数据字段，长度为46到1500字节之间。最后一个字段是4字节的帧检测序列FCS。当数据字段小于64字节时，MAC字层就会在数据字段的后面加上一个整数字段的填充字段，以保证以太网的MAC帧长不小于64字节。因此上层协议必须具有识别有效的数据字段的功能在传输媒体（物理层）上实际传输的要比MAC帧还多8字节。目的是为了接收端迅速实现同步。这8个字节的组成：第一个字段是7个字节的前同步码，作用是使接收端的适配器在接收MAC帧时能迅速调整时钟频率，使他和发送端时钟同步，第二个字段是帧开始定界符，定义为10101011。MAC帧的FCS字段的检验范围不包括前同步码和帧开始界定符。以太网不需要帧结束界定符，也不需要字节来保证透明传输。 扩展以太网这种扩展的以太网在网络层看来仍然是一个网络。 在物理层扩展以太网 现在，扩展以太网和集线器之间的距离一种简单的方法就是使用光纤和一对光线解调器。缺点：碰撞域扩大；如果使用不同以太网技术，那么就不可能用集线器将它们互联起来。 在数据链路层扩展以太网 在数据链路层扩展以太网要使用网桥，网桥工作在数据链路层，它根据MAC帧的目的地址对收到的帧进行转发和过滤。 网桥内部结构 两个以太网通过网桥来连接时，就成为一个覆盖更大的以太网，而原来的每个以太网就可以称为一个网段。网桥依靠转发表来转发帧，转发表也叫做转发数据库和路由目录。转发表的好处： 1.过滤通信量，增大吞吐量 2.扩大了物理范围 3.提高可靠性 4.可互联不同物理层，不同MAC字层和不同速率 缺点： 1.增加了延时 2.没有流量控制功能 3.用户数太多和通信量太大会导致广播风暴 透明网桥 目前使用最多的网桥，透明是指以太网上的站点都看不见以太网上的网桥，透明网桥还是一种即插即用设备 当网桥刚刚连接到以太网时，其转发表是空的。网桥收到一个帧就会按照自学习的算法处理收到的帧。网桥每收到一个帧，就记下其源地址和进入网桥的接口。转发表中，没有源地址这一栏，只有地址这一栏。建立转发表时是把帧首部的源地址写在地址栏里，在转发帧时，是根据收到的这首部中的目的地址来转发的，这时地址栏下面把记录的源地址当作目的地址 网桥的子学习和转发帧：网桥收到一段帧后先进行自学习，查找转发表中有与收到帧的源地址有无相匹配的项目。转发帧，查找转发表中与收到的目的地址有无向匹配的项目。如没有，则通过所有其他接口进行转发。如有，则按转发表中给出的接口进行转发。若转发表中给出的接口就是该帧进入的接口，则丢弃该帧。 源路由网桥 源路由网桥是在发送帧时，把详细的路由信息放在帧首部中。 多接口路由–以太网交换机 交换式集线器又称为交换机或第二层交换机，表明这种交换机工作在数据链路层。交换机实质上就是一个多接口的网桥。使每一对相互通信的主机都能像独占传输设备那样，无碰撞的传输数据。以太网交换机对收到的帧采用存储转发和直通的方式 以太网可以实现虚拟以太网VLAN。VLAN：由一些局域网网段构成与物理位置无关的工作组，而这些网段具有某种共同的需求。VLAN其实是给用户提供一种服务，而不是一种新型局域网。虚拟局域网上的每个站都可以收到同一个局域网上的其他成员所发出的广播，即使他们没有连接在同一个以太网交换机上。它可以限制接收广播的工作站数，抑制广播风暴。虚拟局域网允许在以太网的帧格式中插入一个4字节的表示符，称为VLAN标记，用来指明发送该帧的工作站属于哪一个虚拟局域网。插入在MAC帧的源地址和字段和类型字段之间。 3.高速以太网 100BASE-T以太网 在全双工方式下工作而无冲突发生，此方式下CSMA/CD不起作用。 吉比特以太网 有全双工和半双工两种方式工作。 10吉比特和100吉比特 只工作在全双工方式。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象程序设计之对象]]></title>
    <url>%2F2018%2F03%2F05%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[面向对象程序设计学习笔记1.理解对象创建自定义对象最简单的方式就是创建一个Object的实例，再给他加上方法和属性 123456var person = new Object();person.name="Tom";person.age=29;person.sayName=function()&#123; alert(this.name);&#125;; 还有一种就是创建对象自变量。 1234567var person=&#123; name: "Tom", age: 29, sayName: function()&#123; alert(this.name); &#125;&#125;; 1.1属性类型只有内部才用的特性时（attribute），描述了属性（property）的各种特征。在JavaScript中不能直接访问它们。为了表示特性是内部值，用[[attribute]]表示ECMAScipt有两种属性：数据属性和访问器属性。 数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性 [[Configurable]]: 表示能否通过delete删除属性重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。默认为true。 [[Enumerable]]: 表示能否通过for-in循环返回属性。默认true [[Writable]]: 能否修改属性的值。默认true [[Value]]: 包含这个属性的数据值。读取属性值时，从这个位置读；写入属性值时，把新值保存到这个位置。默认undefined。 要修改属性的默认特性，就必须使用Object.defineProperty()方法。接收三个参数：属性所在对象、属性名字、一个描述符对象。其中，描述符对象的属性必须是：Configurable,Enumerable,Writable,Value. 12345678var person=&#123;&#125;;Object.defineProperty(person,'name',&#123; Writable: false, Value: 'Tom',&#125;);alert(person.name); //"Tom"person.name='gray';alert(person.name); //"Tom" 把configurable设置为false，表示不能从对象中删除属性。如果调用delete，在非严格模式下什么也不会发生，在严格模式下跑出错误。而且一旦把属性定义为不可配置时，就不能再把他变为可配置属性了。在调用defineProperty()方法修改除Writable之外的特性，都会发生错误。 12345678910111213var person=&#123;&#125;;Object.defineProperty(person,'name',&#123; Configurable: false, Value: 'Tom',&#125;);alert(person.name); //Tomdelete person.name;alert(person.name); //TomObject.defineProperty(person,'name',&#123; Configurable: true, //抛出错误 Value: 'Tom'&#125;); 用Object.defineProperty()方法创建一个新属性时，如果不指定，Configurable，Writable，Enumerable默认为false。 访问器属性 [[Configurable]]: 同上 [[Enumerable]]: 同上 [[Set]]:在写入属性时调用的函数。默认undefined。 [[Get]]:在读取属性时调用的函数。默认undefined。 访问器属性不包含数据值，他们包含一对getter和setter函数。在读取访问器属性时，调用getter()。设置访问器属性时，调用setter()并传入新值。访问器属性不能直接定义，必须使用Object.defineProperty()来定义。 123456789101112131415161718var book=&#123; _year: 2004, edition: 1, &#125;; Object.defineProperty(book,&quot;year&quot;,&#123; get: function()&#123; alert(this._year); &#125;, set: function(newValue)&#123; if(newValue&gt;2004)&#123; this._year += newValue; this.edition += newValue-2004; &#125; &#125;, &#125;);book.year=2008;alert(book.edition); 只定义getter意味着属性是不能写，尝试写入属性会被忽略。类似的，只定义setter函数的属性也不能读。 1.2定义多个属性利用Object.defineProperties()方法。 12345678910111213141516171819202122var book=&#123;&#125;;Object.defineProperties(book,&#123; _year:&#123; writable:true, value:2004, &#125;, edition:&#123; writable:true, value:1, &#125; year:&#123; get:function()&#123; return this._year; &#125;, set:function(newValue)&#123; if(newValue&gt;2004)&#123; this._year += newValue; this.edition += newValue-2004; &#125; &#125; &#125;&#125;); 1.3读取属性特性利用Object.getOwnPropertyDescriptor()。接收两个参数：属性所在的对象和读取其描述符的属性名称。返回的是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get、set；如果是数据属性，这个对象的属性有configurable、enumerable、writable、value。 1var descripter=Object.getOwnPropertyDescriptor(book,"_year"); 2.创建对象虽然Object构造函数和对象自变量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量重复的代码。 2.1 工厂模式用函数来封装以特定接口创建对象的细节，如下 12345678910function createPerson(name,age,job)&#123; var o=new Object(); o.name=name; o.age=age; o.job=job; o.sayName=function()&#123; alert(this.name); &#125;; return o;&#125; 工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题，即怎样知道一个对象的类型。 2.2构造函数模式可以用构造函数创建自定义构造函数，从而定义自定义对象类型的属性和方法。构造函数始终都应该以一个大写字母开头。构造函数也是函数，只不过可以用来创建对象而已。如下 1234567891011function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=function()&#123; alert(this.name); &#125;;&#125;var person1=new Person('zhang',21,"teacher");var person2=new Person('he',20,'Doctor'); 与工厂模式的不同： 没有显式的创建对象 直接将方法和属性赋值给了this对象 没有return 创建Person的新实例，必须使用new操作符。以这种方式调用构造函数会经历四个步骤： 创建一个新对象 将构造函数的作用域赋值给新对象（因此this就指向这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 person1和person2分别保存着Person的一个不同的实例。这两个对象都有一个constructor属性，该属性指向Personperson.constructor==Person //true也可以用instanceof操作符可以得到验证person1 instanceof Person //true。创建自定义构造函数意味着将来可以将它的实例标示为一种特定的类型，优于工厂模式。 1，构造函数问题构造函数与其他函数的区别，就是调用方式不同。任何函数使用new 操作符调用，那他就可以作为构造函数，而不通过new调用则就是普通函数。 123456789101112//作为构造函数var person=new Person('Tom',29,'teacher');person.name //Tom//作为普通函数使用Person('Tom',29,teacher);window.name //Tom//在另一个对象中调用var o=new Object();Person.call(o,'Tom',29,teacher);o.name //'Tom' 2.构造函数问题构造函数的问题就是：每个方法都要在每个实例上再创建一遍。不同实例上的同名函数是不一样的。可以把函数定义转移到构造函数外部进行定义。 2.3原型模式我们创建的每个函数都有一个prototype属性。这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的方法和属性。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。 1234567891011function Person()&#123;&#125;Person.prototype.name='Tom';Person.prototype.age=29;Person.prototype.job='teacher';Person.prototype.sayName=function()&#123; return this.name;&#125;;var person1=new Person();var person2=new Person();alert(person1==person2); //true 1.理解原型对象无论什么时候，一个新函数有一个prototype属性，该属性指向函数的原型对象，原型对象又包含一个constructor属性，这个属性是一个指针，指向新函数。Person.prototype.constructor指向Person。当调用构造函数创建一个新实例的时候，该实例内部有一个属性(内部属性)，叫[[prototype]]。在Safari、Firefox、Chrome对象上都支持一个属性proto。 proto这个连接存在于实例和原型对象之间，不存在于实例与构造函数之间。可以通过isPrototypeOf()方法来确定对象之间是否存在这种联系。 注：可以通过对象实例访问原型中的值，但不能通过对象实例修改原型中的值。当为实例添加一个属性时，就会屏蔽原型对象上的同名属性，可以通过delete删除实例上的属性，从而恢复对原型对象上的属性的访问。 用hasOwnProperty(属性名)方法可以判断一个属性是否存在于实例中，还是存在于原型中。当属性存在于实例中返回true。 2.原型与in操作符单独使用in时，会在通过对象能够访问给定属性时返回true，无论属性在对象实例中还是原型中。alert(&#39;name&#39; in person1)。 可以根据hasOwnProperty()和in一起确定属性是否存在于原型链中。如下 123function isPrototypeProperty(obj,name)&#123; return !obj.hasOwnProperty(name)&amp;&amp;(name in obj);&#125; for-in可以返回存在于实例中的属性和存在于原型中的属性，即使原型中不可枚举的属性（即将把[[Enumerable]]设置为false的属性）也会在for-in循环中返回。 Object.keys(对象)，返回一个包含所有可枚举属性字符串的数组。作用：取得对象上所有可枚举的实例属性。是实例上的属性，不包括原型链上的。要取得所有的属性可以使用Object.getOwnPropertyNames() 3.更简洁的语法12345678910function Person()&#123;&#125;Person.prototype=&#123; name:'Tom', age:29, job:teacher, sayName:function()&#123; alert(this.name); &#125;&#125;; 这种语法中，将对象自变量直接赋给原型对象。使用这种方法出现了一个问题，即Person.prototype.constructor不在指向Person，而指向了Object。因为我们完全重写了prototype对象，因此constructor也变成了新的constructor，不再指向Person函数。为了解决这个问题，可以有以下两种修改方法 1234567891011function Person()&#123;&#125;Person.prototype=&#123; constructor: Person, name:'Tom', age:29, job:teacher, sayName:function()&#123; alert(this.name); &#125;&#125;; 以上面这种方式设置constructor会导致其变为可枚举的，默认情况下，它是不可枚举的所以也可以通过下述方法改进。 1234Object.defineProperty(Person.prototype,'constructor',&#123; Enumerable: false, value: Person&#125;); 4.原型的动态性由于原型查找值的过程是一次搜索，因此我们对原型的任何修改都可以体现在实例上，即使我们在创建实例后修改原型也可以立刻体现到实例中。 5.原型对象的问题最大的问题是由共享的本性所导致的。对于引用类型值的属性来说，问题就比较突出了。 12345678910111213141516171819function Person()&#123;&#125;Person.prototype=&#123; constructor: Person, name:'Tom', age:29, job:teacher, friends:["Jane","Jay"], sayName:function()&#123; alert(this.name); &#125;&#125;;var person1=new Person();var person2=new Person();person1.friends.push('Van');alert(person1.friends); //"Jane","Jay","Van"alert(person2.friends); //"Jane","Jay","Van" 修改了一个可以从另外一个实例中反映出来。 2.4组合使用构造函数模式和原型模式创建自定义类型最常见的方式。构造函数模式用于定义实例属性，而原型模式用于定义共享属性。结果就是，每个实例都会有自己的一份实例属性的副本。但同时又共享着对方法的引用，最大限度的节省内存。此外还支持构造函数传递参数 123456789101112131415161718function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.friends=["Tom","Jay"];&#125;Person.prototype=&#123; constructor: Person, sayName: function()&#123; alert(this.name); &#125;&#125;var person1=new Person("Jucy",29,"Engineer");var person2=new Person("Greg",27,"Doctor");person1.friends.push("Kobe"); alert(person1.friends) //"Tom","Jay","Kobe"alert(person2.friends) //"Tom","Jay" 2.5 动态原型模式它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型，又保持了同时使用构造函数和原型的优点。也就是，可以通过检查某个应该存放的位置是否有效，来决定是否需要初始化原型。 12345678910function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; if(typeof sayName != 'function')&#123; person.prototype.sayName=function()&#123; alert(this.name); &#125;; &#125;&#125; 2.6 寄生构造函数模式基本思想：创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。 1234567891011function Person(name,age,job)&#123; var o=new Object(); o.name=name; o.age=age; o.job=job; o.sayName=function()&#123; alert(this.name); &#125;; return o&#125;var person=new Person('Tom',29,'teacher'); 除了使用new操作符并把使用的包装函数叫做构造函数以外，这个模式和工厂模式是一模一样的。 2.7 稳妥构造函数稳妥对象：没有公共属性，而且其方法也不引用this对象。最适合一些安全的环境中。与寄生构造函数的不同：1、不使用this。 2、不使用new操作符调用构造函数。 12345678910111213function Person(name,age,job)&#123; var o=new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName=function()&#123; alert(name); &#125;; //返回对象 return o;&#125;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax和Comet学习笔记]]></title>
    <url>%2F2018%2F03%2F01%2FAjax%E5%92%8CComet%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Ajax和Comet的学习笔记 按着js高级程序设计的步骤进行笔记记录～～ ajax：Asynchronous JavaScript+XMLajax的核心技术：XMLHttpRequest对象。 1.XMLHttpRequest对象建立：var xhr=new XMLHttpRequest(); (不考虑兼容IE7之前的版本)。 1.1 XHR用法 要调用的第一个方法就是open(),接受3个参数：1、要发送请求的类型（“post”，“get”等）、请求的URL、是否异步发送请求的bool值 xhr.open(&quot;get&quot;,&quot;example.php&quot;,false) 说明：1.url相对于执行代码的当前页面2.调用open方法并不会发送请求，而是启动一个请求已备发送。 要发送特定的请求，必须像这样调用send(),xhr.send(null).send()方法接受一个参数，即要作为请求主体发送的数据。如果不需要请求主体发送数据，则必须传入null。这次请求是同步的，js代码会等到服务器响应之后再继续执行。在收到响应后，响应的数据会自动填充XHR对象的属性,相关属性如下： responseText: 作为响应主体被返回的文本。 responseXML: 如果响应的内容类型是“text/xml”或者“application/xml”，这个属性将保存着包含响应数据的XML DOM文档。 status：响应的HTTP状态。 statusText：HTTP状态的说明 过程：第一步：检查status的状态，以确定响应已经成功返回。一般来说，HTTP的状态码为200时，可以作为成功的标志。这时候，responseText属性的内容已经就绪，在内容正确的情况下responseXML也能访问了。状态码为304时表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本。这时候的响应也是有效的。可以像下面这样肩检查两种状态码。 12345if( (xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300)||xhr.status==304 )&#123; alert(xhr.responseText);&#125;else&#123; alert("request is unsucessful" +xhr.status);&#125; 通过检测status来决定下一步操作。另外，无论内容类型是什么，响应主体都会保存到responseText中；而对于非XML数据来说，responseXML属性将设置为null。 上述是发送同步请求，多数情况下，我们还是要发送异步请求，才能让JavaScript继续执行而不必响应等待。通过检测XHR对象的readyState属性，该属性表示请求/响应过程的当前活动阶段。这个属性可取： 0:未初始化。尚未调用open()方法。 1:启动，已经调用open()方法，但未调用send()方法。 2:发送，已经调用send()方法，但未接收到响应。 3:接收，已经接收到部分响应数据。 4:完成，已经接收到全部数据，而且可以在客户端使用了 只要readyState属性的值由一个值变为另一个值，都会触发一次readystatechange事件。可以利用这个事件来检测每次状态变化后readyState值。一般只对readyState的值为4的阶段感兴趣，因为这时的所有元素都已经就绪。不过，必须在调用open()之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性。 12345678var xhr=new XMLHttpRequest();xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; //code.... &#125;&#125;;xhr.open("get","example.php",true);xhr.send(null); 1.2 HTTP头部信息每个HTTP请求和响应都会带有相应的头部信息。XHR对象也提供了操作这两种头部（请求头部和响应头部）信息的方法。 请求头部：默认情况下，在发送XHR请求的同时，还会发送下列头部信息： Accept：浏览器能够处理的内容类型。 Accept-Charset：浏览器能够显示的字符集。 Accept-Encoding：浏览器能够处理的压缩编码。 Accept-Language：浏览器当前设置的语言。 Connection: 浏览器与服务器之间连接的类型。 Cookie：当前页面设置的任何cookie。 Host：发出请求的页面所在的域。 Refer：发出请求的页面的url。 User-Agent：浏览器的用户代理字符串。 使用setRequestHeader()方法可以设置自定义的请求头部信息。接收两个参数：1、头部字段的名称。 2、头部字段的值。 必须在调用open方法之后，send方法之前调用setRequestHeader()。 123456789var xhr = new XMLHttpRequest();xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; //.... &#125;&#125;;xhr.open("get","example.php",true);xhr.setRequestHeader("MyHeader","MyValue");xhr.send(null); 响应头部： 调用XHR对象的getResponseHeader()方法并传入头部字段名称，可以取得相应的响应头部信息。 调用XHR对象的getAllResponseHeaders()方法则可以取得一个包含所有头部信息的长字符串。 12var myHeader=xhr.getResponseHeader('MyHeader');var allHeaders=xhr.getAllResponseHeader(); getAllResponseHeaders()方法通常会返回如下所示的多行文本内容： 123456Date: ..Server: ..Vary: ..X-Power-By: ..Connection: ..Content-type: .. 1.3 GET请求GET是最常见的请求类型，最常用于向服务器查询某些信息。可以将查询字符串参数追加到URL的末尾，以便将信息发送给服务器。对XHR而言，位于传入open()方法的URL末尾的查询字符串必须经过正确的编码才行。使用get请求经常会发生一个错误，就是查询字符串格式有问题。查询字符串的每个参数的名称和值都必须使用encodeURIComponent()进行编码。 先解释下encodeURIComponent(URIstring)的作用以及用法。 1. 作用：函数可把字符串作为 URI 组件进行编码。&lt;br&gt; 2. 说明：该方法不会对ASCII字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * &apos; ( ) 。 其他字符（比如 ：;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。 下面这个函数可以辅助向现有URL的末尾添加查询字符串参数： 12345function addURLParam(url,name,value)&#123; url+= (url.indexOf("?")==-1 ? "?" : "&amp;"); url+= encodeURIComponent(name)+"="+encodeURIComponent(value); return url;&#125; 1.4 POST请求post通常用于向服务器发送应该被保存的数据。post请求应该把数据作为请求的主体来提交，而get请求传统上不是这样。post请求的主体可以包含非常多的数据，而且格式不限。用法: 第一步： xhr.open(&quot;post&quot;,&quot;example.php&quot;,true) 第二步： 向send()方法传入某些数据。 默认情况下，服务器对POST请求和提交Web表单请求并不会一视同仁。因此服务器端必须有程序来读取发送过来的原始数据，并从里面解析出有用的部分。可以利用XHR来模仿表单提交：首先将Content-Type头部信息设置为application/x-www-form-urlencoded，也就是表单提交时的内容类型。其次是以适当的格式创建一个字符串。 2.XMLHttpRequest2级2.1 FormData现代Web应用中频繁使用的一项功能就是表单数据的序列化，XMLHttpRequest2定义了FormData类型。作用：为序列化表单以及创建与表单格式相同的数据提供了便利。 12var data=new FormData();data.append('name','Nicholas'); 两个参数分别对应表单字段的名字和字段包含的值。向FormData构造函数传入表单元素，也可以用表单元素的数据预先向其中填入键值对：var data=new FormData(document.forms[0]);。创建FormData可以直接把它传入send()中。xhr.send(new FormData(form)). 2.2 超时设定XHR对象添加了一个timeout属性，表示请求在等待响应多少毫秒之后就终止。给timeout设置一个数值后，如果在规定的时间内浏览器还没有接收到响应，那么就会触发timeout事件，进而会调用ontimeout事件处理程序。 2.3 overridMimeType() 方法用于重写XHR响应的MIME类型 3.进度事件定义了与客户端服务器通信有关的事件。有以下6个进度事件。 loadstart：在接收到响应数据的第一个字节时触发。 progress：在接收响应期间持续不断地出发。 error：在请求发生错误时触发。 abort：调用abort()方法而终止连接时触发。 load：在接收完整的响应的触发。 可以替代readystatechange事件。 loadend：在通信完成或者在触发error、abort、load事件后触发。 过程：先触发loadstart,然后是一个或多个progress事件，然后是error、abort、load其中一个被触发，最后触发loadend事件。 4.跨域源资源通过XHR实现Ajax通信的一个主要限制就是跨域安全策略。在默认情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。CORS定义了在必须访问跨域资源时，浏览器和服务器应该如何沟通。CORS背后的基本思想，就是使用自定义的http头部让浏览器与服务器进行通信，从而决定请求或响应是否成功或失败。Origin:http://www.nczonline.net IE对CORS的实现 IE8引入XDR（XDomainRequest）类型。这个对象与XHR类似，但能实现安全可靠的跨域通信。XDR和XHR不同之处： cookie不会随请求发送，也不会随响应返回 不能访问响应头部信息 只支持GET和POST请求 只能设置请求头部信息中的Content-type 其他浏览器对CORS的实现都通过XMLHttpRequest对象实现了对CORS的原生支持。在尝试打开不同来源的资源，无需额外编写代码就可以触发这个行为。方法：使用标准的XHR对象并在open()方法中传入URL即可。例如 123456789101112var xhr=new XMLHttpRequest();xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; if((xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300) || xhr.status==304)&#123; alert(xhr.responseText); &#125;else&#123; alert("Request was unsucessful"+xhr.status); &#125; &#125;&#125;;xhr.open("get","http://www.somewhere-else.com/page/",true);xhr.send(null); 与IE的XDR对象不同，通过跨域XHR对象可以访问status和statusText属性，而且支持同步请求。跨域对象也有一些限制，如下： 不能使用setRequestHeader()设置自定义头部。 不能接受和发送cookie 调用getAllResponseHeader()方法总会返回空字符串。 Preflighted ReqeustsCORS通过一个叫做Preflighted Requests的透明服务器验证机制支持开发人员使用自定义的头部、GET或POST之外的方法，以及不同类型的主体内容。在使用高级选项来发送请求时，就会向服务器发送一个Preflight请求。这种请求使用OPTIONS方法，发送下列头部 跨浏览器的CORS所有浏览器都支持简单的请求，因此有必要实现一个跨浏览器的方案。检测XHR是否支持CORS的最简单的方式，就是检查withCredentials属性。再结合检测XDomainRequest对象是否存在，就可以检测所有浏览器了。 12345678910111213141516171819function createCORSRequest(method,url)&#123; var xhr=new XMLHttpRequest(); if("withCredentials" in xhr)&#123; xhr.open(method,url,true) &#125;else if(typeof XDomainRequest != "undefined")&#123; xhr = new XDomainRequest(); xhr.open(method,url); &#125;else&#123; xhr = null; &#125; return xhr;&#125;var request=createCORSRequest("get","http://www.somewhere-else.com/page/");if(request)&#123; request.onload=function()&#123; //对request.responseText进行处理 &#125; request.send();&#125; 5.其他跨域技术图像Ping使用标签，一个网页可以从任何网页中加载图像，不用担心跨不跨域。可以动态的创建图像，使用它们的onload和onerror事件处理程序来确定是否接收到了响应。图像Ping：是与服务器进行简单、单项的跨域通信的一种方式。通过图像Ping，浏览器得不到任何具体数据的数据，但通过监听load和error事件，它能知道响应是什么时候接收的。 12345var img=new Image();img.onload=img.onerror=function()&#123; alert("Done!");&#125;;img.src="http://www.example.com/test?name=Tom"; 图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。 JSONPJSONP：JSON with padding(填充式JSON或参数式JSON)，是应用JSON的一种新方式，JSONP和JSON差不多，只不过是包含在函数调用的JSON，callback({&quot;name&quot;:&quot;Tom&quot;});JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面调用的函数。回调函数的名字一般在请求中指定。而数据就是传入回调函数的JSON数据。典型的JSONP请求http://freegeoip.net/json/?callback=handleResponse。JSONP是通过动态创建script元素来使用的 123456function handleResponse(response)&#123; alert("Your Ip is"+response.ip+", which is in"+response.city);&#125;var script=document.createElement('script');script.src="http://freegeoip.net/json/?callback=handleResponse";document.body.insertBefore(script,document.body.firstChild); 优点：1.双向通信。2、可以访问响应文本。3、简单易用缺点：1.从其他域加载执行代码，不安全。2、确定请求是否失败并不容易。 Comet更高级的Ajax技术（也叫服务器推送）。Ajax是一种页面向服务器请求数据的技术，而Comet则是一种服务器向页面推送数据的技术。能够使信息实时地被推送到页面上。实现Comet有两种方式：长轮询和流。 短轮询：即浏览器定时向服务器发送请求，看有没有数据更新长轮询：页面发起一个到服务器的请求，然后服务器一直保持连续打开，直到有数据可以传送。发送完数据后，浏览器关闭连接，随即又发起一个到服务器的新请求。 HTTP流。他在页面的整体生命周期内只使用一个HTTP连接。就是浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性的向浏览器发送数据。可以通过监听readystatechange事件以及readyState的值是否为3，就可以利用XHR对象实现HTTP流。随着不断从服务器接收数据，readyState周期性的变为3，当readyState变为3时，responseText属性中就会保存接收到的所有数据。此时，需要比较此前接收到的数据，决定从什么位置开始取得最新的数据。实现如下 123456789101112131415161718function createStreamingClient(url,progress,finished)&#123; var xhr=new XMLHttpRequest(), receive=0; xhr.onreadystatechange=function()&#123; var result; if(xhr.readyState==3)&#123; result=xhr.reponseText.substring(received); received+=result.length; progress(result); &#125;else if(xhr.readyState==4)&#123; finished(xhr.responseText); &#125; &#125;; xhr.open("get",url,true); xhr.send(null); return xhr;&#125; Web SocketsWeb Sockets目标：在一个单独的持久连接上提供全双工、双向通信。过程：在JavaScript创建了Web Sockets之后，会有一个HTTP请求发送到浏览器以发起连接。在取得服务器响应之后，建立的连接会使用HTTP升级从HTTP协议交换为Web Socket协议。URL的模式也略有不同。未加密的连接是ws://，加密的连接是wss://。不是http://和https://好处：能够在客户端和服务器之间发送非常少的数据，而不必担心HTTP那样子节级的开销。非常适合移动应用。 1.Web Sockets API要创建web sockets，先实例一个WebSocket对象并传入要连接的URL：var socket=new WebSocket(&quot;ws://www.example.com/server.php&quot;)。必须给WebSocket构造函数传入绝对的URL。可以通过它打开到任何站点的连接。 实例化WebSocket对象后，浏览器就会马上尝试创建连接。与XHR相似，WebSocket也有一个表示当前状态的readyState属性。这个属性的值和XHR并不相同 WebSocket.OPENING(0): 正在建立连接 WebSocket.OPEN(1): 已经建立连接 WebSocket.CLOSING(2): 正在关闭连接 WebSocket.CLOSE(3): 已经关闭连接 WebSocket没有readystatechange事件；不过他有其他事件，对应不同状态，readyState的值永远都从0开始。要关闭Web Socket连接，可以在任何调用close方法().socket.close() 2.发送和接收数据使用send()方法并传入任意字符串，例如： 12var socket=new WebSocket("ws://www.example.com/server.php");socket.send("hello world"); WebSockets只能通过连接发送纯文本数据，所以对于复杂的数据结构，在发送之前，必须进行序列化。 当服务器向客户端发来消息时，WebSocket对象会触发message事件。这个message事件与其他传递消息的协议类似，也就是把返回的数据保存在event.data中。 12345socket.onmessage=function(event)&#123; var data = event.data; //处理数据&#125; 3.其他事件 open:在成功建立时触发 error：发生错误时触发 close：关闭连接时触发]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量、作用域和内存问题学习笔记]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[变量、作用域和内存问题学习笔记 之前学习过一遍，考完研发现记得不是很清楚😂，重新看了一遍js高程，在这里记录下自己的学习心得和薄弱环节～～ 1.基本和引用类型的值基本类型：简单的数据段，五种基本类型：Undefined,Null,Boolean,String,Number引用类型：是保存在内存中的对象 1.动态属性对于引用类型，我们可以为其添加属性和方法。对于基本类型变量，不能添加属性，虽然不会报错。 2.复制变量值基本类型：会在变量对象创建一个新值，然后把该值复制到为新变量分配的位置上。两个变量不会互相影响。 引用类型：同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。复制操作结束后，两个变量实际上引用同一个对象。改变其中一个变量，会影响另一个变量。 3.传递参数所有函数都是按值传递的。基本类型值的传递如同基本类型变量的复制一样。而引用类型值的传递，则如同引用类型变量的复制一样。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数外部。 1234567891011121314151617//基本类型function add(num)&#123; num+=10; return num;&#125;var count=20;var result=addTen(count);alert(count); //20,没有变化alert(result); //30//引用类型function setName(obj)&#123; obj.name="Tom";&#125;var person=new Object();setName(person);alert(person.name) //Tom 4.检测类型 1、typeof：检测一个变量是不是基本数据类型。检测基本类型时使用他，检测引用类型时用处不大。 注意：typeof null等于object 2、instanceof：在检测一个引用类型和Object构造函数时，instanceof操作符始终返回true。instanceof检测基本类型的值时，该操作符始终返回false。 2.执行环境及作用域执行环境时JavaScript最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之被销毁。每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将环境弹出，把控制权返回给之前的执行环境。当代码在一个环境中执行，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域的前端，始终都是当前执行的代码所在环境的变量对象。下一个变量来自外部环境，一直延续下去；全局执行环境的变量对象始终都是作用域链中的最后一个对象。标识符解析：是沿着作用域链一级一级搜索标示符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止。 1234567891011121314var color="blue";function changeColor()&#123; var anotherColor="red"; function swapColors()&#123; var tempColor=anotherColor; anotherColor=color; color=tempColor; //这里可以访问color、anotherColor、tempColor &#125; //这里可以访问color、anotherColor，不能访问tempColor。 swapColors();&#125;//这里只能访问color 延长作用域链：有些语句可以在作用域的前端临时加一个变量对象，该变量对象会在代码执行后被移除。以下两个语句会使作用域链得到加长。1、try-catch语句的catch块2、with语句 指定对象添加到作用域链中 3.垃圾收集js具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。原理：找出那些不再使用的变量，然后释放其占用的内存。垃圾收集器必须跟踪哪个变量有用，哪个变量没用，对于没用的变量打上标记，以便回收。具体有两个策略 3.1 标记清除最常用的垃圾收集方式。当变量进入环境时，就将这个变量标记为“进入环境”。离开环境时，将其标记为“离开环境”。过程：1、垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记。2、它会去掉环境中的变量以及被环境中的变量引用的变量的标记。 3、然后在此之后再被加上标记的变量将被视为准备删除的变量。4、最后垃圾收集器完成内存清除工作。 3.2 引用计数原理：跟踪记录每个值被引用的次数。过程：1、当声明了一个变量，并将一个引用类型值赋给该变量，则这个值的引用次数就是1.2、如果同一个值又被赋给另一个变量，该值的引用次数加1.3、假如包含这个值引用的变量又取得了另外一个值，则这个值的引用次数减1.4、如归该值的引用次数变为0，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。 3.3 性能问题垃圾收集器是周期运行的。确定垃圾收集器的时间间隔是一个非常重要的问题。 3.4 管理内存最主要问题：分配给web浏览器的可用内存数量通常要比分配给桌面应用程序的少。目的：为了防止javascript的网页耗尽全部内存而导致系统崩溃。优化内存占用的最佳方式：就是为执行中的代码保存必要的数据，一旦数据不在有用，最好通过将其设置为null，这个做法叫做解除引用。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引用类型之Function类型学习笔记]]></title>
    <url>%2F2018%2F02%2F26%2FFunction%E7%B1%BB%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Function类型函数实际上是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。由于函数名仅仅是指向函数的指针，一个函数可能会有多个名字。 函数定义的三种方式：1、函数声明 2、函数表达式 3、使用Function构造函数 var sum=new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1+num2&quot;). 1.没有重载可以将函数名想象为指针来理解为什么没有重载。如下 1234567function sum(num)&#123; return 30+num;&#125;function sum(num)&#123; return 40+num;&#125;sum(20) //60 以上代码输出60，说明第二次函数声明覆盖了第一次函数声明，这就说明了函数没有重载，以上代码等价于下面代码 123456var sum=function(num)&#123; return 30+num;&#125;;sum=function(num)&#123; return 40+num;&#125;; 切记：函数名只是指向函数对象的指针 2.函数声明和函数表达式 区别：解析器会首先读取函数声明，使任意代码都可以使用；而函数表达式则要等到执行到该代码行才会被解析。 3.作为值的函数 因为函数名本身就是变量，所以函数也可以作为值来使用。意思是，1、函数可以作为另一个函数的参数 2、函数可以作为一个函数的返回值 4.函数内部属性 在函数内部有两个特殊的对象：arguments和this。arguments是一个类数组对象，保存着函数所有参数。 arguments对象只是与数组类似，它并不是Array的实例。 123function sayhi()&#123; return arguments[0]+','+arguments[1];&#125; 以上代码不包含命名的参数，但函数功能依旧。这说明了ECMAScript函数的一个重要特点：命名的参数只提供便利，但不是必须的。arguments的length属性表示参数的个数。另外arguments对象可以和命名参数一起使用。最后，没有传递值的命名参数将自动被赋予undefined的值，跟定义了变量未初始化一样。 arguments还有个特殊的属性callee：该属性是一个指针，指向拥有这个arguments对象的函数。使用如下 1234567function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else( return num*factorial(num-1); )&#125; 上面代码将函数和函数名紧密地联系在了一起，如果将该函数名赋值给另外一个变量，再将此函数名指向另外一个函数，调用另外一个变量对应的函数时，则会受到该变量名的影响。 1234567function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return num*arguments.callee(num-1); &#125;&#125; 函数内部对象this，this的值是函数执行的环境对象。（当在网页的全局作用域调用函数时this对象的值为window） 12345678window.color='red';var o=&#123;color:'blue'&#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //red this:windowo.sayColor=sayColor;o.sayColor(); //blue this:o 还有一个函数对象的属性：caller。这个属性保存着调用当前函数的函数的引用，如果在全局作用域中调用当前函数，他的值为null。我的理解是，函数A在函数B中调用，函数A中的caller属性就指向函数B。 5.函数的属性和方法每个函数都包含了两个属性：length和prototype。length属性表示希望接受的命名参数的个数。而arguments.length表示有多少个参数传递给了函数。前者说的是命名参数的个数，后者并没有强调命名参数。 1) 对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。2)在创建自定义引用类型以及实现以及实现继承prototype属性是及其重要的。3) prototype属性是不可枚举的，因此使用for-in无法发现。 每个函数都包含两个非继承而来的的方法：apply()和call()两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。 apply()第一个参数在其中运行函数的作用域；另一个是参数数组，可以是Array实例也可以是arguments对象。 call()第一个参数是this值，其余参数都必须逐个列举出来。 他俩的作用：扩充函数赖以运行的作用域。 1234567891011window.color='red';var o=&#123;color:'blue'&#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o) //blue sayColor.call(this)和sayColor.call(window)是两种显式的在全局作用域中调用函数的方式。sayColor.call(o)此时函数体内的this对象指向了o。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5实现滑动解锁功能]]></title>
    <url>%2F2018%2F02%2F25%2Fhtml5%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E8%A7%A3%E9%94%81%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[设计思路 在刚开始做的时候，我做的是直接在html文件里把页面结构写出来，然后再一个一个功能的加上去，写了几个函数之后，发现这样做各个函数之间不好配合，而且感觉该功能的灵活性不够。所以就尝试动态创建html,并且把整个滑动解锁的功能写成一个组件，感觉这样灵活性性要强许多。 我把代码分为三个部分：页面初始化部分、绑定事件部分、密码操作部分。 1. 页面初始化部分：该部分的主要功能是，动态创建页面DOM结构；确定每个解锁圆的圆心；确定画圆函数、画线函数等。 关键代码： 12345678910111213141516171819202122232425262728293031323334 oLock.prototype.getPoint=function()&#123; //规划好每个圆心的位置,并给每个位置加上序号 var n=3; var num=0; this.r=this.oC.width/(2+4*n); //让圆心均匀分布在中心的公式 this.usedArr=[]; //重置usedArr; this.arr=[]; this.restArr=[]; //剩下的小圈圈集合 var r=this.r; for(var i=0;i&lt;n;i++)&#123; //存每个点的坐标 for(var j=0;j&lt;n;j++)&#123; num++; var obj=&#123; x: j*4*r+3*r, y: i*4*r+3*r, index:num, &#125;; this.arr.push(obj); this.restArr.push(obj); &#125; &#125; this.oGC.clearRect(0,0,this.oC.width,this.oC.height); for(var i=0;i&lt;this.arr.length;i++)&#123; this.createCle(this.arr[i].x,this.arr[i].y); &#125;&#125;oLock.prototype.createCle=function(x,y)&#123; //画每个圆圈 this.oGC.lineWidth=2; this.oGC.strokeStyle="#E6E6E6"; this.oGC.beginPath(); this.oGC.arc(x,y,this.r,0,Math.PI*2,true); this.oGC.closePath(); this.oGC.stroke();&#125; 这两个的功能是找到每个圆的圆心，并把每个圆给画出来。圆的半径r和canvas宽度有关。 r=this.oC.width/(2+4n)的得来：我想的是每个圆之间，以及圆和边界间隔一个半径，所以可以得到width=(2r)(n+1)+2rn,求得r=width/(2+4n)。 此处遇到的坑：当初没有写上this.usedArr=[]这句话，导致usedArr没有清空，第二次点击滑动的时候自动添加了上一次路径😂 2. 事件绑定部分：该部分主要就是添加touchstart、touchmove、touchend事件相对应的功能；实现滑动解锁具体操作。 **关键代码：** 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071oLock.prototype.pickPoints=function(from,to)&#123; var olength=getDis(from,to); var dir=to.index&gt;from.index?1:-1; var len=this.restArr.length; var i= dir==1?0:(len-1); var limit= dir==1?len:-1; while( i!=limit )&#123; var pt=this.restArr[i]; if(getDis(pt,from)+getDis(pt,to)==olength)&#123; this.createPoint(pt.x,pt.y); this.usedArr.push(pt); this.restArr.splice(i,1); if(limit&gt;0)&#123; i--; limit--; &#125; &#125; i+=dir; &#125;&#125;oLock.prototype.boss=function(pos)&#123; //核心方法 this.oGC.clearRect(0,0,this.oC.width,this.oC.height); for(var i=0;i&lt;this.arr.length;i++)&#123; this.createCle(this.arr[i].x, this.arr[i].y); &#125; this.createPoint(); this.createLine(pos); console.log(this.restArr.length); for(var i=0;i&lt;this.restArr.length;i++)&#123; var tp=this.restArr[i]; if(Math.abs(pos.x-tp.x)&lt;this.r &amp;&amp; Math.abs(pos.y-tp.y)&lt;this.r)&#123; this.createPoint(); this.pickPoints(this.usedArr[this.usedArr.length-1],tp); break; &#125; &#125; &#125;oLock.prototype.bindEv=function()&#123; var This=this; this.oC.addEventListener("touchstart",function(ev)&#123; var pos=This.getPos(ev); console.log(pos); for(var i=0;i&lt;This.arr.length;i++)&#123; if( Math.abs(pos.x-This.arr[i].x)&lt;This.r &amp;&amp; Math.abs(pos.y-This.arr[i].y)&lt;This.r )&#123; //判断点击的位置是不是在小圈圈里面 // alert(1); This.onOff=true; This.usedArr.push(This.arr[i]); This.restArr.splice(i,1); break; &#125; &#125; &#125;); this.oC.addEventListener("touchmove",function(ev)&#123; if(This.onOff)&#123; This.boss(This.getPos(ev)); &#125; &#125;); this.oC.addEventListener("touchend",function(ev)&#123; if(This.onOff)&#123; This.onOff=true; This.doPassword(This.usedArr); setTimeout(function()&#123; This.getPoint(); //touchend之后要初始化页面一下 &#125;,300); &#125; &#125;); &#125; 这里的usedArr是指已经被圈出的小圆圈，restArr是指剩下没被全出的小圆圈。boss函数是控制连线，里面的pickPoints函数作用是当触摸点接触到小圈圈的时候，将该小圈圈的index添入usedArr，并删除restArr里面相对应的元素 此处的坑：一开始并没有注意事件里面this的指向和外面的不同，导致错误，在bindEv里写上var This=this就OK了 3. 密码操作部分：此处功能包含，修改密码并删除localStorage里面存的东西；验证输入密码是否与设置的相同；设置密码时各种不符合规则的检查等。 关键代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556oLock.prototype.selectFun=function()&#123; var aInput=document.getElementsByTagName("input"); var that=this; aInput[0].onfocus=function()&#123; document.getElementById('header').innerHTML="请解锁"; oLock.prototype.doPassword=function(pw)&#123; if( window.localStorage.getItem('password') )&#123; if(that.pwObj.nowPw)&#123; if(that.checkPassword(that.pwObj.nowPw,pw))&#123; document.getElementById('header').innerHTML='解锁成功'; that.createCleLine('#00F90F'); &#125;else&#123; document.getElementById('header').innerHTML='解锁失败'; that.createCleLine('red'); &#125; &#125;else&#123; alert("还未设置密码"); &#125; &#125;else&#123; alert("还未设置密码"); &#125; &#125; &#125;; aInput[1].onfocus=function()&#123; document.getElementById('header').innerHTML="请绘制解锁图案"; that.pwObj=&#123;&#125;; that.getPoint(); oLock.prototype.doPassword=function(pw)&#123; if(that.pwObj.step==1)&#123; if(that.checkPassword(that.pwObj.formerPw,pw))&#123; that.pwObj.step=2; that.pwObj.nowPw=pw; document.getElementById('header').innerHTML='密码保存成功'; that.createCleLine('#00F90F'); window.localStorage.setItem('password',JSON.stringify(that.pwObj.nowPw)); &#125;else&#123; document.getElementById('header').innerHTML="两次输入不一致，请重新输入"; that.createCleLine('red'); delete that.pwObj.step; &#125; &#125;else&#123; if(pw.length&lt;5)&#123; document.getElementById('header').innerHTML="密码太短，至少需要五个点"; that.createCleLine('red'); that.pwObj=&#123;&#125;; &#125;else&#123; that.pwObj.step=1; that.pwObj.formerPw=pw; document.getElementById('header').innerHTML="再次输入"; &#125; &#125; &#125; &#125;;&#125; 这个函数主要功能就是通过单选按钮来控制是设置密码还是验证密码，具体做法就是通过改变oLock.prototype.doPassword来实现的，不同的选择会使oLock.prototype.doPassword里面对应的方法不同，从而实现模式的切换。 遇到的坑：在打开页面的时候并没有触发onfocus事件，所以oLock.prototype.doPassword就不会被定义。解决方法就是在外面先定义一下这个方法。]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据结构与算法学习笔记(一)]]></title>
    <url>%2F2018%2F02%2F25%2Fjs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[JavaScript数据结构与算法学习笔记(一) 前言：考完研啦，前端大半年没碰了，最近开始恶补一番😂。去年参加了几次实习生招聘，吃亏在数据结构和算法方面，最近在专门针对这方面进行学习。在这里记录下自己需要熟记的一些知识点以及弱项。首先从难的开始～ 排序总结六种排序方式实现：冒泡排序、选择排序、插入排序、归并排序、快速排序和堆排序 1.冒泡排序原理：比较相邻的两个项，如果第一个比第二个大，则交换他们。实现如下 12345678910111213var bubbleSort=function(arr)&#123; var length=arr.length; for(var i=0;i&lt;length;i++)&#123; for(var j=0;j&lt;length-1;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; swap(arr,j,j+1); //交换值的函数 &#125; &#125; &#125;&#125;function swap(arr,i,j)&#123; [arr[i],arr[j]]=[arr[j],arr[i]]; &#125; 外包围的循环控制经过了多少轮排序，内包围的将第一位迭代至倒数第二位，这种冒泡排序会比较已经排好的元素，性能会下降。下面是改进后的冒泡排序 12345678910var modifiedBubbleSort=function(arr)&#123; var length=arr.length; for(var i=0;i&lt;length;i++)&#123; for(var j=0;j&lt;length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; swap(arr,j,j+1); &#125; &#125; &#125;&#125; 2.选择排序大致思路：找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推 123456789101112131415var selectionSort=function(arr)&#123; var length=arr.length, indexMin; for(var i=0;i&lt;length-1;i++)&#123; indexMin=i; for(var j=i;j&lt;length;j++)&#123; if(arr[indexMin]&gt;arr[j])&#123; indexMin=j; &#125; &#125; if(i!==indexMin)&#123; swap(arr,indexMin,i); &#125; &#125;&#125; 流程： 首先假设本迭代轮次的第一个值为数组的最小值 从当前i的值开始至数组结束，比较j的值是否比当前最小值小；如果是，则将j的值作为最小值 如果最小值和原来的最小值不同，则交换他俩 冒泡排序和选择排序一样，它们都包含了嵌套的两个循环，导致了二次方的复杂度。 3.插入排序原理：插入排序每次排一个数组项，以此方式构建最后的排序数组。例如，第一项已经排好，现在比较第二项和第一项，看看第二项是呆在原地还是插入到第一项的前面？接着，操作第三项，通过和前两项的比较，看看第三项是插入到哪地方。我的个人理解就是：数组的某一项在他前面所有项依次进行比较，如果找到比他大的实现如下： 12345678910111213var insertionSort=function(arr)&#123; var length=arr.length, j,temp; for(var i=1;i&lt;length;i++)&#123; //假定第一项已经排好，所以i从1开始 j=i; temp=arr[i]; while(j&gt;0 &amp;&amp; arr[j-1]&gt;temp)&#123; arr[j]=arr[j-1]; j--; &#125; arr[j]=temp; &#125;&#125; 此算法性能好于选择排序和冒泡排序 4.归并排序 归并排序是第一个可以实际使用的排序算法，复杂度为O(nlogn) 原理：把原始数组分成比较小的数组，直到每个小数组只有一个位置，接着将小数组归并成比较大的数组，直到最后只有一个排序完毕的大数组。我的理解就是，第一步把数组切分成只有一项元素的子数组；第二步再把这些子数组依次合并，最终变成一个完整的数组。 当实现一个递归函数，我们都会实现一个实际被执行的辅助函数。如下先实现merge函数，他负责合并和排序小数组来产生大数组 12345678910111213141516171819202122var merge = function(left,right)&#123; //接收两个参数，排序发生在合并过程中 var result=[], il=0, ir=0; while(il&lt;left.length &amp;&amp; ir&lt;right.length)&#123; //依次比较来自left数组的项是否比来自right数组的项要小，如果是，则将该元素添加到result数组中，并递增迭代数组的控制变量，否则则操作right if(left[il]&lt;right[ir])&#123; result.push(left[il++]); &#125;else&#123; result.push(right[ir++]); &#125; &#125; while(il&lt;left.length)&#123; //将剩余的的项添加到result数组中 result.push(left[il++]); &#125; while(ir&lt;right.length)&#123; result.push(right[ir++]); &#125; return result;&#125; 接下来，定义一个递归函数，作用利用递归把数组切成只有一项，然后调用merge函数进行合并排序 123456789101112var mergeSortRec=function(arr)&#123; var length=arr.length; if(arr.length==1)&#123; //递归的停止条件，如果数组长度是1，则返回这个长度为1的数组。 return arr; &#125; var mid=Math.floor(length/2); var left=arr.slice(0,mid); var right=arr.slilce(mid,length); return merge(mergeSortRec(left),mergeSortRec(right));&#125; 最后，定义一个mergeSort函数完成整个归并算法 123var mergeSort=function(arr)&#123; arr=mergeSortRec(arr);&#125; 归并排序的时间复杂度为O(nlogn) 5.快速排序 步骤：1、从数组中选择中间一项作为主元2、创建两个指针，左边一个指向数组的第一项，右边一个指向数组的最后一项。移动左指针直到找到一个比主元大的元素，接着，移动右指针直到找到一个比主元小的元素，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在了主元之前，而比主元大的值都排在了主元之后。这一步叫划分操作。3、接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复前两个步骤，直到数组完全排序。 123function quickSort(arr)&#123; quick(arr,0,arr.length-1);&#125; 像归并排序一样，首先定义一个主函数来调用递归函数，传递待排数组，以及索引0及最末的位置。 5.1 划分操作的实现第一件事情就是要选择主元（pivot）。我们选择中间项作为主元 1234567891011121314151617181920var partition=function(arr,left,right)&#123; var pivot=arr[Math.floor((left+right)/2)]; var i=left; var j=right; while(i&lt;=j)&#123; while(arr[i]&lt;pivot)&#123; i++ &#125; while(arr[j]&gt;pivot)&#123; j-- &#125; if(i&lt;=j)&#123; swap(arr,i,j); i++; j-- &#125; &#125; return i;&#125; 当左指针指向的元素比主元大且右指针指向的元素比主元小，并且此时左指针索引没有右指针索引大。然后交换他俩，移动指针，并重复此过程。下面实现递归函数quick 1234567891011121314var quick=function(arr,left,right)&#123; var index; if(arr.length&gt;1)&#123; index=partition(arr,left,right); if(left&lt;index-1)&#123; quick(arr,left,index-1); &#125; if(index&lt;right)&#123; quick(arr,index,right) &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建博客心得]]></title>
    <url>%2F2018%2F02%2F24%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[MAC环境下利用Hexo+github搭建博客心得 前言：此次是利用hexo+github搭建博客，主要目的就是整理之前的项目，梳理一下思路，方便在面试的时候有所展示；同时也方便今后学习和项目的总结～ 搭建这个博客我花了一天时间，主要是通过参考他人搭建经历完成的。网上搭建流程有很多，在此就不再赘述。本文主要是记录下自己在搭建博客中学到的东西和踩过的坑。 1.what’s Hexo?Hexo是一个快速, 简洁且高效的博客框架. 让上百个页面在几秒内瞬间完成渲染. Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件. 并自己也拥有强大的插件系统. 2.Hexo相关指令 安装Hexo 之前得安装好nodejs，在安装好nodejs之后，在终端执行下列指令 1$ sudo npm install -g hexo-cli 坑一：Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。 初始化 首先必须cd到准备用来搭建博客的文件夹，执行hexo init命令 接着在该文件夹下执行npm的安装指令npm install 最后开启hexo服务器hexo s，并在浏览器中打开http://localhost:4000可以见到初始化页面 更新主题配置和部署文章 每次文章发布和主题属性都要进行以下步骤才能同步到博客上 123$ hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)$ hexo g //生成缓存和静态文件$ hexo d //重新部署到服务器 3.next主题配置 坑二：在配置站点配置文件和主题配置文件时（所有的_config.yml），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错。切记，很坑😂 菜单设置 通过修改next主题下的_config.yml的menu字段，选定显示的菜单项。 1234567menu: home: / categories: /categories about: /about archives: /archives tags: /tags #commonweal: /404.html 其中，home代表主页，categories代表分类页，about代表关于页面，archives代表归档页，commonweal代表404页面（page not found时候显示的页面）。在设置好菜单后，就会出现这一系列按钮，此时点击这些按钮时，会弹出页面不存在，这是因为这些页面还没设置的原因 添加标签页面 1.新建页面 12$ cd Blog //Blog是选择作为搭建博客的那个文件夹名称$ hexo new page tags 2.设置页面的类型在上步新生成的myBlog/source/tags/index.md中添加type: &quot;tags&quot;，index.md文件内容如下： 123title: tagsdate: 2018-02-24 09:40:00type: &quot;tags&quot; //加上这句话 添加标签才能起作用 3.设置具体文章的tags 123title: 搭建博客心得categories: 搭建博客tags: [npm, hexo, github] 添加分类页面 步骤和添加标签页面一摸一样，只需将tags改成categories 添加关于我(about)页面 1.新建页面 12$ cd myBlog$ hexo new page about 输入命令后，在myBlog/source下会新生成一个新的文件夹about，在该文件夹下会有一个index.md文件。 2.修改index.md 我的index.md配置如下 1234567891011121314---title: aboutdate: 2018-02-23 13:13:14---##关于我一只正在如饥似渴学习前端的小菜鸟～微信：zfight13QQ: 707085615Email: scty8888@163.com]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>

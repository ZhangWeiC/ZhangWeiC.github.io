<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js数据结构与算法学习笔记(一)]]></title>
    <url>%2F2018%2F02%2F25%2Fjs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[JavaScript数据结构与算法学习笔记(一) 前言：考完研啦，前端大半年没碰了，最近开始恶补一番😂。去年参加了几次实习生招聘，吃亏在数据结构和算法方面，最近在专门针对这方面进行学习。在这里记录下自己需要熟记的一些知识点以及弱项。首先从难的开始～ 排序总结六种排序方式实现：冒泡排序、选择排序、插入排序、归并排序、快速排序和堆排序 1.冒泡排序原理：比较相邻的两个项，如果第一个比第二个大，则交换他们。实现如下 12345678910111213var bubbleSort=function(arr)&#123; var length=arr.length; for(var i=0;i&lt;length;i++)&#123; for(var j=0;j&lt;length-1;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; swap(arr,j,j+1); //交换值的函数 &#125; &#125; &#125;&#125;function swap(arr,i,j)&#123; [arr[i],arr[j]]=[arr[j],arr[i]]; &#125; 外包围的循环控制经过了多少轮排序，内包围的将第一位迭代至倒数第二位，这种冒泡排序会比较已经排好的元素，性能会下降。下面是改进后的冒泡排序 12345678910var modifiedBubbleSort=function(arr)&#123; var length=arr.length; for(var i=0;i&lt;length;i++)&#123; for(var j=0;j&lt;length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; swap(arr,j,j+1); &#125; &#125; &#125;&#125; 2.选择排序大致思路：找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推 123456789101112131415var selectionSort=function(arr)&#123; var length=arr.length, indexMin; for(var i=0;i&lt;length-1;i++)&#123; indexMin=i; for(var j=i;j&lt;length;j++)&#123; if(arr[indexMin]&gt;arr[j])&#123; indexMin=j; &#125; &#125; if(i!==indexMin)&#123; swap(arr,indexMin,i); &#125; &#125;&#125; 流程： 首先假设本迭代轮次的第一个值为数组的最小值 从当前i的值开始至数组结束，比较j的值是否比当前最小值小；如果是，则将j的值作为最小值 如果最小值和原来的最小值不同，则交换他俩 冒泡排序和选择排序一样，它们都包含了嵌套的两个循环，导致了二次方的复杂度。 3.插入排序原理：插入排序每次排一个数组项，以此方式构建最后的排序数组。例如，第一项已经排好，现在比较第二项和第一项，看看第二项是呆在原地还是插入到第一项的前面？接着，操作第三项，通过和前两项的比较，看看第三项是插入到哪地方。我的个人理解就是：数组的某一项在他前面所有项依次进行比较，如果找到比他大的实现如下： 12345678910111213var insertionSort=function(arr)&#123; var length=arr.length, j,temp; for(var i=1;i&lt;length;i++)&#123; //假定第一项已经排好，所以i从1开始 j=i; temp=arr[i]; while(j&gt;0 &amp;&amp; arr[j-1]&gt;temp)&#123; arr[j]=arr[j-1]; j--; &#125; arr[j]=temp; &#125;&#125; 此算法性能好于选择排序和冒泡排序 4.归并排序 归并排序是第一个可以实际使用的排序算法，复杂度为O(nlogn) 原理：把原始数组分成比较小的数组，直到每个小数组只有一个位置，接着将小数组归并成比较大的数组，直到最后只有一个排序完毕的大数组。我的理解就是，第一步把数组切分成只有一项元素的子数组；第二步再把这些子数组依次合并，最终变成一个完整的数组。 当实现一个递归函数，我们都会实现一个实际被执行的辅助函数。如下先实现merge函数，他负责合并和排序小数组来产生大数组 12345678910111213141516171819202122var merge = function(left,right)&#123; //接收两个参数，排序发生在合并过程中 var result=[], il=0, ir=0; while(il&lt;left.length &amp;&amp; ir&lt;right.length)&#123; //依次比较来自left数组的项是否比来自right数组的项要小，如果是，则将该元素添加到result数组中，并递增迭代数组的控制变量，否则则操作right if(left[il]&lt;right[ir])&#123; result.push(left[il++]); &#125;else&#123; result.push(right[ir++]); &#125; &#125; while(il&lt;left.length)&#123; //将剩余的的项添加到result数组中 result.push(left[il++]); &#125; while(ir&lt;right.length)&#123; result.push(right[ir++]); &#125; return result;&#125; 接下来，定义一个递归函数，作用利用递归把数组切成只有一项，然后调用merge函数进行合并排序 123var mergeSortRec=function(arr)&#123; var length=&#125;]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5实现滑动解锁功能]]></title>
    <url>%2F2018%2F02%2F25%2Fhtml5%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E8%A7%A3%E9%94%81%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[设计思路 在刚开始做的时候，我做的是直接在html文件里把页面结构写出来，然后再一个一个功能的加上去，写了几个函数之后，发现这样做各个函数之间不好配合，而且感觉该功能的灵活性不够。所以就尝试动态创建html,并且把整个滑动解锁的功能写成一个组件，感觉这样灵活性性要强许多。 我把代码分为三个部分：页面初始化部分、绑定事件部分、密码操作部分。 1. 页面初始化部分：该部分的主要功能是，动态创建页面DOM结构；确定每个解锁圆的圆心；确定画圆函数、画线函数等。 关键代码： 12345678910111213141516171819202122232425262728293031323334 oLock.prototype.getPoint=function()&#123; //规划好每个圆心的位置,并给每个位置加上序号 var n=3; var num=0; this.r=this.oC.width/(2+4*n); //让圆心均匀分布在中心的公式 this.usedArr=[]; //重置usedArr; this.arr=[]; this.restArr=[]; //剩下的小圈圈集合 var r=this.r; for(var i=0;i&lt;n;i++)&#123; //存每个点的坐标 for(var j=0;j&lt;n;j++)&#123; num++; var obj=&#123; x: j*4*r+3*r, y: i*4*r+3*r, index:num, &#125;; this.arr.push(obj); this.restArr.push(obj); &#125; &#125; this.oGC.clearRect(0,0,this.oC.width,this.oC.height); for(var i=0;i&lt;this.arr.length;i++)&#123; this.createCle(this.arr[i].x,this.arr[i].y); &#125;&#125;oLock.prototype.createCle=function(x,y)&#123; //画每个圆圈 this.oGC.lineWidth=2; this.oGC.strokeStyle="#E6E6E6"; this.oGC.beginPath(); this.oGC.arc(x,y,this.r,0,Math.PI*2,true); this.oGC.closePath(); this.oGC.stroke();&#125; 这两个的功能是找到每个圆的圆心，并把每个圆给画出来。圆的半径r和canvas宽度有关。 r=this.oC.width/(2+4n)的得来：我想的是每个圆之间，以及圆和边界间隔一个半径，所以可以得到width=(2r)(n+1)+2rn,求得r=width/(2+4n)。 此处遇到的坑：当初没有写上this.usedArr=[]这句话，导致usedArr没有清空，第二次点击滑动的时候自动添加了上一次路径😂 2. 事件绑定部分：该部分主要就是添加touchstart、touchmove、touchend事件相对应的功能；实现滑动解锁具体操作。 **关键代码：** 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071oLock.prototype.pickPoints=function(from,to)&#123; var olength=getDis(from,to); var dir=to.index&gt;from.index?1:-1; var len=this.restArr.length; var i= dir==1?0:(len-1); var limit= dir==1?len:-1; while( i!=limit )&#123; var pt=this.restArr[i]; if(getDis(pt,from)+getDis(pt,to)==olength)&#123; this.createPoint(pt.x,pt.y); this.usedArr.push(pt); this.restArr.splice(i,1); if(limit&gt;0)&#123; i--; limit--; &#125; &#125; i+=dir; &#125;&#125;oLock.prototype.boss=function(pos)&#123; //核心方法 this.oGC.clearRect(0,0,this.oC.width,this.oC.height); for(var i=0;i&lt;this.arr.length;i++)&#123; this.createCle(this.arr[i].x, this.arr[i].y); &#125; this.createPoint(); this.createLine(pos); console.log(this.restArr.length); for(var i=0;i&lt;this.restArr.length;i++)&#123; var tp=this.restArr[i]; if(Math.abs(pos.x-tp.x)&lt;this.r &amp;&amp; Math.abs(pos.y-tp.y)&lt;this.r)&#123; this.createPoint(); this.pickPoints(this.usedArr[this.usedArr.length-1],tp); break; &#125; &#125; &#125;oLock.prototype.bindEv=function()&#123; var This=this; this.oC.addEventListener("touchstart",function(ev)&#123; var pos=This.getPos(ev); console.log(pos); for(var i=0;i&lt;This.arr.length;i++)&#123; if( Math.abs(pos.x-This.arr[i].x)&lt;This.r &amp;&amp; Math.abs(pos.y-This.arr[i].y)&lt;This.r )&#123; //判断点击的位置是不是在小圈圈里面 // alert(1); This.onOff=true; This.usedArr.push(This.arr[i]); This.restArr.splice(i,1); break; &#125; &#125; &#125;); this.oC.addEventListener("touchmove",function(ev)&#123; if(This.onOff)&#123; This.boss(This.getPos(ev)); &#125; &#125;); this.oC.addEventListener("touchend",function(ev)&#123; if(This.onOff)&#123; This.onOff=true; This.doPassword(This.usedArr); setTimeout(function()&#123; This.getPoint(); //touchend之后要初始化页面一下 &#125;,300); &#125; &#125;); &#125; 这里的usedArr是指已经被圈出的小圆圈，restArr是指剩下没被全出的小圆圈。boss函数是控制连线，里面的pickPoints函数作用是当触摸点接触到小圈圈的时候，将该小圈圈的index添入usedArr，并删除restArr里面相对应的元素 此处的坑：一开始并没有注意事件里面this的指向和外面的不同，导致错误，在bindEv里写上var This=this就OK了 3. 密码操作部分：此处功能包含，修改密码并删除localStorage里面存的东西；验证输入密码是否与设置的相同；设置密码时各种不符合规则的检查等。 关键代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556oLock.prototype.selectFun=function()&#123; var aInput=document.getElementsByTagName("input"); var that=this; aInput[0].onfocus=function()&#123; document.getElementById('header').innerHTML="请解锁"; oLock.prototype.doPassword=function(pw)&#123; if( window.localStorage.getItem('password') )&#123; if(that.pwObj.nowPw)&#123; if(that.checkPassword(that.pwObj.nowPw,pw))&#123; document.getElementById('header').innerHTML='解锁成功'; that.createCleLine('#00F90F'); &#125;else&#123; document.getElementById('header').innerHTML='解锁失败'; that.createCleLine('red'); &#125; &#125;else&#123; alert("还未设置密码"); &#125; &#125;else&#123; alert("还未设置密码"); &#125; &#125; &#125;; aInput[1].onfocus=function()&#123; document.getElementById('header').innerHTML="请绘制解锁图案"; that.pwObj=&#123;&#125;; that.getPoint(); oLock.prototype.doPassword=function(pw)&#123; if(that.pwObj.step==1)&#123; if(that.checkPassword(that.pwObj.formerPw,pw))&#123; that.pwObj.step=2; that.pwObj.nowPw=pw; document.getElementById('header').innerHTML='密码保存成功'; that.createCleLine('#00F90F'); window.localStorage.setItem('password',JSON.stringify(that.pwObj.nowPw)); &#125;else&#123; document.getElementById('header').innerHTML="两次输入不一致，请重新输入"; that.createCleLine('red'); delete that.pwObj.step; &#125; &#125;else&#123; if(pw.length&lt;5)&#123; document.getElementById('header').innerHTML="密码太短，至少需要五个点"; that.createCleLine('red'); that.pwObj=&#123;&#125;; &#125;else&#123; that.pwObj.step=1; that.pwObj.formerPw=pw; document.getElementById('header').innerHTML="再次输入"; &#125; &#125; &#125; &#125;;&#125; 这个函数主要功能就是通过单选按钮来控制是设置密码还是验证密码，具体做法就是通过改变oLock.prototype.doPassword来实现的，不同的选择会使oLock.prototype.doPassword里面对应的方法不同，从而实现模式的切换。 遇到的坑：在打开页面的时候并没有触发onfocus事件，所以oLock.prototype.doPassword就不会被定义。解决方法就是在外面先定义一下这个方法。]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建博客心得]]></title>
    <url>%2F2018%2F02%2F24%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[MAC环境下利用Hexo+github搭建博客心得 前言：此次是利用hexo+github搭建博客，主要目的就是整理之前的项目，梳理一下思路，方便在面试的时候有所展示；同时也方便今后学习和项目的总结～ 搭建这个博客我花了一天时间，主要是通过参考他人搭建经历完成的。网上搭建流程有很多，在此就不再赘述。本文主要是记录下自己在搭建博客中学到的东西和踩过的坑。 1.what’s Hexo?Hexo是一个快速, 简洁且高效的博客框架. 让上百个页面在几秒内瞬间完成渲染. Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件. 并自己也拥有强大的插件系统. 2.Hexo相关指令 安装Hexo 之前得安装好nodejs，在安装好nodejs之后，在终端执行下列指令 1$ sudo npm install -g hexo-cli 坑一：Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。 初始化 首先必须cd到准备用来搭建博客的文件夹，执行hexo init命令 接着在该文件夹下执行npm的安装指令npm install 最后开启hexo服务器hexo s，并在浏览器中打开http://localhost:4000可以见到初始化页面 更新主题配置和部署文章 每次文章发布和主题属性都要进行以下步骤才能同步到博客上 123$ hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)$ hexo g //生成缓存和静态文件$ hexo d //重新部署到服务器 3.next主题配置 坑二：在配置站点配置文件和主题配置文件时（所有的_config.yml），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错。切记，很坑😂 菜单设置 通过修改next主题下的_config.yml的menu字段，选定显示的菜单项。 1234567menu: home: / categories: /categories about: /about archives: /archives tags: /tags #commonweal: /404.html 其中，home代表主页，categories代表分类页，about代表关于页面，archives代表归档页，commonweal代表404页面（page not found时候显示的页面）。在设置好菜单后，就会出现这一系列按钮，此时点击这些按钮时，会弹出页面不存在，这是因为这些页面还没设置的原因 添加标签页面 1.新建页面 12$ cd Blog //Blog是选择作为搭建博客的那个文件夹名称$ hexo new page tags 2.设置页面的类型在上步新生成的myBlog/source/tags/index.md中添加type: &quot;tags&quot;，index.md文件内容如下： 123title: tagsdate: 2018-02-24 09:40:00type: &quot;tags&quot; //加上这句话 添加标签才能起作用 3.设置具体文章的tags 123title: 搭建博客心得categories: 搭建博客tags: [npm, hexo, github] 添加分类页面 步骤和添加标签页面一摸一样，只需将tags改成categories 添加关于我(about)页面 1.新建页面 12$ cd myBlog$ hexo new page about 输入命令后，在myBlog/source下会新生成一个新的文件夹about，在该文件夹下会有一个index.md文件。 2.修改index.md 我的index.md配置如下 1234567891011121314---title: aboutdate: 2018-02-23 13:13:14---##关于我一只正在如饥似渴学习前端的小菜鸟～微信：zfight13QQ: 707085615Email: scty8888@163.com]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面向对象程序设计]]></title>
    <url>%2F2018%2F03%2F05%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[面向对象程序设计学习笔记1.理解对象创建自定义对象最简单的方式就是创建一个Object的实例，再给他加上方法和属性 123456var person = new Object();person.name="Tom";person.age=29;person.sayName=function()&#123; alert(this.name);&#125;; 还有一种就是创建对象自变量。 1234567var person=&#123; name: "Tom", age: 29, sayName: function()&#123; alert(this.name); &#125;&#125;; 1.1属性类型只有内部才用的特性时（attribute），描述了属性（property）的各种特征。在JavaScript中不能直接访问它们。为了表示特性是内部值，用[[attribute]]表示ECMAScipt有两种属性：数据属性和访问器属性。 数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性 [[Configurable]]: 表示能否通过delete删除属性重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。默认为true。 [[Enumerable]]: 表示能否通过for-in循环返回属性。默认true [[Writable]]: 能否修改属性的值。默认true [[Value]]: 包含这个属性的数据值。读取属性值时，从这个位置读；写入属性值时，把新值保存到这个位置。默认undefined。 要修改属性的默认特性，就必须使用Object.defineProperty()方法。接收三个参数：属性所在对象、属性名字、一个描述符对象。其中，描述符对象的属性必须是：Configurable,Enumerable,Writable,Value. 12345678var person=&#123;&#125;;Object.defineProperty(person,'name',&#123; Writable: false, Value: 'Tom',&#125;);alert(person.name); //"Tom"person.name='gray';alert(person.name); //"Tom" 把configurable设置为false，表示不能从对象中删除属性。如果调用delete，在非严格模式下什么也不会发生，在严格模式下跑出错误。而且一旦把属性定义为不可配置时，就不能再把他变为可配置属性了。在调用defineProperty()方法修改除Writable之外的特性，都会发生错误。 12345678910111213var person=&#123;&#125;;Object.defineProperty(person,'name',&#123; Configurable: false, Value: 'Tom',&#125;);alert(person.name); //Tomdelete person.name;alert(person.name); //TomObject.defineProperty(person,'name',&#123; Configurable: true, //抛出错误 Value: 'Tom'&#125;); 用Object.defineProperty()方法创建一个新属性时，如果不指定，Configurable，Writable，Enumerable默认为false。 访问器属性 [[Configurable]]: 同上 [[Enumerable]]: 同上 [[Set]]:在写入属性时调用的函数。默认undefined。 [[Get]]:在读取属性时调用的函数。默认undefined。 访问器属性不包含数据值，他们包含一对getter和setter函数。在读取访问器属性时，调用getter()。设置访问器属性时，调用setter()并传入新值。访问器属性不能直接定义，必须使用Object.defineProperty()来定义。 123456789101112131415161718var book=&#123; _year: 2004, edition: 1, &#125;; Object.defineProperty(book,&quot;year&quot;,&#123; get: function()&#123; alert(this._year); &#125;, set: function(newValue)&#123; if(newValue&gt;2004)&#123; this._year += newValue; this.edition += newValue-2004; &#125; &#125;, &#125;);book.year=2008;alert(book.edition); 只定义getter意味着属性是不能写，尝试写入属性会被忽略。类似的，只定义setter函数的属性也不能读。 1.2定义多个属性利用Object.defineProperties()方法。 12345678910111213141516171819202122var book=&#123;&#125;;Object.defineProperties(book,&#123; _year:&#123; writable:true, value:2004, &#125;, edition:&#123; writable:true, value:1, &#125; year:&#123; get:function()&#123; return this._year; &#125;, set:function(newValue)&#123; if(newValue&gt;2004)&#123; this._year += newValue; this.edition += newValue-2004; &#125; &#125; &#125;&#125;); 1.3读取属性特性利用Object.getOwnPropertyDescriptor()。接收两个参数：属性所在的对象和读取其描述符的属性名称。返回的是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get、set；如果是数据属性，这个对象的属性有configurable、enumerable、writable、value。 1var descripter=Object.getOwnPropertyDescriptor(book,"_year"); 2.创建对象虽然Object构造函数和对象自变量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量重复的代码。 2.1 工厂模式用函数来封装以特定接口创建对象的细节，如下 12345678910function createPerson(name,age,job)&#123; var o=new Object(); o.name=name; o.age=age; o.job=job; o.sayName=function()&#123; alert(this.name); &#125;; return o;&#125; 工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题，即怎样知道一个对象的类型。 2.2构造函数模式可以用构造函数创建自定义构造函数，从而定义自定义对象类型的属性和方法。构造函数始终都应该以一个大写字母开头。构造函数也是函数，只不过可以用来创建对象而已。如下 1234567891011function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=function()&#123; alert(this.name); &#125;;&#125;var person1=new Person('zhang',21,"teacher");var person2=new Person('he',20,'Doctor'); 与工厂模式的不同： 没有显式的创建对象 直接将方法和属性赋值给了this对象 没有return 创建Person的新实例，必须使用new操作符。以这种方式调用构造函数会经历四个步骤： 创建一个新对象 将构造函数的作用域赋值给新对象（因此this就指向这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 person1和person2分别保存着Person的一个不同的实例。这两个对象都有一个constructor属性，该属性指向Personperson.constructor==Person //true也可以用instanceof操作符可以得到验证person1 instanceof Person //true。创建自定义构造函数意味着将来可以将它的实例标示为一种特定的类型，优于工厂模式。 1，构造函数问题构造函数与其他函数的区别，就是调用方式不同。任何函数使用new 操作符调用，那他就可以作为构造函数，而不通过new调用则就是普通函数。 123456789101112//作为构造函数var person=new Person('Tom',29,'teacher');person.name //Tom//作为普通函数使用Person('Tom',29,teacher);window.name //Tom//在另一个对象中调用var o=new Object();Person.call(o,'Tom',29,teacher);o.name //'Tom' 2.构造函数问题构造函数的问题就是：每个方法都要在每个实例上再创建一遍。不同实例上的同名函数是不一样的。可以把函数定义转移到构造函数外部进行定义。 2.3原型模式我们创建的每个函数都有一个prototype属性。这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的方法和属性。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。 1234567891011function Person()&#123;&#125;Person.prototype.name='Tom';Person.prototype.age=29;Person.prototype.job='teacher';Person.prototype.sayName=function()&#123; return this.name;&#125;;var person1=new Person();var person2=new Person();alert(person1==person2); //true 1.理解原型对象无论什么时候，一个新函数有一个prototype属性，该属性指向函数的原型对象，原型对象又包含一个constructor属性，这个属性是一个指针，指向新函数。Person.prototype.constructor指向Person。当调用构造函数创建一个新实例的时候，该实例内部有一个属性(内部属性)，叫[[prototype]]。在Safari、Firefox、Chrome对象上都支持一个属性proto。 proto这个连接存在于实例和原型对象之间，不存在于实例与构造函数之间。可以通过isPrototypeOf()方法来确定对象之间是否存在这种联系。 注：可以通过对象实例访问原型中的值，但不能通过对象实例修改原型中的值。当为实例添加一个属性时，就会屏蔽原型对象上的同名属性，可以通过delete删除实例上的属性，从而恢复对原型对象上的属性的访问。 用hasOwnProperty(属性名)方法可以判断一个属性是否存在于实例中，还是存在于原型中。当属性存在于实例中返回true。 2.原型与in操作符单独使用in时，会在通过对象能够访问给定属性时返回true，无论属性在对象实例中还是原型中。alert(&#39;name&#39; in person1)。 可以根据hasOwnProperty()和in一起确定属性是否存在于原型链中。如下 123function isPrototypeProperty(obj,name)&#123; return !obj.hasOwnProperty(name)&amp;&amp;(name in obj);&#125; for-in可以返回存在于实例中的属性和存在于原型中的属性，即使原型中不可枚举的属性（即将把[[Enumerable]]设置为false的属性）也会在for-in循环中返回。 Object.keys(对象)，返回一个包含所有可枚举属性字符串的数组。作用：取得对象上所有可枚举的实例属性。是实例上的属性，不包括原型链上的。要取得所有的属性可以使用Object.getOwnPropertyNames() 3.更简洁的语法12345678910function Person()&#123;&#125;Person.prototype=&#123; name:'Tom', age:29, job:teacher, sayName:function()&#123; alert(this.name); &#125;&#125;; 这种语法中，将对象自变量直接赋给原型对象。使用这种方法出现了一个问题，即Person.prototype.constructor不在指向Person，而指向了Object。因为我们完全重写了prototype对象，因此constructor也变成了新的constructor，不再指向Person函数。为了解决这个问题，可以有以下两种修改方法 1234567891011function Person()&#123;&#125;Person.prototype=&#123; constructor: Person, name:'Tom', age:29, job:teacher, sayName:function()&#123; alert(this.name); &#125;&#125;; 以上面这种方式设置constructor会导致其变为可枚举的，默认情况下，它是不可枚举的所以也可以通过下述方法改进。 1234Object.defineProperty(Person.prototype,'constructor',&#123; Enumerable: false, value: Person&#125;); 4.原型的动态性由于原型查找值的过程是一次搜索，因此我们对原型的任何修改都可以体现在实例上，即使我们在创建实例后修改原型也可以立刻体现到实例中。 5.原型对象的问题最大的问题是由共享的本性所导致的。对于引用类型值的属性来说，问题就比较突出了。 12345678910111213141516171819function Person()&#123;&#125;Person.prototype=&#123; constructor: Person, name:'Tom', age:29, job:teacher, friends:["Jane","Jay"], sayName:function()&#123; alert(this.name); &#125;&#125;;var person1=new Person();var person2=new Person();person1.friends.push('Van');alert(person1.friends); //"Jane","Jay","Van"alert(person2.friends); //"Jane","Jay","Van" 修改了一个可以从另外一个实例中反映出来。 2.4组合使用构造函数模式和原型模式创建自定义类型最常见的方式。构造函数模式用于定义实例属性，而原型模式用于定义共享属性。结果就是，每个实例都会有自己的一份实例属性的副本。但同时又共享着对方法的引用，最大限度的节省内存。此外还支持构造函数传递参数 123456789101112131415161718function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.friends=["Tom","Jay"];&#125;Person.prototype=&#123; constructor: Person, sayName: function()&#123; alert(this.name); &#125;&#125;var person1=new Person("Jucy",29,"Engineer");var person2=new Person("Greg",27,"Doctor");person1.friends.push("Kobe"); alert(person1.friends) //"Tom","Jay","Kobe"alert(person2.friends) //"Tom","Jay" 2.5 动态原型模式它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型，又保持了同时使用构造函数和原型的优点。也就是，可以通过检查某个应该存放的位置是否有效，来决定是否需要初始化原型。 12345678910function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; if(typeof sayName != 'function')&#123; person.prototype.sayName=function()&#123; alert(this.name); &#125;; &#125;&#125; 2.6 寄生构造函数模式基本思想：创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。 1234567891011function Person(name,age,job)&#123; var o=new Object(); o.name=name; o.age=age; o.job=job; o.sayName=function()&#123; alert(this.name); &#125;; return o&#125;var person=new Person('Tom',29,'teacher'); 除了使用new操作符并把使用的包装函数叫做构造函数以外，这个模式和工厂模式是一模一样的。 2.7 稳妥构造函数稳妥对象：没有公共属性，而且其方法也不引用this对象。最适合一些安全的环境中。与寄生构造函数的不同：1、不使用this。 2、不使用new操作符调用构造函数。 12345678910111213function Person(name,age,job)&#123; var o=new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName=function()&#123; alert(name); &#125;; //返回对象 return o;&#125;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax和Comet学习笔记]]></title>
    <url>%2F2018%2F03%2F01%2FAjax%E5%92%8CComet%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Ajax和Comet的学习笔记 按着js高级程序设计的步骤进行笔记记录～～ ajax：Asynchronous JavaScript+XMLajax的核心技术：XMLHttpRequest对象。 1.XMLHttpRequest对象建立：var xhr=new XMLHttpRequest(); (不考虑兼容IE7之前的版本)。 1.1 XHR用法 要调用的第一个方法就是open(),接受3个参数：1、要发送请求的类型（“post”，“get”等）、请求的URL、是否异步发送请求的bool值 xhr.open(&quot;get&quot;,&quot;example.php&quot;,false) 说明：1.url相对于执行代码的当前页面2.调用open方法并不会发送请求，而是启动一个请求已备发送。 要发送特定的请求，必须像这样调用send(),xhr.send(null).send()方法接受一个参数，即要作为请求主体发送的数据。如果不需要请求主体发送数据，则必须传入null。这次请求是同步的，js代码会等到服务器响应之后再继续执行。在收到响应后，响应的数据会自动填充XHR对象的属性,相关属性如下： responseText: 作为响应主体被返回的文本。 responseXML: 如果响应的内容类型是“text/xml”或者“application/xml”，这个属性将保存着包含响应数据的XML DOM文档。 status：响应的HTTP状态。 statusText：HTTP状态的说明 过程：第一步：检查status的状态，以确定响应已经成功返回。一般来说，HTTP的状态码为200时，可以作为成功的标志。这时候，responseText属性的内容已经就绪，在内容正确的情况下responseXML也能访问了。状态码为304时表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本。这时候的响应也是有效的。可以像下面这样肩检查两种状态码。 12345if( (xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300)||xhr.status==304 )&#123; alert(xhr.responseText);&#125;else&#123; alert("request is unsucessful" +xhr.status);&#125; 通过检测status来决定下一步操作。另外，无论内容类型是什么，响应主体都会保存到responseText中；而对于非XML数据来说，responseXML属性将设置为null。 上述是发送同步请求，多数情况下，我们还是要发送异步请求，才能让JavaScript继续执行而不必响应等待。通过检测XHR对象的readyState属性，该属性表示请求/响应过程的当前活动阶段。这个属性可取： * 0:未初始化。尚未调用open()方法。 * 1:启动，已经调用open()方法，但未调用send()方法。 * 2:发送，已经调用send()方法，但未接收到响应。 * 3:接收，已经接收到部分响应数据。 * 4:完成，已经接收到全部数据，而且可以在客户端使用了 只要readyState属性的值由一个值变为另一个值，都会触发一次readystatechange事件。可以利用这个事件来检测每次状态变化后readyState值。一般只对readyState的值为4的阶段感兴趣，因为这时的所有元素都已经就绪。不过，**必须在调用open()之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性。** 12345678var xhr=new XMLHttpRequest();xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; //code.... &#125;&#125;;xhr.open("get","example.php",true);xhr.send(null); 1.2 HTTP头部信息每个HTTP请求和响应都会带有相应的头部信息。XHR对象也提供了操作这两种头部（请求头部和响应头部）信息的方法。 请求头部：默认情况下，在发送XHR请求的同时，还会发送下列头部信息： Accept：浏览器能够处理的内容类型。 Accept-Charset：浏览器能够显示的字符集。 Accept-Encoding：浏览器能够处理的压缩编码。 Accept-Language：浏览器当前设置的语言。 Connection: 浏览器与服务器之间连接的类型。 Cookie：当前页面设置的任何cookie。 Host：发出请求的页面所在的域。 Refer：发出请求的页面的url。 User-Agent：浏览器的用户代理字符串。 使用setRequestHeader()方法可以设置自定义的请求头部信息。接收两个参数：1、头部字段的名称。 2、头部字段的值。 必须在调用open方法之后，send方法之前调用setRequestHeader()。 123456789var xhr = new XMLHttpRequest();xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; //.... &#125;&#125;;xhr.open("get","example.php",true);xhr.setRequestHeader("MyHeader","MyValue");xhr.send(null); 响应头部： 调用XHR对象的getResponseHeader()方法并传入头部字段名称，可以取得相应的响应头部信息。 调用XHR对象的getAllResponseHeaders()方法则可以取得一个包含所有头部信息的长字符串。 12var myHeader=xhr.getResponseHeader('MyHeader');var allHeaders=xhr.getAllResponseHeader(); getAllResponseHeaders()方法通常会返回如下所示的多行文本内容： 123456Date: ..Server: ..Vary: ..X-Power-By: ..Connection: ..Content-type: .. 1.3 GET请求GET是最常见的请求类型，最常用于向服务器查询某些信息。可以将查询字符串参数追加到URL的末尾，以便将信息发送给服务器。对XHR而言，位于传入open()方法的URL末尾的查询字符串必须经过正确的编码才行。使用get请求经常会发生一个错误，就是查询字符串格式有问题。查询字符串的每个参数的名称和值都必须使用encodeURIComponent()进行编码。 先解释下encodeURIComponent(URIstring)的作用以及用法。 1. 作用：函数可把字符串作为 URI 组件进行编码。&lt;br&gt; 2. 说明：该方法不会对ASCII字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * &apos; ( ) 。 其他字符（比如 ：;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。 下面这个函数可以辅助向现有URL的末尾添加查询字符串参数： 12345function addURLParam(url,name,value)&#123; url+= (url.indexOf("?")==-1 ? "?" : "&amp;"); url+= encodeURIComponent(name)+"="+encodeURIComponent(value); return url;&#125; 1.4 POST请求post通常用于向服务器发送应该被保存的数据。post请求应该把数据作为请求的主体来提交，而get请求传统上不是这样。post请求的主体可以包含非常多的数据，而且格式不限。用法: 第一步： xhr.open(&quot;post&quot;,&quot;example.php&quot;,true) 第二步： 向send()方法传入某些数据。 默认情况下，服务器对POST请求和提交Web表单请求并不会一视同仁。因此服务器端必须有程序来读取发送过来的原始数据，并从里面解析出有用的部分。可以利用XHR来模仿表单提交：首先将Content-Type头部信息设置为application/x-www-form-urlencoded，也就是表单提交时的内容类型。其次是以适当的格式创建一个字符串。 2.XMLHttpRequest2级2.1 FormData现代Web应用中频繁使用的一项功能就是表单数据的序列化，XMLHttpRequest2定义了FormData类型。作用：为序列化表单以及创建与表单格式相同的数据提供了便利。 12var data=new FormData();data.append('name','Nicholas'); 两个参数分别对应表单字段的名字和字段包含的值。向FormData构造函数传入表单元素，也可以用表单元素的数据预先向其中填入键值对：var data=new FormData(document.forms[0]);。创建FormData可以直接把它传入send()中。xhr.send(new FormData(form)). 2.2 超时设定XHR对象添加了一个timeout属性，表示请求在等待响应多少毫秒之后就终止。给timeout设置一个数值后，如果在规定的时间内浏览器还没有接收到响应，那么就会触发timeout事件，进而会调用ontimeout事件处理程序。 2.3 overridMimeType() 方法用于重写XHR响应的MIME类型 3.进度事件定义了与客户端服务器通信有关的事件。有以下6个进度事件。 loadstart：在接收到响应数据的第一个字节时触发。 progress：在接收响应期间持续不断地出发。 error：在请求发生错误时触发。 abort：调用abort()方法而终止连接时触发。 load：在接收完整的响应的触发。 可以替代readystatechange事件。 loadend：在通信完成或者在触发error、abort、load事件后触发。 过程：先触发loadstart,然后是一个或多个progress事件，然后是error、abort、load其中一个被触发，最后触发loadend事件。 4.跨域源资源通过XHR实现Ajax通信的一个主要限制就是跨域安全策略。在默认情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。CORS定义了在必须访问跨域资源时，浏览器和服务器应该如何沟通。CORS背后的基本思想，就是使用自定义的http头部让浏览器与服务器进行通信，从而决定请求或响应是否成功或失败。Origin:http://www.nczonline.net IE对CORS的实现 IE8引入XDR（XDomainRequest）类型。这个对象与XHR类似，但能实现安全可靠的跨域通信。XDR和XHR不同之处： cookie不会随请求发送，也不会随响应返回 不能访问响应头部信息 只支持GET和POST请求 只能设置请求头部信息中的Content-type 其他浏览器对CORS的实现都通过XMLHttpRequest对象实现了对CORS的原生支持。在尝试打开不同来源的资源，无需额外编写代码就可以触发这个行为。方法：使用标准的XHR对象并在open()方法中传入URL即可。例如 123456789101112var xhr=new XMLHttpRequest();xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; if((xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300) || xhr.status==304)&#123; alert(xhr.responseText); &#125;else&#123; alert("Request was unsucessful"+xhr.status); &#125; &#125;&#125;;xhr.open("get","http://www.somewhere-else.com/page/",true);xhr.send(null); 与IE的XDR对象不同，通过跨域XHR对象可以访问status和statusText属性，而且支持同步请求。跨域对象也有一些限制，如下： 不能使用setRequestHeader()设置自定义头部。 不能接受和发送cookie 调用getAllResponseHeader()方法总会返回空字符串。 Preflighted ReqeustsCORS通过一个叫做Preflighted Requests的透明服务器验证机制支持开发人员使用自定义的头部、GET或POST之外的方法，以及不同类型的主体内容。在使用高级选项来发送请求时，就会向服务器发送一个Preflight请求。这种请求使用OPTIONS方法，发送下列头部 跨浏览器的CORS所有浏览器都支持简单的请求，因此有必要实现一个跨浏览器的方案。检测XHR是否支持CORS的最简单的方式，就是检查withCredentials属性。再结合检测XDomainRequest对象是否存在，就可以检测所有浏览器了。 12345678910111213141516171819function createCORSRequest(method,url)&#123; var xhr=new XMLHttpRequest(); if("withCredentials" in xhr)&#123; xhr.open(method,url,true) &#125;else if(typeof XDomainRequest != "undefined")&#123; xhr = new XDomainRequest(); xhr.open(method,url); &#125;else&#123; xhr = null; &#125; return xhr;&#125;var request=createCORSRequest("get","http://www.somewhere-else.com/page/");if(request)&#123; request.onload=function()&#123; //对request.responseText进行处理 &#125; request.send();&#125; 5.其他跨域技术图像Ping使用标签，一个网页可以从任何网页中加载图像，不用担心跨不跨域。可以动态的创建图像，使用它们的onload和onerror事件处理程序来确定是否接收到了响应。图像Ping：是与服务器进行简单、单项的跨域通信的一种方式。通过图像Ping，浏览器得不到任何具体数据的数据，但通过监听load和error事件，它能知道响应是什么时候接收的。 12345var img=new Image();img.onload=img.onerror=function()&#123; alert("Done!");&#125;;img.src="http://www.example.com/test?name=Tom"; 图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。 JSONPJSONP：JSON with padding(填充式JSON或参数式JSON)，是应用JSON的一种新方式，JSONP和JSON差不多，只不过是包含在函数调用的JSON，callback({&quot;name&quot;:&quot;Tom&quot;});JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面调用的函数。回调函数的名字一般在请求中指定。而数据就是传入回调函数的JSON数据。典型的JSONP请求http://freegeoip.net/json/?callback=handleResponse。JSONP是通过动态创建script元素来使用的 123456function handleResponse(response)&#123; alert("Your Ip is"+response.ip+", which is in"+response.city);&#125;var script=document.createElement('script');script.src="http://freegeoip.net/json/?callback=handleResponse";document.body.insertBefore(script,document.body.firstChild); 优点：1.双向通信。2、可以访问响应文本。3、简单易用缺点：1.从其他域加载执行代码，不安全。2、确定请求是否失败并不容易。 Comet更高级的Ajax技术（也叫服务器推送）。Ajax是一种页面向服务器请求数据的技术，而Comet则是一种服务器向页面推送数据的技术。能够使信息实时地被推送到页面上。实现Comet有两种方式：长轮询和流。 短轮询：即浏览器定时向服务器发送请求，看有没有数据更新长轮询：页面发起一个到服务器的请求，然后服务器一直保持连续打开，直到有数据可以传送。发送完数据后，浏览器关闭连接，随即又发起一个到服务器的新请求。 HTTP流。他在页面的整体生命周期内只使用一个HTTP连接。就是浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性的向浏览器发送数据。可以通过监听readystatechange事件以及readyState的值是否为3，就可以利用XHR对象实现HTTP流。随着不断从服务器接收数据，readyState周期性的变为3，当readyState变为3时，responseText属性中就会保存接收到的所有数据。此时，需要比较此前接收到的数据，决定从什么位置开始取得最新的数据。实现如下 123456789101112131415161718function createStreamingClient(url,progress,finished)&#123; var xhr=new XMLHttpRequest(), receive=0; xhr.onreadystatechange=function()&#123; var result; if(xhr.readyState==3)&#123; result=xhr.reponseText.substring(received); received+=result.length; progress(result); &#125;else if(xhr.readyState==4)&#123; finished(xhr.responseText); &#125; &#125;; xhr.open("get",url,true); xhr.send(null); return xhr;&#125; Web SocketsWeb Sockets目标：在一个单独的持久连接上提供全双工、双向通信。过程：在JavaScript创建了Web Sockets之后，会有一个HTTP请求发送到浏览器以发起连接。在取得服务器响应之后，建立的连接会使用HTTP升级从HTTP协议交换为Web Socket协议。URL的模式也略有不同。未加密的连接是ws://，加密的连接是wss://。不是http://和https://好处：能够在客户端和服务器之间发送非常少的数据，而不必担心HTTP那样子节级的开销。非常适合移动应用。 1.Web Sockets API要创建web sockets，先实例一个WebSocket对象并传入要连接的URL：var socket=new WebSocket(&quot;ws://www.example.com/server.php&quot;)。必须给WebSocket构造函数传入绝对的URL。可以通过它打开到任何站点的连接。 实例化WebSocket对象后，浏览器就会马上尝试创建连接。与XHR相似，WebSocket也有一个表示当前状态的readyState属性。这个属性的值和XHR并不相同 WebSocket.OPENING(0): 正在建立连接 WebSocket.OPEN(1): 已经建立连接 WebSocket.CLOSING(2): 正在关闭连接 WebSocket.CLOSE(3): 已经关闭连接 WebSocket没有readystatechange事件；不过他有其他事件，对应不同状态，readyState的值永远都从0开始。要关闭Web Socket连接，可以在任何调用close方法().socket.close() 2.发送和接收数据使用send()方法并传入任意字符串，例如： 12var socket=new WebSocket("ws://www.example.com/server.php");socket.send("hello world"); WebSockets只能通过连接发送纯文本数据，所以对于复杂的数据结构，在发送之前，必须进行序列化。 当服务器向客户端发来消息时，WebSocket对象会触发message事件。这个message事件与其他传递消息的协议类似，也就是把返回的数据保存在event.data中。 12345socket.onmessage=function(event)&#123; var data = event.data; //处理数据&#125; 3.其他事件 open:在成功建立时触发 error：发生错误时触发 close：关闭连接时触发]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量、作用域和内存问题学习笔记]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[变量、作用域和内存问题学习笔记 之前学习过一遍，考完研发现记得不是很清楚😂，重新看了一遍js高程，在这里记录下自己的学习心得和薄弱环节～～ 1.基本和引用类型的值基本类型：简单的数据段，五种基本类型：Undefined,Null,Boolean,String,Number引用类型：是保存在内存中的对象 1.动态属性对于引用类型，我们可以为其添加属性和方法。对于基本类型变量，不能添加属性，虽然不会报错。 2.复制变量值基本类型：会在变量对象创建一个新值，然后把该值复制到为新变量分配的位置上。两个变量不会互相影响。 引用类型：同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。复制操作结束后，两个变量实际上引用同一个对象。改变其中一个变量，会影响另一个变量。 3.传递参数所有函数都是按值传递的。基本类型值的传递如同基本类型变量的复制一样。而引用类型值的传递，则如同引用类型变量的复制一样。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数外部。 1234567891011121314151617//基本类型function add(num)&#123; num+=10; return num;&#125;var count=20;var result=addTen(count);alert(count); //20,没有变化alert(result); //30//引用类型function setName(obj)&#123; obj.name="Tom";&#125;var person=new Object();setName(person);alert(person.name) //Tom 4.检测类型 1、typeof：检测一个变量是不是基本数据类型。检测基本类型时使用他，检测引用类型时用处不大。 注意：typeof null等于object 2、instanceof：在检测一个引用类型和Object构造函数时，instanceof操作符始终返回true。instanceof检测基本类型的值时，该操作符始终返回false。 2.执行环境及作用域执行环境时JavaScript最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之被销毁。每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将环境弹出，把控制权返回给之前的执行环境。当代码在一个环境中执行，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域的前端，始终都是当前执行的代码所在环境的变量对象。下一个变量来自外部环境，一直延续下去；全局执行环境的变量对象始终都是作用域链中的最后一个对象。标识符解析：是沿着作用域链一级一级搜索标示符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止。 1234567891011121314var color="blue";function changeColor()&#123; var anotherColor="red"; function swapColors()&#123; var tempColor=anotherColor; anotherColor=color; color=tempColor; //这里可以访问color、anotherColor、tempColor &#125; //这里可以访问color、anotherColor，不能访问tempColor。 swapColors();&#125;//这里只能访问color 延长作用域链：有些语句可以在作用域的前端临时加一个变量对象，该变量对象会在代码执行后被移除。以下两个语句会使作用域链得到加长。1、try-catch语句的catch块2、with语句 指定对象添加到作用域链中 3.垃圾收集js具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。原理：找出那些不再使用的变量，然后释放其占用的内存。垃圾收集器必须跟踪哪个变量有用，哪个变量没用，对于没用的变量打上标记，以便回收。具体有两个策略 3.1 标记清除最常用的垃圾收集方式。当变量进入环境时，就将这个变量标记为“进入环境”。离开环境时，将其标记为“离开环境”。过程：1、垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记。2、它会去掉环境中的变量以及被环境中的变量引用的变量的标记。 3、然后在此之后再被加上标记的变量将被视为准备删除的变量。4、最后垃圾收集器完成内存清除工作。 3.2 引用计数原理：跟踪记录每个值被引用的次数。过程：1、当声明了一个变量，并将一个引用类型值赋给该变量，则这个值的引用次数就是1.2、如果同一个值又被赋给另一个变量，该值的引用次数加1.3、假如包含这个值引用的变量又取得了另外一个值，则这个值的引用次数减1.4、如归该值的引用次数变为0，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。 3.3 性能问题垃圾收集器是周期运行的。确定垃圾收集器的时间间隔是一个非常重要的问题。 3.4 管理内存最主要问题：分配给web浏览器的可用内存数量通常要比分配给桌面应用程序的少。目的：为了防止javascript的网页耗尽全部内存而导致系统崩溃。优化内存占用的最佳方式：就是为执行中的代码保存必要的数据，一旦数据不在有用，最好通过将其设置为null，这个做法叫做解除引用。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引用类型之Function类型学习笔记]]></title>
    <url>%2F2018%2F02%2F26%2FFunction%E7%B1%BB%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Function类型函数实际上是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。由于函数名仅仅是指向函数的指针，一个函数可能会有多个名字。 函数定义的三种方式：1、函数声明 2、函数表达式 3、使用Function构造函数 var sum=new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1+num2&quot;). 1.没有重载可以将函数名想象为指针来理解为什么没有重载。如下 1234567function sum(num)&#123; return 30+num;&#125;function sum(num)&#123; return 40+num;&#125;sum(20) //60 以上代码输出60，说明第二次函数声明覆盖了第一次函数声明，这就说明了函数没有重载，以上代码等价于下面代码 123456var sum=function(num)&#123; return 30+num;&#125;;sum=function(num)&#123; return 40+num;&#125;; 切记：函数名只是指向函数对象的指针 2.函数声明和函数表达式 区别：解析器会首先读取函数声明，使任意代码都可以使用；而函数表达式则要等到执行到该代码行才会被解析。 3.作为值的函数 因为函数名本身就是变量，所以函数也可以作为值来使用。意思是，1、函数可以作为另一个函数的参数 2、函数可以作为一个函数的返回值 4.函数内部属性 在函数内部有两个特殊的对象：arguments和this。arguments是一个类数组对象，保存着函数所有参数。 arguments对象只是与数组类似，它并不是Array的实例。 123function sayhi()&#123; return arguments[0]+','+arguments[1];&#125; 以上代码不包含命名的参数，但函数功能依旧。这说明了ECMAScript函数的一个重要特点：命名的参数只提供便利，但不是必须的。arguments的length属性表示参数的个数。另外arguments对象可以和命名参数一起使用。最后，没有传递值的命名参数将自动被赋予undefined的值，跟定义了变量未初始化一样。 arguments还有个特殊的属性callee：该属性是一个指针，指向拥有这个arguments对象的函数。使用如下 1234567function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else( return num*factorial(num-1); )&#125; 上面代码将函数和函数名紧密地联系在了一起，如果将该函数名赋值给另外一个变量，再将此函数名指向另外一个函数，调用另外一个变量对应的函数时，则会受到该变量名的影响。 1234567function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return num*arguments.callee(num-1); &#125;&#125; 函数内部对象this，this的值是函数执行的环境对象。（当在网页的全局作用域调用函数时this对象的值为window） 12345678window.color='red';var o=&#123;color:'blue'&#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //red this:windowo.sayColor=sayColor;o.sayColor(); //blue this:o 还有一个函数对象的属性：caller。这个属性保存着调用当前函数的函数的引用，如果在全局作用域中调用当前函数，他的值为null。我的理解是，函数A在函数B中调用，函数A中的caller属性就指向函数B。 5.函数的属性和方法每个函数都包含了两个属性：length和prototype。length属性表示希望接受的命名参数的个数。而arguments.length表示有多少个参数传递给了函数。前者说的是命名参数的个数，后者并没有强调命名参数。 1) 对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。2)在创建自定义引用类型以及实现以及实现继承prototype属性是及其重要的。3) prototype属性是不可枚举的，因此使用for-in无法发现。 每个函数都包含两个非继承而来的的方法：apply()和call()两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。 apply()第一个参数在其中运行函数的作用域；另一个是参数数组，可以是Array实例也可以是arguments对象。 call()第一个参数是this值，其余参数都必须逐个列举出来。 他俩的作用：扩充函数赖以运行的作用域。 1234567891011window.color='red';var o=&#123;color:'blue'&#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o) //blue sayColor.call(this)和sayColor.call(window)是两种显式的在全局作用域中调用函数的方式。sayColor.call(o)此时函数体内的this对象指向了o。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5实现滑动解锁功能]]></title>
    <url>%2F2018%2F02%2F25%2Fhtml5%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E8%A7%A3%E9%94%81%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[设计思路 在刚开始做的时候，我做的是直接在html文件里把页面结构写出来，然后再一个一个功能的加上去，写了几个函数之后，发现这样做各个函数之间不好配合，而且感觉该功能的灵活性不够。所以就尝试动态创建html,并且把整个滑动解锁的功能写成一个组件，感觉这样灵活性性要强许多。 我把代码分为三个部分：页面初始化部分、绑定事件部分、密码操作部分。 1. 页面初始化部分：该部分的主要功能是，动态创建页面DOM结构；确定每个解锁圆的圆心；确定画圆函数、画线函数等。 关键代码： 12345678910111213141516171819202122232425262728293031323334 oLock.prototype.getPoint=function()&#123; //规划好每个圆心的位置,并给每个位置加上序号 var n=3; var num=0; this.r=this.oC.width/(2+4*n); //让圆心均匀分布在中心的公式 this.usedArr=[]; //重置usedArr; this.arr=[]; this.restArr=[]; //剩下的小圈圈集合 var r=this.r; for(var i=0;i&lt;n;i++)&#123; //存每个点的坐标 for(var j=0;j&lt;n;j++)&#123; num++; var obj=&#123; x: j*4*r+3*r, y: i*4*r+3*r, index:num, &#125;; this.arr.push(obj); this.restArr.push(obj); &#125; &#125; this.oGC.clearRect(0,0,this.oC.width,this.oC.height); for(var i=0;i&lt;this.arr.length;i++)&#123; this.createCle(this.arr[i].x,this.arr[i].y); &#125;&#125;oLock.prototype.createCle=function(x,y)&#123; //画每个圆圈 this.oGC.lineWidth=2; this.oGC.strokeStyle="#E6E6E6"; this.oGC.beginPath(); this.oGC.arc(x,y,this.r,0,Math.PI*2,true); this.oGC.closePath(); this.oGC.stroke();&#125; 这两个的功能是找到每个圆的圆心，并把每个圆给画出来。圆的半径r和canvas宽度有关。 r=this.oC.width/(2+4n)的得来：我想的是每个圆之间，以及圆和边界间隔一个半径，所以可以得到width=(2r)(n+1)+2rn,求得r=width/(2+4n)。 此处遇到的坑：当初没有写上this.usedArr=[]这句话，导致usedArr没有清空，第二次点击滑动的时候自动添加了上一次路径😂 2. 事件绑定部分：该部分主要就是添加touchstart、touchmove、touchend事件相对应的功能；实现滑动解锁具体操作。 **关键代码：** 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071oLock.prototype.pickPoints=function(from,to)&#123; var olength=getDis(from,to); var dir=to.index&gt;from.index?1:-1; var len=this.restArr.length; var i= dir==1?0:(len-1); var limit= dir==1?len:-1; while( i!=limit )&#123; var pt=this.restArr[i]; if(getDis(pt,from)+getDis(pt,to)==olength)&#123; this.createPoint(pt.x,pt.y); this.usedArr.push(pt); this.restArr.splice(i,1); if(limit&gt;0)&#123; i--; limit--; &#125; &#125; i+=dir; &#125;&#125;oLock.prototype.boss=function(pos)&#123; //核心方法 this.oGC.clearRect(0,0,this.oC.width,this.oC.height); for(var i=0;i&lt;this.arr.length;i++)&#123; this.createCle(this.arr[i].x, this.arr[i].y); &#125; this.createPoint(); this.createLine(pos); console.log(this.restArr.length); for(var i=0;i&lt;this.restArr.length;i++)&#123; var tp=this.restArr[i]; if(Math.abs(pos.x-tp.x)&lt;this.r &amp;&amp; Math.abs(pos.y-tp.y)&lt;this.r)&#123; this.createPoint(); this.pickPoints(this.usedArr[this.usedArr.length-1],tp); break; &#125; &#125; &#125;oLock.prototype.bindEv=function()&#123; var This=this; this.oC.addEventListener("touchstart",function(ev)&#123; var pos=This.getPos(ev); console.log(pos); for(var i=0;i&lt;This.arr.length;i++)&#123; if( Math.abs(pos.x-This.arr[i].x)&lt;This.r &amp;&amp; Math.abs(pos.y-This.arr[i].y)&lt;This.r )&#123; //判断点击的位置是不是在小圈圈里面 // alert(1); This.onOff=true; This.usedArr.push(This.arr[i]); This.restArr.splice(i,1); break; &#125; &#125; &#125;); this.oC.addEventListener("touchmove",function(ev)&#123; if(This.onOff)&#123; This.boss(This.getPos(ev)); &#125; &#125;); this.oC.addEventListener("touchend",function(ev)&#123; if(This.onOff)&#123; This.onOff=true; This.doPassword(This.usedArr); setTimeout(function()&#123; This.getPoint(); //touchend之后要初始化页面一下 &#125;,300); &#125; &#125;); &#125; 这里的usedArr是指已经被圈出的小圆圈，restArr是指剩下没被全出的小圆圈。boss函数是控制连线，里面的pickPoints函数作用是当触摸点接触到小圈圈的时候，将该小圈圈的index添入usedArr，并删除restArr里面相对应的元素 此处的坑：一开始并没有注意事件里面this的指向和外面的不同，导致错误，在bindEv里写上var This=this就OK了 3. 密码操作部分：此处功能包含，修改密码并删除localStorage里面存的东西；验证输入密码是否与设置的相同；设置密码时各种不符合规则的检查等。 关键代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556oLock.prototype.selectFun=function()&#123; var aInput=document.getElementsByTagName("input"); var that=this; aInput[0].onfocus=function()&#123; document.getElementById('header').innerHTML="请解锁"; oLock.prototype.doPassword=function(pw)&#123; if( window.localStorage.getItem('password') )&#123; if(that.pwObj.nowPw)&#123; if(that.checkPassword(that.pwObj.nowPw,pw))&#123; document.getElementById('header').innerHTML='解锁成功'; that.createCleLine('#00F90F'); &#125;else&#123; document.getElementById('header').innerHTML='解锁失败'; that.createCleLine('red'); &#125; &#125;else&#123; alert("还未设置密码"); &#125; &#125;else&#123; alert("还未设置密码"); &#125; &#125; &#125;; aInput[1].onfocus=function()&#123; document.getElementById('header').innerHTML="请绘制解锁图案"; that.pwObj=&#123;&#125;; that.getPoint(); oLock.prototype.doPassword=function(pw)&#123; if(that.pwObj.step==1)&#123; if(that.checkPassword(that.pwObj.formerPw,pw))&#123; that.pwObj.step=2; that.pwObj.nowPw=pw; document.getElementById('header').innerHTML='密码保存成功'; that.createCleLine('#00F90F'); window.localStorage.setItem('password',JSON.stringify(that.pwObj.nowPw)); &#125;else&#123; document.getElementById('header').innerHTML="两次输入不一致，请重新输入"; that.createCleLine('red'); delete that.pwObj.step; &#125; &#125;else&#123; if(pw.length&lt;5)&#123; document.getElementById('header').innerHTML="密码太短，至少需要五个点"; that.createCleLine('red'); that.pwObj=&#123;&#125;; &#125;else&#123; that.pwObj.step=1; that.pwObj.formerPw=pw; document.getElementById('header').innerHTML="再次输入"; &#125; &#125; &#125; &#125;;&#125; 这个函数主要功能就是通过单选按钮来控制是设置密码还是验证密码，具体做法就是通过改变oLock.prototype.doPassword来实现的，不同的选择会使oLock.prototype.doPassword里面对应的方法不同，从而实现模式的切换。 遇到的坑：在打开页面的时候并没有触发onfocus事件，所以oLock.prototype.doPassword就不会被定义。解决方法就是在外面先定义一下这个方法。]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据结构与算法学习笔记(一)]]></title>
    <url>%2F2018%2F02%2F25%2Fjs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[JavaScript数据结构与算法学习笔记(一) 前言：考完研啦，前端大半年没碰了，最近开始恶补一番😂。去年参加了几次实习生招聘，吃亏在数据结构和算法方面，最近在专门针对这方面进行学习。在这里记录下自己需要熟记的一些知识点以及弱项。首先从难的开始～ 排序总结六种排序方式实现：冒泡排序、选择排序、插入排序、归并排序、快速排序和堆排序 1.冒泡排序原理：比较相邻的两个项，如果第一个比第二个大，则交换他们。实现如下 12345678910111213var bubbleSort=function(arr)&#123; var length=arr.length; for(var i=0;i&lt;length;i++)&#123; for(var j=0;j&lt;length-1;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; swap(arr,j,j+1); //交换值的函数 &#125; &#125; &#125;&#125;function swap(arr,i,j)&#123; [arr[i],arr[j]]=[arr[j],arr[i]]; &#125; 外包围的循环控制经过了多少轮排序，内包围的将第一位迭代至倒数第二位，这种冒泡排序会比较已经排好的元素，性能会下降。下面是改进后的冒泡排序 12345678910var modifiedBubbleSort=function(arr)&#123; var length=arr.length; for(var i=0;i&lt;length;i++)&#123; for(var j=0;j&lt;length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; swap(arr,j,j+1); &#125; &#125; &#125;&#125; 2.选择排序大致思路：找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推 123456789101112131415var selectionSort=function(arr)&#123; var length=arr.length, indexMin; for(var i=0;i&lt;length-1;i++)&#123; indexMin=i; for(var j=i;j&lt;length;j++)&#123; if(arr[indexMin]&gt;arr[j])&#123; indexMin=j; &#125; &#125; if(i!==indexMin)&#123; swap(arr,indexMin,i); &#125; &#125;&#125; 流程： 首先假设本迭代轮次的第一个值为数组的最小值 从当前i的值开始至数组结束，比较j的值是否比当前最小值小；如果是，则将j的值作为最小值 如果最小值和原来的最小值不同，则交换他俩 冒泡排序和选择排序一样，它们都包含了嵌套的两个循环，导致了二次方的复杂度。 3.插入排序原理：插入排序每次排一个数组项，以此方式构建最后的排序数组。例如，第一项已经排好，现在比较第二项和第一项，看看第二项是呆在原地还是插入到第一项的前面？接着，操作第三项，通过和前两项的比较，看看第三项是插入到哪地方。我的个人理解就是：数组的某一项在他前面所有项依次进行比较，如果找到比他大的实现如下： 12345678910111213var insertionSort=function(arr)&#123; var length=arr.length, j,temp; for(var i=1;i&lt;length;i++)&#123; //假定第一项已经排好，所以i从1开始 j=i; temp=arr[i]; while(j&gt;0 &amp;&amp; arr[j-1]&gt;temp)&#123; arr[j]=arr[j-1]; j--; &#125; arr[j]=temp; &#125;&#125; 此算法性能好于选择排序和冒泡排序 4.归并排序 归并排序是第一个可以实际使用的排序算法，复杂度为O(nlogn) 原理：把原始数组分成比较小的数组，直到每个小数组只有一个位置，接着将小数组归并成比较大的数组，直到最后只有一个排序完毕的大数组。我的理解就是，第一步把数组切分成只有一项元素的子数组；第二步再把这些子数组依次合并，最终变成一个完整的数组。 当实现一个递归函数，我们都会实现一个实际被执行的辅助函数。如下先实现merge函数，他负责合并和排序小数组来产生大数组 12345678910111213141516171819202122var merge = function(left,right)&#123; //接收两个参数，排序发生在合并过程中 var result=[], il=0, ir=0; while(il&lt;left.length &amp;&amp; ir&lt;right.length)&#123; //依次比较来自left数组的项是否比来自right数组的项要小，如果是，则将该元素添加到result数组中，并递增迭代数组的控制变量，否则则操作right if(left[il]&lt;right[ir])&#123; result.push(left[il++]); &#125;else&#123; result.push(right[ir++]); &#125; &#125; while(il&lt;left.length)&#123; //将剩余的的项添加到result数组中 result.push(left[il++]); &#125; while(ir&lt;right.length)&#123; result.push(right[ir++]); &#125; return result;&#125; 接下来，定义一个递归函数，作用利用递归把数组切成只有一项，然后调用merge函数进行合并排序 123456789101112var mergeSortRec=function(arr)&#123; var length=arr.length; if(arr.length==1)&#123; //递归的停止条件，如果数组长度是1，则返回这个长度为1的数组。 return arr; &#125; var mid=Math.floor(length/2); var left=arr.slice(0,mid); var right=arr.slilce(mid,length); return merge(mergeSortRec(left),mergeSortRec(right));&#125; 最后，定义一个mergeSort函数完成整个归并算法 123var mergeSort=function(arr)&#123; arr=mergeSortRec(arr);&#125; 归并排序的时间复杂度为O(nlogn) 5.快速排序 步骤：1、从数组中选择中间一项作为主元2、创建两个指针，左边一个指向数组的第一项，右边一个指向数组的最后一项。移动左指针直到找到一个比主元大的元素，接着，移动右指针直到找到一个比主元小的元素，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在了主元之前，而比主元大的值都排在了主元之后。这一步叫划分操作。3、接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复前两个步骤，直到数组完全排序。 123function quickSort(arr)&#123; quick(arr,0,arr.length-1);&#125; 像归并排序一样，首先定义一个主函数来调用递归函数，传递待排数组，以及索引0及最末的位置。 5.1 划分操作的实现第一件事情就是要选择主元（pivot）。我们选择中间项作为主元 1234567891011121314151617181920var partition=function(arr,left,right)&#123; var pivot=arr[Math.floor((left+right)/2)]; var i=left; var j=right; while(i&lt;=j)&#123; while(arr[i]&lt;pivot)&#123; i++ &#125; while(arr[j]&gt;pivot)&#123; j-- &#125; if(i&lt;=j)&#123; swap(arr,i,j); i++; j-- &#125; &#125; return i;&#125; 当左指针指向的元素比主元大且右指针指向的元素比主元小，并且此时左指针索引没有右指针索引大。然后交换他俩，移动指针，并重复此过程。下面实现递归函数quick 1234567891011121314var quick=function(arr,left,right)&#123; var index; if(arr.length&gt;1)&#123; index=partition(arr,left,right); if(left&lt;index-1)&#123; quick(arr,left,index-1); &#125; if(index&lt;right)&#123; quick(arr,index,right) &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建博客心得]]></title>
    <url>%2F2018%2F02%2F24%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[MAC环境下利用Hexo+github搭建博客心得 前言：此次是利用hexo+github搭建博客，主要目的就是整理之前的项目，梳理一下思路，方便在面试的时候有所展示；同时也方便今后学习和项目的总结～ 搭建这个博客我花了一天时间，主要是通过参考他人搭建经历完成的。网上搭建流程有很多，在此就不再赘述。本文主要是记录下自己在搭建博客中学到的东西和踩过的坑。 1.what’s Hexo?Hexo是一个快速, 简洁且高效的博客框架. 让上百个页面在几秒内瞬间完成渲染. Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件. 并自己也拥有强大的插件系统. 2.Hexo相关指令 安装Hexo 之前得安装好nodejs，在安装好nodejs之后，在终端执行下列指令 1$ sudo npm install -g hexo-cli 坑一：Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。 初始化 首先必须cd到准备用来搭建博客的文件夹，执行hexo init命令 接着在该文件夹下执行npm的安装指令npm install 最后开启hexo服务器hexo s，并在浏览器中打开http://localhost:4000可以见到初始化页面 更新主题配置和部署文章 每次文章发布和主题属性都要进行以下步骤才能同步到博客上 123$ hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)$ hexo g //生成缓存和静态文件$ hexo d //重新部署到服务器 3.next主题配置 坑二：在配置站点配置文件和主题配置文件时（所有的_config.yml），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错。切记，很坑😂 菜单设置 通过修改next主题下的_config.yml的menu字段，选定显示的菜单项。 1234567menu: home: / categories: /categories about: /about archives: /archives tags: /tags #commonweal: /404.html 其中，home代表主页，categories代表分类页，about代表关于页面，archives代表归档页，commonweal代表404页面（page not found时候显示的页面）。在设置好菜单后，就会出现这一系列按钮，此时点击这些按钮时，会弹出页面不存在，这是因为这些页面还没设置的原因 添加标签页面 1.新建页面 12$ cd Blog //Blog是选择作为搭建博客的那个文件夹名称$ hexo new page tags 2.设置页面的类型在上步新生成的myBlog/source/tags/index.md中添加type: &quot;tags&quot;，index.md文件内容如下： 123title: tagsdate: 2018-02-24 09:40:00type: &quot;tags&quot; //加上这句话 添加标签才能起作用 3.设置具体文章的tags 123title: 搭建博客心得categories: 搭建博客tags: [npm, hexo, github] 添加分类页面 步骤和添加标签页面一摸一样，只需将tags改成categories 添加关于我(about)页面 1.新建页面 12$ cd myBlog$ hexo new page about 输入命令后，在myBlog/source下会新生成一个新的文件夹about，在该文件夹下会有一个index.md文件。 2.修改index.md 我的index.md配置如下 1234567891011121314---title: aboutdate: 2018-02-23 13:13:14---##关于我一只正在如饥似渴学习前端的小菜鸟～微信：zfight13QQ: 707085615Email: scty8888@163.com]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
